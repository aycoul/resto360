---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - docker/Dockerfile.api
  - docker/docker-compose.yml
  - docker/.env.docker
  - .github/workflows/ci.yml
  - render.yaml
  - scripts/dev-setup.sh
  - scripts/dev-setup.ps1
  - Makefile
autonomous: true

must_haves:
  truths:
    - "Developer can start full local environment with single command"
    - "All services (API, PostgreSQL, Redis) run in Docker containers"
    - "Code changes trigger automated lint and tests on GitHub"
    - "Staging deployment happens automatically when tests pass on develop branch"
    - "render.yaml defines complete infrastructure for Render.com"
  artifacts:
    - path: "docker/docker-compose.yml"
      provides: "Docker Compose configuration for local dev"
      contains: "postgres:15"
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
      contains: "pytest"
    - path: "render.yaml"
      provides: "Render.com Blueprint specification"
      contains: "resto360-api"
    - path: "Makefile"
      provides: "Developer commands"
      contains: "dev-up"
  key_links:
    - from: "docker/docker-compose.yml"
      to: "apps/api"
      via: "volume mount"
      pattern: "../apps/api:/app"
    - from: ".github/workflows/ci.yml"
      to: "render.yaml"
      via: "deploy hook"
      pattern: "RENDER_STAGING_DEPLOY_HOOK"
    - from: "scripts/dev-setup.sh"
      to: "docker/docker-compose.yml"
      via: "docker-compose up"
      pattern: "docker-compose"
---

<objective>
Set up CI/CD pipeline and Docker-based development environment.

Purpose: Enable consistent local development across machines and automated quality gates (lint, test) with deployment to staging when code merges to develop branch.

Output: Docker Compose for local dev, GitHub Actions CI workflow, Render.com Blueprint (render.yaml), and developer convenience scripts.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose development environment</name>
  <files>
    docker/Dockerfile.api
    docker/docker-compose.yml
    docker/.env.docker
    apps/api/.dockerignore
  </files>
  <action>
Create `docker/Dockerfile.api`:
```dockerfile
# Development Dockerfile for Django API
FROM python:3.12-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements/development.txt requirements/development.txt
COPY requirements/base.txt requirements/base.txt
RUN pip install --no-cache-dir -r requirements/development.txt

# Copy project
COPY . .

# Expose port
EXPOSE 8000

# Default command
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
```

Create `docker/docker-compose.yml` (from RESEARCH.md):
```yaml
version: '3.9'

services:
  api:
    build:
      context: ../apps/api
      dockerfile: ../../docker/Dockerfile.api
    container_name: resto360-api
    ports:
      - "8000:8000"
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings.development
      - DATABASE_URL=postgres://resto360:resto360@db:5432/resto360
      - REDIS_URL=redis://redis:6379/0
      - DEBUG=true
      - SECRET_KEY=dev-secret-key-not-for-production
      - ALLOWED_HOSTS=localhost,127.0.0.1
    volumes:
      - ../apps/api:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    command: >
      sh -c "python manage.py migrate &&
             python manage.py runserver 0.0.0.0:8000"

  db:
    image: postgres:15-alpine
    container_name: resto360-db
    environment:
      POSTGRES_DB: resto360
      POSTGRES_USER: resto360
      POSTGRES_PASSWORD: resto360
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U resto360 -d resto360"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: resto360-redis
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data
    command: redis-server --appendonly yes

  # Test runner service (for running tests in container)
  test:
    build:
      context: ../apps/api
      dockerfile: ../../docker/Dockerfile.api
    container_name: resto360-test
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings.testing
      - DATABASE_URL=postgres://resto360:resto360@db:5432/resto360_test
      - REDIS_URL=redis://redis:6379/1
      - SECRET_KEY=test-secret-key
    volumes:
      - ../apps/api:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    command: pytest --cov=apps --cov-report=term-missing
    profiles:
      - test

volumes:
  pgdata:
  redisdata:

networks:
  default:
    name: resto360-network
```

Create `docker/.env.docker`:
```bash
# Docker environment variables
# Copy to docker/.env and customize if needed

POSTGRES_DB=resto360
POSTGRES_USER=resto360
POSTGRES_PASSWORD=resto360

DJANGO_SETTINGS_MODULE=config.settings.development
DATABASE_URL=postgres://resto360:resto360@db:5432/resto360
REDIS_URL=redis://redis:6379/0
DEBUG=true
SECRET_KEY=dev-secret-key-not-for-production
ALLOWED_HOSTS=localhost,127.0.0.1
```

Create `apps/api/.dockerignore`:
```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
.venv/
venv/
env/

# Django
*.log
db.sqlite3
staticfiles/
media/

# Testing
.coverage
htmlcov/
.pytest_cache/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Git
.git/
.gitignore

# Docker
Dockerfile*

# Misc
*.md
!requirements/*.txt
```
  </action>
  <verify>
    ls -la docker/ && cat docker/docker-compose.yml | head -30
  </verify>
  <done>
    Docker Compose configuration exists with API, PostgreSQL 15, and Redis 7 services
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub Actions CI pipeline</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
Create `.github/workflows/ci.yml` (from RESEARCH.md):
```yaml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  PYTHON_VERSION: "3.12"

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install ruff
        run: pip install ruff

      - name: Run ruff check
        run: ruff check apps/api/

      - name: Run ruff format check
        run: ruff format --check apps/api/

  test:
    name: Test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: resto360_test
          POSTGRES_USER: resto360
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('apps/api/requirements/testing.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: pip install -r apps/api/requirements/testing.txt

      - name: Run Django checks
        working-directory: apps/api
        env:
          DATABASE_URL: postgres://resto360:postgres@localhost:5432/resto360_test
          REDIS_URL: redis://localhost:6379/0
          DJANGO_SETTINGS_MODULE: config.settings.testing
          SECRET_KEY: test-secret-key-for-ci
        run: python manage.py check

      - name: Run migrations
        working-directory: apps/api
        env:
          DATABASE_URL: postgres://resto360:postgres@localhost:5432/resto360_test
          REDIS_URL: redis://localhost:6379/0
          DJANGO_SETTINGS_MODULE: config.settings.testing
          SECRET_KEY: test-secret-key-for-ci
        run: python manage.py migrate

      - name: Run tests with coverage
        working-directory: apps/api
        env:
          DATABASE_URL: postgres://resto360:postgres@localhost:5432/resto360_test
          REDIS_URL: redis://localhost:6379/0
          DJANGO_SETTINGS_MODULE: config.settings.testing
          SECRET_KEY: test-secret-key-for-ci
        run: pytest --cov=apps --cov-report=xml --cov-report=term-missing -v

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: apps/api/coverage.xml
          fail_ci_if_error: false
          verbose: true
        continue-on-error: true

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install pip-audit
        run: pip install pip-audit

      - name: Run pip-audit
        run: pip-audit -r apps/api/requirements/base.txt
        continue-on-error: true  # Don't fail on vulnerabilities initially

  deploy-staging:
    name: Deploy to Staging
    needs: [lint, test]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Trigger Render Deploy
        run: |
          curl -X POST "${{ secrets.RENDER_STAGING_DEPLOY_HOOK }}"
        env:
          RENDER_STAGING_DEPLOY_HOOK: ${{ secrets.RENDER_STAGING_DEPLOY_HOOK }}

  deploy-production:
    name: Deploy to Production
    needs: [lint, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Trigger Render Deploy
        run: |
          curl -X POST "${{ secrets.RENDER_PRODUCTION_DEPLOY_HOOK }}"
        env:
          RENDER_PRODUCTION_DEPLOY_HOOK: ${{ secrets.RENDER_PRODUCTION_DEPLOY_HOOK }}
```

This CI pipeline:
1. **Lint job**: Runs ruff check and format verification
2. **Test job**: Runs pytest with PostgreSQL and Redis services
3. **Security job**: Runs pip-audit for dependency vulnerabilities
4. **Deploy staging**: Triggers Render deploy hook when develop branch passes tests
5. **Deploy production**: Triggers Render deploy hook when main branch passes tests
  </action>
  <verify>
    cat .github/workflows/ci.yml | head -60
  </verify>
  <done>
    GitHub Actions CI workflow exists with lint, test, security, and deploy jobs
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Render.com Blueprint and developer convenience scripts</name>
  <files>
    render.yaml
    scripts/dev-setup.sh
    scripts/dev-setup.ps1
    Makefile
  </files>
  <action>
Create `render.yaml` (from RESEARCH.md):
```yaml
# Render.com Blueprint
# Deploy: Connect GitHub repo to Render, it auto-detects this file

databases:
  - name: resto360-db
    databaseName: resto360
    user: resto360
    plan: starter  # Upgrade for persistence (free tier resets)
    postgresMajorVersion: 15
    ipAllowList: []  # Only Render internal network

services:
  # Redis key-value store
  - type: redis
    name: resto360-redis
    plan: starter
    maxmemoryPolicy: allkeys-lru
    ipAllowList: []  # Only Render internal network

  # Django API service
  - type: web
    name: resto360-api
    runtime: python
    plan: starter
    region: frankfurt  # Closest to West Africa
    rootDir: apps/api
    buildCommand: |
      pip install -r requirements/production.txt
      python manage.py collectstatic --noinput
    startCommand: gunicorn config.wsgi:application --bind 0.0.0.0:$PORT --workers 2
    healthCheckPath: /health/
    autoDeploy: false  # Manual deploys (triggered by CI)
    envVars:
      - key: PYTHON_VERSION
        value: "3.12.0"
      - key: DJANGO_SETTINGS_MODULE
        value: config.settings.production
      - key: DATABASE_URL
        fromDatabase:
          name: resto360-db
          property: connectionString
      - key: REDIS_URL
        fromService:
          name: resto360-redis
          type: redis
          property: connectionString
      - key: SECRET_KEY
        generateValue: true
      - key: ALLOWED_HOSTS
        sync: false  # Set manually: resto360-api.onrender.com,yourdomain.com
      - key: CORS_ALLOWED_ORIGINS
        sync: false  # Set manually: https://yourdomain.com

# Environment variable groups (shared secrets)
envVarGroups:
  - name: resto360-shared
    envVars:
      - key: SENTRY_DSN
        sync: false  # Add manually when Sentry is configured
```

Create `scripts/dev-setup.sh`:
```bash
#!/bin/bash
# Development environment setup script for Unix/macOS/Linux

set -e

echo "======================================"
echo "RESTO360 Development Environment Setup"
echo "======================================"
echo ""

# Check for Docker
if ! command -v docker &> /dev/null; then
    echo "ERROR: Docker is not installed."
    echo "Please install Docker Desktop from https://www.docker.com/products/docker-desktop"
    exit 1
fi

# Check for Docker Compose
if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
    echo "ERROR: Docker Compose is not installed."
    echo "Please install Docker Compose: https://docs.docker.com/compose/install/"
    exit 1
fi

# Check if .env exists, create from example if not
if [ ! -f "apps/api/.env" ]; then
    echo "Creating apps/api/.env from .env.example..."
    cp .env.example apps/api/.env
    echo "IMPORTANT: Edit apps/api/.env with your local settings if needed."
    echo ""
fi

# Build and start containers
echo "Building and starting Docker containers..."
cd docker
docker-compose up -d --build

echo ""
echo "Waiting for database to be ready..."
sleep 5

# Run migrations
echo "Running database migrations..."
docker-compose exec api python manage.py migrate

# Create superuser prompt
echo ""
echo "======================================"
echo "Setup Complete!"
echo "======================================"
echo ""
echo "Services running:"
echo "  - API:      http://localhost:8000"
echo "  - Database: localhost:5432 (resto360/resto360)"
echo "  - Redis:    localhost:6379"
echo ""
echo "Useful commands:"
echo "  make dev-up      - Start all services"
echo "  make dev-down    - Stop all services"
echo "  make dev-logs    - View logs"
echo "  make test        - Run tests"
echo "  make lint        - Run linter"
echo "  make shell       - Django shell"
echo ""
echo "To create a superuser:"
echo "  docker-compose exec api python manage.py createsuperuser"
echo ""
```

Create `scripts/dev-setup.ps1`:
```powershell
# Development environment setup script for Windows PowerShell

Write-Host "======================================" -ForegroundColor Cyan
Write-Host "RESTO360 Development Environment Setup" -ForegroundColor Cyan
Write-Host "======================================" -ForegroundColor Cyan
Write-Host ""

# Check for Docker
try {
    docker --version | Out-Null
} catch {
    Write-Host "ERROR: Docker is not installed." -ForegroundColor Red
    Write-Host "Please install Docker Desktop from https://www.docker.com/products/docker-desktop"
    exit 1
}

# Check if .env exists, create from example if not
if (-not (Test-Path "apps/api/.env")) {
    Write-Host "Creating apps/api/.env from .env.example..."
    Copy-Item ".env.example" "apps/api/.env"
    Write-Host "IMPORTANT: Edit apps/api/.env with your local settings if needed." -ForegroundColor Yellow
    Write-Host ""
}

# Build and start containers
Write-Host "Building and starting Docker containers..." -ForegroundColor Yellow
Set-Location docker
docker-compose up -d --build

Write-Host ""
Write-Host "Waiting for database to be ready..."
Start-Sleep -Seconds 5

# Run migrations
Write-Host "Running database migrations..."
docker-compose exec api python manage.py migrate

Write-Host ""
Write-Host "======================================" -ForegroundColor Green
Write-Host "Setup Complete!" -ForegroundColor Green
Write-Host "======================================" -ForegroundColor Green
Write-Host ""
Write-Host "Services running:"
Write-Host "  - API:      http://localhost:8000"
Write-Host "  - Database: localhost:5432 (resto360/resto360)"
Write-Host "  - Redis:    localhost:6379"
Write-Host ""
Write-Host "Useful commands:"
Write-Host "  make dev-up      - Start all services"
Write-Host "  make dev-down    - Stop all services"
Write-Host "  make dev-logs    - View logs"
Write-Host "  make test        - Run tests"
Write-Host "  make lint        - Run linter"
Write-Host "  make shell       - Django shell"
Write-Host ""
Write-Host "To create a superuser:"
Write-Host "  docker-compose exec api python manage.py createsuperuser"
Write-Host ""

Set-Location ..
```

Create `Makefile`:
```makefile
# RESTO360 Development Makefile
# Run 'make help' to see available commands

.PHONY: help dev-up dev-down dev-logs dev-restart test lint format shell migrate makemigrations createsuperuser clean

# Default target
help:
	@echo "RESTO360 Development Commands"
	@echo "=============================="
	@echo ""
	@echo "Development:"
	@echo "  make dev-up        Start all services (Docker Compose)"
	@echo "  make dev-down      Stop all services"
	@echo "  make dev-restart   Restart all services"
	@echo "  make dev-logs      View service logs (follow mode)"
	@echo ""
	@echo "Testing & Quality:"
	@echo "  make test          Run all tests"
	@echo "  make test-cov      Run tests with coverage report"
	@echo "  make lint          Run ruff linter"
	@echo "  make format        Format code with ruff"
	@echo ""
	@echo "Django:"
	@echo "  make shell         Open Django shell"
	@echo "  make migrate       Run database migrations"
	@echo "  make makemigrations  Create new migrations"
	@echo "  make createsuperuser  Create Django superuser"
	@echo ""
	@echo "Cleanup:"
	@echo "  make clean         Remove containers, volumes, and cache"
	@echo ""

# Development environment
dev-up:
	cd docker && docker-compose up -d --build
	@echo ""
	@echo "Services started:"
	@echo "  API:      http://localhost:8000"
	@echo "  Database: localhost:5432"
	@echo "  Redis:    localhost:6379"

dev-down:
	cd docker && docker-compose down

dev-restart:
	cd docker && docker-compose restart

dev-logs:
	cd docker && docker-compose logs -f

# Testing
test:
	cd docker && docker-compose exec api pytest -v

test-cov:
	cd docker && docker-compose exec api pytest --cov=apps --cov-report=html --cov-report=term-missing

test-local:
	cd apps/api && pytest -v

# Linting and formatting
lint:
	ruff check apps/api/

lint-docker:
	cd docker && docker-compose exec api ruff check .

format:
	ruff format apps/api/

format-check:
	ruff format --check apps/api/

# Django commands
shell:
	cd docker && docker-compose exec api python manage.py shell

migrate:
	cd docker && docker-compose exec api python manage.py migrate

makemigrations:
	cd docker && docker-compose exec api python manage.py makemigrations

createsuperuser:
	cd docker && docker-compose exec api python manage.py createsuperuser

# Cleanup
clean:
	cd docker && docker-compose down -v --remove-orphans
	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	find . -type d -name "htmlcov" -exec rm -rf {} + 2>/dev/null || true
	find . -type f -name ".coverage" -delete 2>/dev/null || true
```

Make scripts executable (Unix):
```bash
chmod +x scripts/dev-setup.sh
```
  </action>
  <verify>
    cat render.yaml | head -40 && cat Makefile | head -30
  </verify>
  <done>
    Render.com Blueprint (render.yaml), dev setup scripts, and Makefile exist
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Docker Compose starts successfully:
   ```bash
   cd docker && docker-compose up -d
   docker-compose ps  # All services running
   curl http://localhost:8000/health/  # Returns {"status": "ok"}
   ```

2. Tests run in Docker:
   ```bash
   cd docker && docker-compose --profile test run test
   # All tests pass
   ```

3. CI workflow file is valid:
   ```bash
   # GitHub Actions will validate on push, but we can check syntax
   cat .github/workflows/ci.yml | python -c "import yaml,sys; yaml.safe_load(sys.stdin)"
   ```

4. render.yaml is valid:
   ```bash
   cat render.yaml | python -c "import yaml,sys; yaml.safe_load(sys.stdin)"
   ```

5. Makefile works:
   ```bash
   make help  # Shows all commands
   make lint  # Runs ruff
   ```
</verification>

<success_criteria>
- Docker Compose with PostgreSQL 15, Redis 7, and Django API
- API service auto-runs migrations on startup
- Volumes persist database data between restarts
- GitHub Actions CI runs on push to main/develop
- CI pipeline: lint -> test -> security -> deploy
- Deploy to staging triggers on develop branch
- Deploy to production triggers on main branch
- render.yaml defines complete Render.com infrastructure
- Makefile provides all common developer commands
- Setup scripts for both Unix (bash) and Windows (PowerShell)
- Developer can run `make dev-up` to start everything
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
