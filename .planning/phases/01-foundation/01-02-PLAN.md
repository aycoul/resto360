---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/api/apps/core/models.py
  - apps/api/apps/core/managers.py
  - apps/api/apps/core/context.py
  - apps/api/apps/core/middleware.py
  - apps/api/apps/core/permissions.py
  - apps/api/apps/core/pagination.py
  - apps/api/apps/authentication/__init__.py
  - apps/api/apps/authentication/models.py
  - apps/api/apps/authentication/serializers.py
  - apps/api/apps/authentication/views.py
  - apps/api/apps/authentication/urls.py
  - apps/api/apps/authentication/admin.py
  - apps/api/apps/authentication/tests/__init__.py
  - apps/api/apps/authentication/tests/factories.py
  - apps/api/apps/authentication/tests/conftest.py
  - apps/api/apps/authentication/tests/test_models.py
  - apps/api/apps/authentication/tests/test_auth_api.py
  - apps/api/config/settings/base.py
  - apps/api/config/urls.py
autonomous: true

must_haves:
  truths:
    - "Restaurant owner can register with phone number and create restaurant"
    - "User can log in with phone/password and receive JWT tokens"
    - "User can refresh access token using refresh token"
    - "User can log out and refresh token is blacklisted"
    - "Staff can only access data from their own restaurant"
    - "Role-based permissions restrict endpoint access appropriately"
  artifacts:
    - path: "apps/api/apps/authentication/models.py"
      provides: "User, Restaurant, and role models"
      contains: "class User"
    - path: "apps/api/apps/core/middleware.py"
      provides: "TenantMiddleware for multi-tenancy"
      contains: "TenantMiddleware"
    - path: "apps/api/apps/core/permissions.py"
      provides: "Role-based permission classes"
      exports: ["IsOwner", "IsOwnerOrManager", "IsSameRestaurant"]
    - path: "apps/api/apps/authentication/serializers.py"
      provides: "Custom JWT serializer with restaurant claims"
      contains: "CustomTokenObtainPairSerializer"
  key_links:
    - from: "apps/api/apps/core/middleware.py"
      to: "apps/api/apps/core/context.py"
      via: "set_current_restaurant"
      pattern: "set_current_restaurant"
    - from: "apps/api/apps/core/managers.py"
      to: "apps/api/apps/core/context.py"
      via: "get_current_restaurant"
      pattern: "get_current_restaurant"
    - from: "apps/api/apps/authentication/views.py"
      to: "rest_framework_simplejwt"
      via: "token endpoints"
      pattern: "TokenObtainPairView"
---

<objective>
Implement multi-tenant database architecture and JWT authentication with role-based permissions.

Purpose: Enable secure, isolated access for restaurant staff where each user can only see their restaurant's data, and permissions are enforced based on role (owner, manager, cashier, kitchen, driver).

Output: Working authentication system with custom User model, Restaurant model, JWT tokens with custom claims, tenant isolation via middleware/managers, and role-based permissions.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core app with base models, tenant manager, and middleware</name>
  <files>
    apps/api/apps/core/__init__.py
    apps/api/apps/core/apps.py
    apps/api/apps/core/models.py
    apps/api/apps/core/managers.py
    apps/api/apps/core/context.py
    apps/api/apps/core/middleware.py
    apps/api/apps/core/permissions.py
    apps/api/apps/core/pagination.py
  </files>
  <action>
Create `apps/api/apps/core/apps.py`:
```python
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.core"
```

Create `apps/api/apps/core/models.py` (from RESEARCH.md Pattern 1):
```python
from django.db import models
from django.utils import timezone
import uuid

class BaseModel(models.Model):
    """Abstract base for all models with UUID primary key."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    created_at = models.DateTimeField(default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class TenantModel(BaseModel):
    """Abstract base for tenant-scoped models."""
    restaurant = models.ForeignKey(
        "authentication.Restaurant",
        on_delete=models.CASCADE,
        related_name="%(class)ss",
    )

    class Meta:
        abstract = True
```

Create `apps/api/apps/core/context.py`:
```python
from contextvars import ContextVar
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from apps.authentication.models import Restaurant

_current_restaurant: ContextVar[Optional["Restaurant"]] = ContextVar(
    "current_restaurant", default=None
)

def get_current_restaurant() -> Optional["Restaurant"]:
    return _current_restaurant.get()

def set_current_restaurant(restaurant: Optional["Restaurant"]) -> None:
    _current_restaurant.set(restaurant)
```

Create `apps/api/apps/core/managers.py`:
```python
from django.db import models
from .context import get_current_restaurant

class TenantManager(models.Manager):
    """Auto-filters queryset by current tenant."""

    def get_queryset(self):
        qs = super().get_queryset()
        restaurant = get_current_restaurant()
        if restaurant:
            return qs.filter(restaurant=restaurant)
        return qs
```

Create `apps/api/apps/core/middleware.py` (from RESEARCH.md Pattern 2):
```python
from django.utils.deprecation import MiddlewareMixin
from .context import set_current_restaurant

class TenantMiddleware(MiddlewareMixin):
    """Extract restaurant from authenticated user and set tenant context."""

    def process_request(self, request):
        if hasattr(request, "user") and request.user.is_authenticated:
            if hasattr(request.user, "restaurant") and request.user.restaurant:
                set_current_restaurant(request.user.restaurant)
        return None

    def process_response(self, request, response):
        set_current_restaurant(None)  # Clear context after request
        return response
```

Create `apps/api/apps/core/permissions.py` (from RESEARCH.md Pattern 4):
```python
from rest_framework import permissions

class IsOwner(permissions.BasePermission):
    """Only restaurant owners can access."""

    def has_permission(self, request, view):
        return (
            request.user.is_authenticated
            and request.user.role == "owner"
        )


class IsOwnerOrManager(permissions.BasePermission):
    """Owners and managers can access."""

    def has_permission(self, request, view):
        return (
            request.user.is_authenticated
            and request.user.role in ("owner", "manager")
        )


class IsCashier(permissions.BasePermission):
    """Cashiers and above can access (owner, manager, cashier)."""

    def has_permission(self, request, view):
        return (
            request.user.is_authenticated
            and request.user.role in ("owner", "manager", "cashier")
        )


class IsSameRestaurant(permissions.BasePermission):
    """User can only access their own restaurant's data."""

    def has_object_permission(self, request, view, obj):
        if hasattr(obj, "restaurant"):
            return obj.restaurant == request.user.restaurant
        return True
```

Create `apps/api/apps/core/pagination.py`:
```python
from rest_framework.pagination import PageNumberPagination

class StandardPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = "page_size"
    max_page_size = 100
```

Update `apps/api/config/settings/base.py`:
- Add "apps.core" to INSTALLED_APPS
- Add "apps.core.middleware.TenantMiddleware" to MIDDLEWARE (after AuthenticationMiddleware)
- Update DEFAULT_PAGINATION_CLASS to "apps.core.pagination.StandardPagination"
  </action>
  <verify>
    cd apps/api && python manage.py check
  </verify>
  <done>
    Core app exists with BaseModel, TenantModel, TenantManager, TenantMiddleware, and permission classes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create authentication app with User and Restaurant models</name>
  <files>
    apps/api/apps/authentication/__init__.py
    apps/api/apps/authentication/apps.py
    apps/api/apps/authentication/models.py
    apps/api/apps/authentication/serializers.py
    apps/api/apps/authentication/views.py
    apps/api/apps/authentication/urls.py
    apps/api/apps/authentication/admin.py
    apps/api/config/settings/base.py
    apps/api/config/urls.py
  </files>
  <action>
Create `apps/api/apps/authentication/apps.py`:
```python
from django.apps import AppConfig

class AuthenticationConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.authentication"
```

Create `apps/api/apps/authentication/models.py` (from RESEARCH.md Pattern 3):
```python
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.db import models
from apps.core.models import BaseModel


class UserManager(BaseUserManager):
    def create_user(self, phone, password=None, **extra_fields):
        if not phone:
            raise ValueError("Users must have a phone number")
        user = self.model(phone=phone, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, phone, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("role", "owner")
        return self.create_user(phone, password, **extra_fields)


class Restaurant(BaseModel):
    """A restaurant tenant in the system."""

    name = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    phone = models.CharField(max_length=20)
    email = models.EmailField(blank=True)
    address = models.TextField(blank=True)
    timezone = models.CharField(max_length=50, default="Africa/Abidjan")
    currency = models.CharField(max_length=3, default="XOF")
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return self.name


class User(AbstractBaseUser, PermissionsMixin, BaseModel):
    """Custom user with phone number as username."""

    ROLE_CHOICES = [
        ("owner", "Owner"),
        ("manager", "Manager"),
        ("cashier", "Cashier"),
        ("kitchen", "Kitchen"),
        ("driver", "Driver"),
    ]

    phone = models.CharField(max_length=20, unique=True)
    email = models.EmailField(blank=True)
    name = models.CharField(max_length=150)
    restaurant = models.ForeignKey(
        Restaurant,
        on_delete=models.CASCADE,
        related_name="staff",
        null=True,
        blank=True,  # Null for superusers without restaurant
    )
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default="cashier")
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    language = models.CharField(max_length=10, default="fr")

    objects = UserManager()

    USERNAME_FIELD = "phone"
    REQUIRED_FIELDS = ["name"]

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return f"{self.name} ({self.phone})"

    def get_permissions_list(self):
        """Return list of permissions based on role."""
        base_permissions = ["view_menu", "view_orders"]
        role_permissions = {
            "owner": ["manage_restaurant", "manage_staff", "manage_menu", "view_reports", "manage_orders"],
            "manager": ["manage_menu", "view_reports", "manage_orders"],
            "cashier": ["create_orders", "manage_orders"],
            "kitchen": ["update_order_status"],
            "driver": ["view_deliveries", "update_delivery_status"],
        }
        return base_permissions + role_permissions.get(self.role, [])
```

Create `apps/api/apps/authentication/serializers.py`:
```python
from rest_framework import serializers
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from .models import User, Restaurant


class RestaurantSerializer(serializers.ModelSerializer):
    class Meta:
        model = Restaurant
        fields = ["id", "name", "slug", "phone", "email", "address", "timezone", "currency", "is_active", "created_at"]
        read_only_fields = ["id", "created_at"]


class UserSerializer(serializers.ModelSerializer):
    restaurant = RestaurantSerializer(read_only=True)

    class Meta:
        model = User
        fields = ["id", "phone", "email", "name", "role", "restaurant", "language", "is_active", "created_at"]
        read_only_fields = ["id", "created_at"]


class UserCreateSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, min_length=8)

    class Meta:
        model = User
        fields = ["phone", "email", "name", "password", "role", "language"]

    def create(self, validated_data):
        password = validated_data.pop("password")
        user = User(**validated_data)
        user.set_password(password)
        user.save()
        return user


class OwnerRegistrationSerializer(serializers.Serializer):
    """Register new restaurant owner with restaurant."""

    # User fields
    phone = serializers.CharField(max_length=20)
    name = serializers.CharField(max_length=150)
    email = serializers.EmailField(required=False, allow_blank=True)
    password = serializers.CharField(write_only=True, min_length=8)

    # Restaurant fields
    restaurant_name = serializers.CharField(max_length=200)
    restaurant_slug = serializers.SlugField()
    restaurant_phone = serializers.CharField(max_length=20, required=False)
    restaurant_address = serializers.CharField(required=False, allow_blank=True)

    def validate_phone(self, value):
        if User.objects.filter(phone=value).exists():
            raise serializers.ValidationError("A user with this phone number already exists.")
        return value

    def validate_restaurant_slug(self, value):
        if Restaurant.objects.filter(slug=value).exists():
            raise serializers.ValidationError("A restaurant with this slug already exists.")
        return value

    def create(self, validated_data):
        # Create restaurant
        restaurant = Restaurant.objects.create(
            name=validated_data["restaurant_name"],
            slug=validated_data["restaurant_slug"],
            phone=validated_data.get("restaurant_phone", validated_data["phone"]),
            address=validated_data.get("restaurant_address", ""),
        )

        # Create owner user
        user = User.objects.create_user(
            phone=validated_data["phone"],
            password=validated_data["password"],
            name=validated_data["name"],
            email=validated_data.get("email", ""),
            restaurant=restaurant,
            role="owner",
        )
        return user


class StaffInviteSerializer(serializers.Serializer):
    """Invite staff member to restaurant."""

    phone = serializers.CharField(max_length=20)
    name = serializers.CharField(max_length=150)
    email = serializers.EmailField(required=False, allow_blank=True)
    password = serializers.CharField(write_only=True, min_length=8)
    role = serializers.ChoiceField(choices=["manager", "cashier", "kitchen", "driver"])

    def validate_phone(self, value):
        if User.objects.filter(phone=value).exists():
            raise serializers.ValidationError("A user with this phone number already exists.")
        return value

    def create(self, validated_data):
        request = self.context.get("request")
        user = User.objects.create_user(
            phone=validated_data["phone"],
            password=validated_data["password"],
            name=validated_data["name"],
            email=validated_data.get("email", ""),
            restaurant=request.user.restaurant,
            role=validated_data["role"],
        )
        return user


class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    """Add custom claims to JWT token."""

    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)

        # Add custom claims
        token["name"] = user.name
        token["role"] = user.role
        if user.restaurant:
            token["restaurant_id"] = str(user.restaurant.id)
            token["restaurant_name"] = user.restaurant.name
        token["permissions"] = user.get_permissions_list()

        return token
```

Create `apps/api/apps/authentication/views.py`:
```python
from rest_framework import generics, status
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from rest_framework_simplejwt.tokens import RefreshToken

from apps.core.permissions import IsOwner, IsOwnerOrManager
from .models import User, Restaurant
from .serializers import (
    UserSerializer,
    RestaurantSerializer,
    OwnerRegistrationSerializer,
    StaffInviteSerializer,
    CustomTokenObtainPairSerializer,
)


class CustomTokenObtainPairView(TokenObtainPairView):
    """Login endpoint - returns JWT with custom claims."""
    serializer_class = CustomTokenObtainPairSerializer


class RegisterOwnerView(generics.CreateAPIView):
    """Register new restaurant owner with restaurant."""
    permission_classes = [AllowAny]
    serializer_class = OwnerRegistrationSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()

        # Generate tokens for immediate login
        refresh = RefreshToken.for_user(user)
        CustomTokenObtainPairSerializer.get_token(user)

        return Response(
            {
                "user": UserSerializer(user).data,
                "tokens": {
                    "refresh": str(refresh),
                    "access": str(refresh.access_token),
                },
            },
            status=status.HTTP_201_CREATED,
        )


class InviteStaffView(generics.CreateAPIView):
    """Invite staff member (owner/manager only)."""
    permission_classes = [IsAuthenticated, IsOwnerOrManager]
    serializer_class = StaffInviteSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data, context={"request": request})
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        return Response(UserSerializer(user).data, status=status.HTTP_201_CREATED)


class StaffListView(generics.ListAPIView):
    """List staff members in current restaurant."""
    permission_classes = [IsAuthenticated, IsOwnerOrManager]
    serializer_class = UserSerializer

    def get_queryset(self):
        return User.objects.filter(restaurant=self.request.user.restaurant)


class CurrentUserView(APIView):
    """Get current authenticated user."""
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response(UserSerializer(request.user).data)


class RestaurantSettingsView(generics.RetrieveUpdateAPIView):
    """Get/update current restaurant settings (owner only)."""
    permission_classes = [IsAuthenticated, IsOwner]
    serializer_class = RestaurantSerializer

    def get_object(self):
        return self.request.user.restaurant


class LogoutView(APIView):
    """Logout - blacklist refresh token."""
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            refresh_token = request.data.get("refresh")
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            return Response({"detail": "Successfully logged out."}, status=status.HTTP_200_OK)
        except Exception:
            return Response({"detail": "Invalid token."}, status=status.HTTP_400_BAD_REQUEST)
```

Create `apps/api/apps/authentication/urls.py`:
```python
from django.urls import path
from rest_framework_simplejwt.views import TokenRefreshView

from .views import (
    CustomTokenObtainPairView,
    RegisterOwnerView,
    InviteStaffView,
    StaffListView,
    CurrentUserView,
    RestaurantSettingsView,
    LogoutView,
)

app_name = "authentication"

urlpatterns = [
    # Auth endpoints
    path("token/", CustomTokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
    path("logout/", LogoutView.as_view(), name="logout"),

    # Registration
    path("register/", RegisterOwnerView.as_view(), name="register_owner"),

    # User management
    path("me/", CurrentUserView.as_view(), name="current_user"),
    path("staff/", StaffListView.as_view(), name="staff_list"),
    path("staff/invite/", InviteStaffView.as_view(), name="invite_staff"),

    # Restaurant settings
    path("restaurant/", RestaurantSettingsView.as_view(), name="restaurant_settings"),
]
```

Create `apps/api/apps/authentication/admin.py`:
```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User, Restaurant


@admin.register(Restaurant)
class RestaurantAdmin(admin.ModelAdmin):
    list_display = ["name", "slug", "phone", "timezone", "currency", "is_active", "created_at"]
    list_filter = ["is_active", "currency"]
    search_fields = ["name", "slug", "phone"]
    prepopulated_fields = {"slug": ("name",)}


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ["phone", "name", "role", "restaurant", "is_active", "is_staff"]
    list_filter = ["role", "is_active", "is_staff", "restaurant"]
    search_fields = ["phone", "name", "email"]
    ordering = ["name"]

    fieldsets = (
        (None, {"fields": ("phone", "password")}),
        ("Personal info", {"fields": ("name", "email", "language")}),
        ("Restaurant", {"fields": ("restaurant", "role")}),
        ("Permissions", {"fields": ("is_active", "is_staff", "is_superuser", "groups", "user_permissions")}),
        ("Important dates", {"fields": ("last_login",)}),
    )

    add_fieldsets = (
        (None, {
            "classes": ("wide",),
            "fields": ("phone", "name", "password1", "password2", "restaurant", "role"),
        }),
    )
```

Update `apps/api/config/settings/base.py`:
- Add "apps.authentication" to INSTALLED_APPS
- Add "rest_framework_simplejwt.token_blacklist" to INSTALLED_APPS
- Set AUTH_USER_MODEL = "authentication.User"
- Update SIMPLE_JWT to use custom serializer

Update `apps/api/config/urls.py`:
```python
from django.contrib import admin
from django.urls import path, include
from django.http import JsonResponse

def health_check(request):
    return JsonResponse({"status": "ok"})

urlpatterns = [
    path("admin/", admin.site.urls),
    path("health/", health_check, name="health"),
    path("api/v1/auth/", include("apps.authentication.urls")),
]
```

Run migrations:
```bash
cd apps/api && python manage.py makemigrations authentication && python manage.py migrate
```
  </action>
  <verify>
    cd apps/api && python manage.py check && python manage.py migrate --run-syncdb
  </verify>
  <done>
    Authentication app created with User/Restaurant models, JWT endpoints, and role-based permissions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive tests for authentication and multi-tenancy</name>
  <files>
    apps/api/apps/authentication/tests/__init__.py
    apps/api/apps/authentication/tests/factories.py
    apps/api/apps/authentication/tests/conftest.py
    apps/api/apps/authentication/tests/test_models.py
    apps/api/apps/authentication/tests/test_auth_api.py
  </files>
  <action>
Create `apps/api/apps/authentication/tests/factories.py`:
```python
import factory
from factory.django import DjangoModelFactory
from apps.authentication.models import User, Restaurant


class RestaurantFactory(DjangoModelFactory):
    class Meta:
        model = Restaurant

    name = factory.Sequence(lambda n: f"Restaurant {n}")
    slug = factory.LazyAttribute(lambda o: o.name.lower().replace(" ", "-"))
    phone = factory.Sequence(lambda n: f"+22507{n:08d}")
    timezone = "Africa/Abidjan"
    currency = "XOF"


class UserFactory(DjangoModelFactory):
    class Meta:
        model = User

    phone = factory.Sequence(lambda n: f"+22501{n:08d}")
    name = factory.Faker("name")
    role = "cashier"
    restaurant = factory.SubFactory(RestaurantFactory)

    @factory.post_generation
    def password(self, create, extracted, **kwargs):
        self.set_password(extracted or "testpass123")
        if create:
            self.save()


class OwnerFactory(UserFactory):
    role = "owner"


class ManagerFactory(UserFactory):
    role = "manager"


class CashierFactory(UserFactory):
    role = "cashier"


class KitchenFactory(UserFactory):
    role = "kitchen"


class DriverFactory(UserFactory):
    role = "driver"
```

Create `apps/api/apps/authentication/tests/conftest.py`:
```python
import pytest
from pytest_factoryboy import register
from rest_framework.test import APIClient
from rest_framework_simplejwt.tokens import RefreshToken

from .factories import (
    RestaurantFactory,
    UserFactory,
    OwnerFactory,
    ManagerFactory,
    CashierFactory,
)

# Register factories as pytest fixtures
register(RestaurantFactory)
register(UserFactory)
register(OwnerFactory)
register(ManagerFactory)
register(CashierFactory)


@pytest.fixture
def api_client():
    return APIClient()


@pytest.fixture
def auth_client(api_client, user):
    """Authenticated API client for regular user."""
    refresh = RefreshToken.for_user(user)
    api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")
    return api_client


@pytest.fixture
def owner_client(api_client, owner):
    """Authenticated API client for owner."""
    refresh = RefreshToken.for_user(owner)
    api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")
    return api_client


@pytest.fixture
def manager_client(api_client, manager):
    """Authenticated API client for manager."""
    refresh = RefreshToken.for_user(manager)
    api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")
    return api_client
```

Create `apps/api/apps/authentication/tests/test_models.py`:
```python
import pytest
from apps.authentication.models import User, Restaurant

pytestmark = pytest.mark.django_db


class TestRestaurantModel:
    def test_create_restaurant(self, restaurant_factory):
        restaurant = restaurant_factory(name="Chez Mama", slug="chez-mama")
        assert restaurant.name == "Chez Mama"
        assert restaurant.slug == "chez-mama"
        assert restaurant.currency == "XOF"
        assert restaurant.timezone == "Africa/Abidjan"

    def test_restaurant_str(self, restaurant_factory):
        restaurant = restaurant_factory(name="Test Restaurant")
        assert str(restaurant) == "Test Restaurant"


class TestUserModel:
    def test_create_user(self, user_factory, restaurant_factory):
        restaurant = restaurant_factory()
        user = user_factory(
            phone="+2250701234567",
            name="Jean Dupont",
            restaurant=restaurant,
            role="cashier",
        )
        assert user.phone == "+2250701234567"
        assert user.name == "Jean Dupont"
        assert user.role == "cashier"
        assert user.restaurant == restaurant

    def test_create_superuser(self):
        user = User.objects.create_superuser(
            phone="+2250700000000",
            password="adminpass123",
            name="Admin User",
        )
        assert user.is_staff is True
        assert user.is_superuser is True
        assert user.role == "owner"

    def test_user_str(self, user_factory):
        user = user_factory(name="Jean Dupont", phone="+2250701234567")
        assert str(user) == "Jean Dupont (+2250701234567)"

    def test_owner_permissions(self, owner_factory):
        owner = owner_factory()
        permissions = owner.get_permissions_list()
        assert "manage_restaurant" in permissions
        assert "manage_staff" in permissions
        assert "manage_menu" in permissions
        assert "view_reports" in permissions

    def test_cashier_permissions(self, cashier_factory):
        cashier = cashier_factory()
        permissions = cashier.get_permissions_list()
        assert "create_orders" in permissions
        assert "manage_orders" in permissions
        assert "manage_restaurant" not in permissions

    def test_password_hashing(self, user_factory):
        user = user_factory(password="mypassword123")
        assert user.check_password("mypassword123")
        assert not user.check_password("wrongpassword")
```

Create `apps/api/apps/authentication/tests/test_auth_api.py`:
```python
import pytest
from django.urls import reverse
from rest_framework import status

pytestmark = pytest.mark.django_db


class TestOwnerRegistration:
    def test_register_owner_success(self, api_client):
        url = reverse("authentication:register_owner")
        data = {
            "phone": "+2250712345678",
            "name": "Jean Owner",
            "email": "jean@example.com",
            "password": "securepass123",
            "restaurant_name": "Chez Jean",
            "restaurant_slug": "chez-jean",
            "restaurant_phone": "+2250712345678",
            "restaurant_address": "123 Rue d'Abidjan",
        }
        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED
        assert "user" in response.data
        assert "tokens" in response.data
        assert response.data["user"]["role"] == "owner"
        assert response.data["user"]["restaurant"]["name"] == "Chez Jean"

    def test_register_duplicate_phone_fails(self, api_client, user_factory):
        user_factory(phone="+2250712345678")
        url = reverse("authentication:register_owner")
        data = {
            "phone": "+2250712345678",  # Duplicate
            "name": "Another Owner",
            "password": "securepass123",
            "restaurant_name": "Another Restaurant",
            "restaurant_slug": "another-restaurant",
        }
        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert "phone" in response.data


class TestLogin:
    def test_login_success(self, api_client, user_factory):
        user = user_factory(phone="+2250712345678", password="testpass123")
        url = reverse("authentication:token_obtain_pair")
        data = {"phone": "+2250712345678", "password": "testpass123"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_200_OK
        assert "access" in response.data
        assert "refresh" in response.data

    def test_login_invalid_password(self, api_client, user_factory):
        user_factory(phone="+2250712345678", password="testpass123")
        url = reverse("authentication:token_obtain_pair")
        data = {"phone": "+2250712345678", "password": "wrongpassword"}

        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_jwt_contains_custom_claims(self, api_client, owner_factory):
        import jwt
        from django.conf import settings

        owner = owner_factory(phone="+2250712345678", password="testpass123")
        url = reverse("authentication:token_obtain_pair")
        data = {"phone": "+2250712345678", "password": "testpass123"}

        response = api_client.post(url, data, format="json")

        # Decode token (without verification for testing)
        token = response.data["access"]
        decoded = jwt.decode(token, options={"verify_signature": False})

        assert decoded["role"] == "owner"
        assert decoded["name"] == owner.name
        assert "restaurant_id" in decoded
        assert "permissions" in decoded


class TestTokenRefresh:
    def test_refresh_token_success(self, api_client, user_factory):
        user = user_factory(phone="+2250712345678", password="testpass123")

        # Get initial tokens
        login_url = reverse("authentication:token_obtain_pair")
        login_response = api_client.post(
            login_url,
            {"phone": "+2250712345678", "password": "testpass123"},
            format="json"
        )
        refresh_token = login_response.data["refresh"]

        # Refresh the token
        refresh_url = reverse("authentication:token_refresh")
        response = api_client.post(refresh_url, {"refresh": refresh_token}, format="json")

        assert response.status_code == status.HTTP_200_OK
        assert "access" in response.data


class TestLogout:
    def test_logout_blacklists_token(self, auth_client, user):
        from rest_framework_simplejwt.tokens import RefreshToken

        refresh = RefreshToken.for_user(user)
        url = reverse("authentication:logout")

        response = auth_client.post(url, {"refresh": str(refresh)}, format="json")

        assert response.status_code == status.HTTP_200_OK

        # Try to use the blacklisted refresh token
        refresh_url = reverse("authentication:token_refresh")
        response = auth_client.post(refresh_url, {"refresh": str(refresh)}, format="json")

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


class TestCurrentUser:
    def test_get_current_user(self, auth_client, user):
        url = reverse("authentication:current_user")
        response = auth_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.data["phone"] == user.phone
        assert response.data["name"] == user.name

    def test_unauthenticated_returns_401(self, api_client):
        url = reverse("authentication:current_user")
        response = api_client.get(url)

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


class TestStaffInvite:
    def test_owner_can_invite_staff(self, owner_client, owner):
        url = reverse("authentication:invite_staff")
        data = {
            "phone": "+2250799999999",
            "name": "New Cashier",
            "password": "staffpass123",
            "role": "cashier",
        }
        response = owner_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data["role"] == "cashier"
        assert response.data["restaurant"]["id"] == str(owner.restaurant.id)

    def test_manager_can_invite_staff(self, manager_client, manager):
        url = reverse("authentication:invite_staff")
        data = {
            "phone": "+2250799999998",
            "name": "New Kitchen Staff",
            "password": "staffpass123",
            "role": "kitchen",
        }
        response = manager_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_201_CREATED

    def test_cashier_cannot_invite_staff(self, api_client, cashier_factory):
        from rest_framework_simplejwt.tokens import RefreshToken

        cashier = cashier_factory()
        refresh = RefreshToken.for_user(cashier)
        api_client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")

        url = reverse("authentication:invite_staff")
        data = {
            "phone": "+2250799999997",
            "name": "Unauthorized Invite",
            "password": "staffpass123",
            "role": "driver",
        }
        response = api_client.post(url, data, format="json")

        assert response.status_code == status.HTTP_403_FORBIDDEN


class TestRestaurantSettings:
    def test_owner_can_update_restaurant(self, owner_client, owner):
        url = reverse("authentication:restaurant_settings")
        data = {"name": "Updated Restaurant Name", "address": "New Address"}

        response = owner_client.patch(url, data, format="json")

        assert response.status_code == status.HTTP_200_OK
        assert response.data["name"] == "Updated Restaurant Name"

    def test_manager_cannot_update_restaurant(self, manager_client):
        url = reverse("authentication:restaurant_settings")
        data = {"name": "Should Fail"}

        response = manager_client.patch(url, data, format="json")

        assert response.status_code == status.HTTP_403_FORBIDDEN


class TestMultiTenantIsolation:
    def test_staff_list_only_shows_same_restaurant(self, owner_client, owner, user_factory, restaurant_factory):
        # Create staff for owner's restaurant
        staff1 = user_factory(restaurant=owner.restaurant, name="Staff 1")
        staff2 = user_factory(restaurant=owner.restaurant, name="Staff 2")

        # Create staff for different restaurant
        other_restaurant = restaurant_factory()
        other_staff = user_factory(restaurant=other_restaurant, name="Other Staff")

        url = reverse("authentication:staff_list")
        response = owner_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        phones = [u["phone"] for u in response.data]

        assert staff1.phone in phones
        assert staff2.phone in phones
        assert owner.phone in phones  # Owner is also staff
        assert other_staff.phone not in phones
```

Run all tests:
```bash
cd apps/api && pytest apps/authentication/tests/ -v
```
  </action>
  <verify>
    cd apps/api && pytest apps/authentication/tests/ -v --tb=short
  </verify>
  <done>
    All authentication tests pass, covering registration, login, logout, token refresh, staff management, and tenant isolation
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd apps/api && python manage.py check` - No issues
2. `cd apps/api && python manage.py migrate` - Migrations applied
3. `cd apps/api && pytest apps/authentication/tests/ -v` - All tests pass (15+ tests)
4. `ruff check apps/api/` - No lint errors
5. Manual API test flow:
   - POST /api/v1/auth/register/ - Create owner + restaurant
   - POST /api/v1/auth/token/ - Login, get JWT
   - GET /api/v1/auth/me/ - Get current user (with auth header)
   - POST /api/v1/auth/staff/invite/ - Invite staff (as owner)
   - GET /api/v1/auth/staff/ - List staff (only same restaurant)
</verification>

<success_criteria>
- Custom User model with phone as username
- Restaurant model with settings (name, address, timezone, XOF currency)
- JWT authentication with custom claims (role, restaurant_id, permissions)
- Token refresh and logout with blacklist
- Owner registration creates both user and restaurant
- Staff invite restricted to owner/manager roles
- TenantMiddleware sets restaurant context from authenticated user
- TenantManager auto-filters queries by current restaurant
- Role-based permission classes (IsOwner, IsOwnerOrManager, IsCashier)
- Comprehensive test coverage (models, API, permissions, multi-tenancy)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
