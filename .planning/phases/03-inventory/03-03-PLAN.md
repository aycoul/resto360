---
phase: 03-inventory
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - apps/api/apps/inventory/services.py
  - apps/api/apps/inventory/views.py
  - apps/api/apps/inventory/serializers.py
  - apps/api/apps/inventory/urls.py
  - apps/api/apps/inventory/tasks.py
  - apps/api/apps/inventory/tests/test_api.py
  - apps/api/apps/inventory/tests/test_reports.py
autonomous: true

must_haves:
  truths:
    - "Manager sees low stock alert when item falls below threshold"
    - "Manager can view current stock levels for all items"
    - "Manager can filter stock by low-stock status"
    - "Manager can view movement history with date range filtering"
    - "Reports show running balance over time"
  artifacts:
    - path: "apps/api/apps/inventory/views.py"
      provides: "Report endpoints"
      contains: ["low_stock", "current_stock_report", "movement_report"]
    - path: "apps/api/apps/inventory/services.py"
      provides: "Report generation logic"
      contains: ["get_current_stock_report", "get_movement_report"]
    - path: "apps/api/apps/inventory/tasks.py"
      provides: "Async low-stock notification"
      contains: ["send_low_stock_alert"]
  key_links:
    - from: "apps/api/apps/inventory/services.py"
      to: "apps/api/apps/inventory/tasks.py"
      via: "check_low_stock_alert calls Celery task"
      pattern: "send_low_stock_alert\\.delay"
    - from: "apps/api/apps/inventory/views.py"
      to: "apps/api/apps/inventory/services.py"
      via: "report endpoints call report services"
      pattern: "get_current_stock_report|get_movement_report"
---

<objective>
Implement low stock alerts and inventory reporting endpoints.

Purpose: Give managers visibility into stock levels and movement history. Low stock alerts prevent stockouts by notifying managers before running out of key ingredients.

Output: Alert system with Celery task, report endpoints for current stock and movement history.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-inventory/03-RESEARCH.md
@.planning/phases/03-inventory/03-01-SUMMARY.md
@.planning/phases/03-inventory/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement low stock alert system</name>
  <files>
    apps/api/apps/inventory/tasks.py
    apps/api/apps/inventory/services.py
  </files>
  <action>
1. Create tasks.py for Celery async notifications:

```python
"""Celery tasks for inventory notifications."""
from celery import shared_task
import logging

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def send_low_stock_alert(self, stock_item_id: str, current_quantity: float, threshold: float):
    """
    Send low stock alert notification.

    This is a placeholder that logs the alert. In production, this would:
    - Send email to restaurant managers
    - Push notification via WebSocket
    - Send SMS if critical

    Args:
        stock_item_id: UUID of the stock item
        current_quantity: Current stock level
        threshold: Configured threshold
    """
    from apps.inventory.models import StockItem

    try:
        stock_item = StockItem.all_objects.select_related('restaurant').get(id=stock_item_id)

        alert_message = (
            f"LOW STOCK ALERT: {stock_item.name} at {stock_item.restaurant.name}\n"
            f"Current: {current_quantity} {stock_item.unit}\n"
            f"Threshold: {threshold} {stock_item.unit}"
        )

        # Log the alert (replace with actual notification in production)
        logger.warning(alert_message)

        # Future: Send to managers via email/push
        # Future: Broadcast via WebSocket to dashboard

        return {'status': 'sent', 'stock_item': str(stock_item_id)}

    except StockItem.DoesNotExist:
        logger.error(f"Stock item {stock_item_id} not found for alert")
        return {'status': 'error', 'reason': 'stock_item_not_found'}
    except Exception as e:
        logger.error(f"Failed to send low stock alert: {e}")
        self.retry(exc=e)
```

2. Update check_low_stock_alert in services.py to use Celery:

```python
def check_low_stock_alert(stock_item):
    """
    Check if stock is below threshold and trigger async alert.

    Only triggers alert once per threshold crossing (uses alert_sent flag).
    Flag is cleared when stock is restocked above threshold.
    """
    if stock_item.low_stock_threshold is None:
        return  # No threshold configured

    if stock_item.current_quantity <= stock_item.low_stock_threshold:
        if not stock_item.low_stock_alert_sent:
            # Mark alert as sent to prevent spam
            StockItem.objects.filter(id=stock_item.id).update(low_stock_alert_sent=True)

            # Trigger async notification
            from apps.inventory.tasks import send_low_stock_alert
            send_low_stock_alert.delay(
                stock_item_id=str(stock_item.id),
                current_quantity=float(stock_item.current_quantity),
                threshold=float(stock_item.low_stock_threshold),
            )
    else:
        # Stock above threshold - clear alert flag if set
        if stock_item.low_stock_alert_sent:
            StockItem.objects.filter(id=stock_item.id).update(low_stock_alert_sent=False)
```

Note: Celery is already configured in the project (used for other tasks). The task will run asynchronously when Redis/Celery worker is available, or execute synchronously in tests with CELERY_TASK_ALWAYS_EAGER=True.
  </action>
  <verify>
cd apps/api && python -c "from apps.inventory.tasks import send_low_stock_alert; print('Celery task imported')"
cd apps/api && python -c "from apps.inventory.services import check_low_stock_alert; print('Alert service ready')"
  </verify>
  <done>
Low stock alert Celery task created. check_low_stock_alert triggers async notification on threshold crossing and prevents duplicate alerts via alert_sent flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create inventory report services</name>
  <files>
    apps/api/apps/inventory/services.py
  </files>
  <action>
Add report generation functions to services.py:

```python
from django.db.models import Sum, Count, Case, When, BooleanField, F, Value
from django.db.models.functions import TruncDate, Coalesce
from datetime import date, timedelta


def get_current_stock_report(restaurant, include_inactive=False, low_stock_only=False):
    """
    Get current stock levels for all items.

    Args:
        restaurant: Restaurant instance
        include_inactive: Include inactive stock items
        low_stock_only: Only return items at or below threshold

    Returns:
        QuerySet of StockItems annotated with is_low_stock boolean
    """
    from apps.inventory.models import StockItem

    queryset = StockItem.objects.filter(restaurant=restaurant)

    if not include_inactive:
        queryset = queryset.filter(is_active=True)

    # Annotate with low stock status
    queryset = queryset.annotate(
        is_low_stock=Case(
            When(
                low_stock_threshold__isnull=False,
                current_quantity__lte=F('low_stock_threshold'),
                then=Value(True)
            ),
            default=Value(False),
            output_field=BooleanField(),
        )
    )

    if low_stock_only:
        queryset = queryset.filter(is_low_stock=True)

    return queryset.order_by('name')


def get_movement_report(restaurant, start_date: date, end_date: date, stock_item_id=None):
    """
    Generate stock movement report for date range.

    Args:
        restaurant: Restaurant instance
        start_date: Report start date (inclusive)
        end_date: Report end date (inclusive)
        stock_item_id: Optional - filter to specific stock item

    Returns:
        Dict with summary and daily breakdown
    """
    from apps.inventory.models import StockMovement

    queryset = StockMovement.objects.filter(
        restaurant=restaurant,
        created_at__date__gte=start_date,
        created_at__date__lte=end_date,
    )

    if stock_item_id:
        queryset = queryset.filter(stock_item_id=stock_item_id)

    # Summary by movement type
    summary = queryset.values('movement_type').annotate(
        total_quantity=Coalesce(Sum('quantity_change'), Value(0)),
        movement_count=Count('id'),
    )

    # Daily breakdown
    daily = queryset.annotate(
        day=TruncDate('created_at')
    ).values('day', 'movement_type').annotate(
        total_quantity=Sum('quantity_change'),
        movement_count=Count('id'),
    ).order_by('day', 'movement_type')

    # By stock item
    by_item = queryset.values(
        'stock_item__id',
        'stock_item__name',
        'stock_item__unit',
    ).annotate(
        total_in=Coalesce(
            Sum('quantity_change', filter=models.Q(movement_type='in')),
            Value(0)
        ),
        total_out=Coalesce(
            Sum('quantity_change', filter=models.Q(movement_type='out')),
            Value(0)
        ),
        net_change=Sum('quantity_change'),
        movement_count=Count('id'),
    ).order_by('stock_item__name')

    return {
        'period': {
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat(),
        },
        'summary': list(summary),
        'daily': list(daily),
        'by_item': list(by_item),
    }


def get_stock_item_movement_history(stock_item, limit=100, offset=0):
    """
    Get movement history for a specific stock item.

    Args:
        stock_item: StockItem instance
        limit: Max records to return
        offset: Starting offset

    Returns:
        List of movements with running balance
    """
    from apps.inventory.models import StockMovement

    movements = StockMovement.objects.filter(
        stock_item=stock_item
    ).select_related('created_by').order_by('-created_at')[offset:offset + limit]

    return movements
```
  </action>
  <verify>
cd apps/api && python -c "
from apps.inventory.services import get_current_stock_report, get_movement_report
print('Report services imported successfully')
"
  </verify>
  <done>
Report services created: get_current_stock_report (with low_stock filter), get_movement_report (summary, daily, by_item breakdown), get_stock_item_movement_history.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create report API endpoints and tests</name>
  <files>
    apps/api/apps/inventory/serializers.py
    apps/api/apps/inventory/views.py
    apps/api/apps/inventory/urls.py
    apps/api/apps/inventory/tests/test_api.py
    apps/api/apps/inventory/tests/test_reports.py
  </files>
  <action>
1. Add report serializers to serializers.py:

```python
class CurrentStockReportSerializer(serializers.ModelSerializer):
    """Stock item with low stock status for reports."""

    is_low_stock = serializers.BooleanField(read_only=True)

    class Meta:
        model = StockItem
        fields = [
            'id', 'name', 'sku', 'unit',
            'current_quantity', 'low_stock_threshold',
            'is_low_stock', 'is_active',
        ]


class MovementReportRequestSerializer(serializers.Serializer):
    """Request parameters for movement report."""

    start_date = serializers.DateField()
    end_date = serializers.DateField()
    stock_item = serializers.UUIDField(required=False)

    def validate(self, data):
        if data['start_date'] > data['end_date']:
            raise serializers.ValidationError("start_date must be before end_date")
        # Limit to 90 days max
        if (data['end_date'] - data['start_date']).days > 90:
            raise serializers.ValidationError("Date range cannot exceed 90 days")
        return data


class MovementReportSerializer(serializers.Serializer):
    """Movement report response."""

    period = serializers.DictField()
    summary = serializers.ListField()
    daily = serializers.ListField()
    by_item = serializers.ListField()
```

2. Add report endpoints to views.py:

```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from datetime import date, timedelta


class ReportViewSet(viewsets.ViewSet):
    """
    ViewSet for inventory reports.

    GET /api/inventory/reports/current-stock/ - Current stock levels
    GET /api/inventory/reports/low-stock/ - Items below threshold
    GET /api/inventory/reports/movements/?start_date=&end_date= - Movement history
    """

    permission_classes = [IsAuthenticated, IsManagerOrOwner]

    @action(detail=False, methods=['get'], url_path='current-stock')
    def current_stock(self, request):
        """Get current stock levels for all items."""
        from apps.core.context import get_current_restaurant
        from apps.inventory.services import get_current_stock_report

        restaurant = get_current_restaurant()
        include_inactive = request.query_params.get('include_inactive', 'false').lower() == 'true'

        items = get_current_stock_report(restaurant, include_inactive=include_inactive)

        serializer = CurrentStockReportSerializer(items, many=True)
        return Response({
            'count': items.count(),
            'items': serializer.data,
        })

    @action(detail=False, methods=['get'], url_path='low-stock')
    def low_stock(self, request):
        """Get items at or below low stock threshold."""
        from apps.core.context import get_current_restaurant
        from apps.inventory.services import get_current_stock_report

        restaurant = get_current_restaurant()
        items = get_current_stock_report(restaurant, low_stock_only=True)

        serializer = CurrentStockReportSerializer(items, many=True)
        return Response({
            'count': items.count(),
            'items': serializer.data,
        })

    @action(detail=False, methods=['get'], url_path='movements')
    def movements(self, request):
        """
        Get movement report for date range.

        Query params:
        - start_date: YYYY-MM-DD (required)
        - end_date: YYYY-MM-DD (required)
        - stock_item: UUID (optional, filter to specific item)
        """
        from apps.core.context import get_current_restaurant
        from apps.inventory.services import get_movement_report

        # Validate request params
        request_serializer = MovementReportRequestSerializer(data=request.query_params)
        request_serializer.is_valid(raise_exception=True)

        restaurant = get_current_restaurant()
        report = get_movement_report(
            restaurant=restaurant,
            start_date=request_serializer.validated_data['start_date'],
            end_date=request_serializer.validated_data['end_date'],
            stock_item_id=request_serializer.validated_data.get('stock_item'),
        )

        return Response(report)
```

3. Update urls.py to add report routes:

```python
from rest_framework.routers import DefaultRouter
from .views import StockItemViewSet, StockMovementViewSet, MenuItemIngredientViewSet, ReportViewSet

router = DefaultRouter()
router.register('stock-items', StockItemViewSet, basename='stock-item')
router.register('movements', StockMovementViewSet, basename='stock-movement')
router.register('recipes', MenuItemIngredientViewSet, basename='recipe')
router.register('reports', ReportViewSet, basename='report')

urlpatterns = router.urls
```

4. Create tests/test_reports.py:

```python
"""Tests for inventory reports."""
import pytest
from datetime import date, timedelta
from decimal import Decimal
from django.urls import reverse
from rest_framework import status


class TestCurrentStockReport:
    """Test current stock report endpoint."""

    def test_returns_all_active_stock_items(self, api_client, stock_items):
        """Report includes all active stock items."""
        url = reverse('report-current-stock')
        response = api_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        assert response.data['count'] > 0

    def test_annotates_low_stock_status(self, api_client, low_stock_item):
        """Items below threshold have is_low_stock=True."""
        url = reverse('report-current-stock')
        response = api_client.get(url)

        low_item = next(
            i for i in response.data['items']
            if i['id'] == str(low_stock_item.id)
        )
        assert low_item['is_low_stock'] is True

    def test_excludes_inactive_by_default(self, api_client, inactive_stock_item):
        """Inactive items excluded by default."""
        url = reverse('report-current-stock')
        response = api_client.get(url)

        item_ids = [i['id'] for i in response.data['items']]
        assert str(inactive_stock_item.id) not in item_ids

    def test_include_inactive_param(self, api_client, inactive_stock_item):
        """include_inactive=true includes inactive items."""
        url = reverse('report-current-stock')
        response = api_client.get(url, {'include_inactive': 'true'})

        item_ids = [i['id'] for i in response.data['items']]
        assert str(inactive_stock_item.id) in item_ids


class TestLowStockReport:
    """Test low stock report endpoint."""

    def test_returns_only_low_stock_items(self, api_client, low_stock_item, normal_stock_item):
        """Report only includes items at or below threshold."""
        url = reverse('report-low-stock')
        response = api_client.get(url)

        assert response.status_code == status.HTTP_200_OK
        item_ids = [i['id'] for i in response.data['items']]

        assert str(low_stock_item.id) in item_ids
        assert str(normal_stock_item.id) not in item_ids


class TestMovementReport:
    """Test movement report endpoint."""

    def test_returns_summary_for_date_range(self, api_client, stock_movements):
        """Report returns summary, daily, and by_item data."""
        today = date.today()
        url = reverse('report-movements')
        response = api_client.get(url, {
            'start_date': (today - timedelta(days=7)).isoformat(),
            'end_date': today.isoformat(),
        })

        assert response.status_code == status.HTTP_200_OK
        assert 'period' in response.data
        assert 'summary' in response.data
        assert 'daily' in response.data
        assert 'by_item' in response.data

    def test_validates_date_range(self, api_client):
        """Start date must be before end date."""
        today = date.today()
        url = reverse('report-movements')
        response = api_client.get(url, {
            'start_date': today.isoformat(),
            'end_date': (today - timedelta(days=7)).isoformat(),
        })

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    def test_limits_date_range_to_90_days(self, api_client):
        """Date range cannot exceed 90 days."""
        today = date.today()
        url = reverse('report-movements')
        response = api_client.get(url, {
            'start_date': (today - timedelta(days=100)).isoformat(),
            'end_date': today.isoformat(),
        })

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    def test_filters_by_stock_item(self, api_client, stock_item_with_movements):
        """Can filter movements to specific stock item."""
        today = date.today()
        url = reverse('report-movements')
        response = api_client.get(url, {
            'start_date': (today - timedelta(days=7)).isoformat(),
            'end_date': today.isoformat(),
            'stock_item': str(stock_item_with_movements.id),
        })

        assert response.status_code == status.HTTP_200_OK
        # All by_item entries should be for the specified item
        for item in response.data['by_item']:
            assert item['stock_item__id'] == str(stock_item_with_movements.id)
```

5. Add additional test fixtures to conftest.py as needed for report tests.
  </action>
  <verify>
cd apps/api && python manage.py check
cd apps/api && pytest apps/inventory/tests/ -v --tb=short
  </verify>
  <done>
Report endpoints created: /api/inventory/reports/current-stock/, /api/inventory/reports/low-stock/, /api/inventory/reports/movements/. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. Low stock alerts work:
   - Create stock item with threshold=10
   - Deduct stock to bring below threshold
   - Verify Celery task triggered (check logs)
   - Verify alert_sent flag set to True
   - Add stock above threshold
   - Verify alert_sent flag cleared

2. Current stock report:
   - GET /api/inventory/reports/current-stock/ returns all active items
   - is_low_stock correctly calculated
   - include_inactive param works

3. Low stock report:
   - GET /api/inventory/reports/low-stock/ returns only items at/below threshold

4. Movement report:
   - GET /api/inventory/reports/movements/?start_date=&end_date= returns report
   - Validates date range
   - Filters by stock_item when provided
   - Returns summary, daily, and by_item breakdown

5. All tests pass:
   - pytest apps/inventory/tests/ -v
</verification>

<success_criteria>
- Celery task send_low_stock_alert created and triggered by check_low_stock_alert
- alert_sent flag prevents notification spam
- GET /api/inventory/reports/current-stock/ returns annotated stock items
- GET /api/inventory/reports/low-stock/ filters to threshold-crossing items
- GET /api/inventory/reports/movements/ returns period summary with breakdown
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-inventory/03-03-SUMMARY.md`
</output>
