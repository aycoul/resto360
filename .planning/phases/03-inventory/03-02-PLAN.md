---
phase: 03-inventory
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/api/apps/inventory/models.py
  - apps/api/apps/inventory/serializers.py
  - apps/api/apps/inventory/views.py
  - apps/api/apps/inventory/urls.py
  - apps/api/apps/inventory/services.py
  - apps/api/apps/inventory/signals.py
  - apps/api/apps/inventory/apps.py
  - apps/api/apps/inventory/admin.py
  - apps/api/apps/inventory/migrations/0002_menuitemingredient.py
  - apps/api/apps/inventory/tests/factories.py
  - apps/api/apps/inventory/tests/test_services.py
  - apps/api/apps/inventory/tests/test_signals.py
autonomous: true

must_haves:
  truths:
    - "Manager can map ingredients to menu items (recipes)"
    - "Each recipe specifies quantity of ingredient per 1 menu item"
    - "Completing an order automatically deducts all ingredients"
    - "Stock deduction happens ONLY on order completion (not creation)"
    - "Insufficient stock logs warning but does not block order completion"
  artifacts:
    - path: "apps/api/apps/inventory/models.py"
      provides: "MenuItemIngredient model for recipe mapping"
      contains: ["class MenuItemIngredient", "quantity_required"]
    - path: "apps/api/apps/inventory/signals.py"
      provides: "Order completion signal handler"
      contains: ["post_save", "handle_order_completion", "deduct_ingredients_for_order"]
    - path: "apps/api/apps/inventory/services.py"
      provides: "Recipe-based deduction logic"
      contains: ["deduct_ingredients_for_order"]
  key_links:
    - from: "apps/api/apps/inventory/signals.py"
      to: "apps/api/apps/orders/models.py"
      via: "post_save signal on Order model"
      pattern: "@receiver\\(post_save.*Order\\)"
    - from: "apps/api/apps/inventory/signals.py"
      to: "apps/api/apps/inventory/services.py"
      via: "calls deduct_ingredients_for_order"
      pattern: "deduct_ingredients_for_order"
    - from: "apps/api/apps/inventory/apps.py"
      to: "apps/api/apps/inventory/signals.py"
      via: "signal registration in ready()"
      pattern: "import.*signals"
---

<objective>
Create recipe mapping (MenuItemIngredient) and wire automatic stock deduction on order completion.

Purpose: Enable automatic ingredient tracking when orders are completed. This closes the loop between sales and inventory, giving managers real-time visibility into ingredient consumption.

Output: MenuItemIngredient model for recipes, signal handler that deducts stock when orders complete.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-inventory/03-RESEARCH.md
@.planning/phases/03-inventory/03-01-SUMMARY.md

# Integration points
@apps/api/apps/orders/models.py
@apps/api/apps/orders/signals.py
@apps/api/apps/menu/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MenuItemIngredient model</name>
  <files>
    apps/api/apps/inventory/models.py
    apps/api/apps/inventory/admin.py
    apps/api/apps/inventory/migrations/0002_menuitemingredient.py
  </files>
  <action>
1. Add MenuItemIngredient model to models.py:

```python
class MenuItemIngredient(TenantModel):
    """Maps a menu item to its required ingredients (recipe/BOM)."""

    menu_item = models.ForeignKey(
        'menu.MenuItem',
        on_delete=models.CASCADE,
        related_name='ingredients',  # menuitem.ingredients.all()
    )
    stock_item = models.ForeignKey(
        'inventory.StockItem',
        on_delete=models.CASCADE,
        related_name='menu_usages',  # stockitem.menu_usages.all()
    )
    quantity_required = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        help_text="Quantity of this ingredient required per 1 unit of menu item"
    )

    # Standard managers
    all_objects = models.Manager()
    objects = TenantManager()

    class Meta:
        unique_together = ['menu_item', 'stock_item']
        ordering = ['stock_item__name']

    def __str__(self):
        return f"{self.menu_item.name}: {self.quantity_required} {self.stock_item.unit} of {self.stock_item.name}"
```

2. Update admin.py to add MenuItemIngredientAdmin:
   - list_display: menu_item, stock_item, quantity_required
   - list_filter: restaurant, stock_item
   - autocomplete_fields: menu_item, stock_item (requires search_fields in related admins)
   - Add search_fields to StockItemAdmin if not present

3. Run migrations:
   ```bash
   cd apps/api && python manage.py makemigrations inventory --name menuitemingredient
   cd apps/api && python manage.py migrate
   ```
  </action>
  <verify>
cd apps/api && python manage.py showmigrations inventory
cd apps/api && python -c "from apps.inventory.models import MenuItemIngredient; print('MenuItemIngredient imported')"
  </verify>
  <done>
MenuItemIngredient model created with FKs to MenuItem and StockItem. Migration applied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create order completion signal and deduction service</name>
  <files>
    apps/api/apps/inventory/services.py
    apps/api/apps/inventory/signals.py
    apps/api/apps/inventory/apps.py
  </files>
  <action>
1. Add deduct_ingredients_for_order to services.py:

```python
def deduct_ingredients_for_order(order):
    """
    Deduct all ingredients for a completed order.
    Processes each order item's recipe ingredients.

    Does NOT raise exceptions - logs warnings for insufficient stock
    but allows order completion to proceed.
    """
    from apps.inventory.models import MenuItemIngredient
    import logging

    logger = logging.getLogger(__name__)

    with transaction.atomic():
        for order_item in order.items.select_related('menu_item'):
            if not order_item.menu_item:
                continue  # Menu item was deleted

            # Get recipe ingredients for this menu item
            ingredients = MenuItemIngredient.objects.filter(
                menu_item=order_item.menu_item,
                restaurant=order.restaurant,
            ).select_related('stock_item')

            if not ingredients.exists():
                logger.debug(
                    f"No ingredients mapped for menu item {order_item.menu_item.name} "
                    f"in order {order.id}"
                )
                continue

            for ingredient in ingredients:
                # Calculate quantity needed: required_per_unit * quantity_ordered
                quantity_needed = ingredient.quantity_required * order_item.quantity

                try:
                    deduct_stock(
                        stock_item_id=ingredient.stock_item_id,
                        quantity=quantity_needed,
                        reason='order_usage',
                        user=order.cashier,
                        notes=f"Order #{order.order_number}",
                        reference=order,
                    )
                except InsufficientStockError as e:
                    # Log but continue - don't block order completion
                    logger.warning(
                        f"Insufficient stock for order {order.id}: "
                        f"{ingredient.stock_item.name} needed {quantity_needed}, "
                        f"available {ingredient.stock_item.current_quantity}"
                    )
                    # Create movement anyway to track discrepancy
                    _create_negative_balance_movement(
                        ingredient.stock_item,
                        quantity_needed,
                        order,
                        order.cashier,
                    )


def _create_negative_balance_movement(stock_item, quantity, order, user):
    """Create movement even when stock goes negative (for tracking discrepancies)."""
    from apps.inventory.models import StockMovement

    with transaction.atomic():
        # Force deduction even if insufficient
        StockItem.objects.filter(id=stock_item.id).update(
            current_quantity=F('current_quantity') - quantity
        )
        stock_item.refresh_from_db()

        StockMovement.objects.create(
            restaurant=stock_item.restaurant,
            stock_item=stock_item,
            quantity_change=-quantity,
            movement_type='out',
            reason='order_usage',
            notes=f"Order #{order.order_number} (INSUFFICIENT STOCK)",
            reference_type='Order',
            reference_id=order.id,
            created_by=user,
            balance_after=stock_item.current_quantity,
        )
```

2. Create signals.py:

```python
"""Signal handlers for inventory integration with orders."""
from django.db.models.signals import post_save
from django.dispatch import receiver
import logging

logger = logging.getLogger(__name__)


@receiver(post_save, sender='orders.Order')
def handle_order_completion(sender, instance, created, **kwargs):
    """
    Deduct ingredients from stock when order is completed.

    Only triggers when:
    1. Order status is 'completed'
    2. completed_at was just set (not a re-save of already completed order)
    """
    from apps.orders.models import OrderStatus

    # Skip if not completed
    if instance.status != OrderStatus.COMPLETED:
        return

    # Skip if completed_at is not set (shouldn't happen, but guard)
    if not instance.completed_at:
        return

    # Check if this is the transition TO completed
    # Use update_fields if available to detect what changed
    update_fields = kwargs.get('update_fields')
    if update_fields is not None:
        # If update_fields specified but doesn't include status/completed_at, skip
        if 'status' not in update_fields and 'completed_at' not in update_fields:
            return

    # Avoid duplicate processing: check if movements already exist for this order
    from apps.inventory.models import StockMovement
    if StockMovement.objects.filter(
        reference_type='Order',
        reference_id=instance.id
    ).exists():
        logger.debug(f"Order {instance.id} already processed for inventory deduction")
        return

    # Perform deduction
    from apps.inventory.services import deduct_ingredients_for_order

    logger.info(f"Processing inventory deduction for order {instance.id}")
    try:
        deduct_ingredients_for_order(instance)
    except Exception as e:
        # Log error but don't block order completion
        logger.error(f"Inventory deduction failed for order {instance.id}: {e}")
```

3. Update apps.py to register signal:

```python
from django.apps import AppConfig


class InventoryConfig(AppConfig):
    name = 'apps.inventory'
    default_auto_field = 'django.db.models.BigAutoField'

    def ready(self):
        # Import signals to register handlers
        import apps.inventory.signals  # noqa: F401
```

CRITICAL: The signal must be imported in ready() to register. This is the standard Django pattern.
  </action>
  <verify>
cd apps/api && python -c "
from django.apps import apps
apps.get_app_config('inventory').ready()
from apps.inventory.signals import handle_order_completion
print('Signal handler registered successfully')
"
  </verify>
  <done>
Signal handler created that triggers on order completion and calls deduct_ingredients_for_order. Logs warnings for insufficient stock but does not block completion.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create recipe API endpoints and tests</name>
  <files>
    apps/api/apps/inventory/serializers.py
    apps/api/apps/inventory/views.py
    apps/api/apps/inventory/urls.py
    apps/api/apps/inventory/tests/factories.py
    apps/api/apps/inventory/tests/test_services.py
    apps/api/apps/inventory/tests/test_signals.py
  </files>
  <action>
1. Add to serializers.py:

```python
class MenuItemIngredientSerializer(serializers.ModelSerializer):
    """Serializer for recipe ingredient mapping."""

    menu_item_name = serializers.CharField(source='menu_item.name', read_only=True)
    stock_item_name = serializers.CharField(source='stock_item.name', read_only=True)
    stock_item_unit = serializers.CharField(source='stock_item.unit', read_only=True)

    class Meta:
        model = MenuItemIngredient
        fields = [
            'id', 'menu_item', 'menu_item_name',
            'stock_item', 'stock_item_name', 'stock_item_unit',
            'quantity_required',
        ]
        read_only_fields = ['id']

    def validate(self, data):
        """Ensure menu_item and stock_item belong to same restaurant."""
        menu_item = data.get('menu_item')
        stock_item = data.get('stock_item')

        if menu_item and stock_item:
            if menu_item.restaurant_id != stock_item.restaurant_id:
                raise serializers.ValidationError(
                    "Menu item and stock item must belong to the same restaurant"
                )
        return data


class MenuItemIngredientsListSerializer(serializers.Serializer):
    """For viewing all ingredients for a menu item."""

    menu_item_id = serializers.UUIDField(read_only=True)
    menu_item_name = serializers.CharField(read_only=True)
    ingredients = MenuItemIngredientSerializer(many=True, read_only=True)
```

2. Add to views.py:

```python
class MenuItemIngredientViewSet(TenantModelViewSet):
    """
    ViewSet for managing recipe ingredient mappings.

    GET /api/inventory/recipes/ - List all mappings
    POST /api/inventory/recipes/ - Create mapping
    GET /api/inventory/recipes/{id}/ - Get mapping detail
    PUT/PATCH /api/inventory/recipes/{id}/ - Update mapping
    DELETE /api/inventory/recipes/{id}/ - Delete mapping
    GET /api/inventory/recipes/by-menu-item/?menu_item={id} - Get all for menu item
    """

    serializer_class = MenuItemIngredientSerializer
    permission_classes = [IsAuthenticated, IsManagerOrOwner]

    def get_queryset(self):
        from apps.inventory.models import MenuItemIngredient
        from apps.core.context import get_current_restaurant

        restaurant = get_current_restaurant()
        queryset = MenuItemIngredient.objects.filter(restaurant=restaurant)

        # Filter by menu_item if provided
        menu_item_id = self.request.query_params.get('menu_item')
        if menu_item_id:
            queryset = queryset.filter(menu_item_id=menu_item_id)

        # Filter by stock_item if provided
        stock_item_id = self.request.query_params.get('stock_item')
        if stock_item_id:
            queryset = queryset.filter(stock_item_id=stock_item_id)

        return queryset.select_related('menu_item', 'stock_item')

    def perform_create(self, serializer):
        from apps.core.context import get_current_restaurant
        serializer.save(restaurant=get_current_restaurant())
```

3. Update urls.py to add recipe endpoint:

```python
router.register('recipes', MenuItemIngredientViewSet, basename='recipe')
```

4. Update tests/factories.py:

```python
class MenuItemIngredientFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = MenuItemIngredient

    restaurant = factory.SubFactory(RestaurantFactory)
    menu_item = factory.SubFactory(MenuItemFactory)
    stock_item = factory.SubFactory(StockItemFactory)
    quantity_required = factory.Faker('pydecimal', left_digits=2, right_digits=4, positive=True)
```

5. Create tests/test_services.py:

```python
"""Tests for inventory services."""
import pytest
from decimal import Decimal
from apps.inventory.services import deduct_ingredients_for_order, InsufficientStockError

class TestDeductIngredientsForOrder:
    """Test automatic ingredient deduction."""

    def test_deducts_ingredients_for_completed_order(self, order_with_ingredients):
        """Completing order deducts all mapped ingredients."""
        # Setup: Order has 2 items, each with ingredients
        initial_stock = order_with_ingredients.stock_item.current_quantity

        deduct_ingredients_for_order(order_with_ingredients.order)

        order_with_ingredients.stock_item.refresh_from_db()
        assert order_with_ingredients.stock_item.current_quantity < initial_stock

    def test_logs_warning_for_insufficient_stock(self, order_with_insufficient_stock, caplog):
        """Insufficient stock logs warning but completes."""
        deduct_ingredients_for_order(order_with_insufficient_stock.order)

        assert "Insufficient stock" in caplog.text

    def test_skips_menu_items_without_ingredients(self, order_without_ingredients):
        """Orders without ingredient mappings complete without error."""
        deduct_ingredients_for_order(order_without_ingredients)
        # Should complete without error
```

6. Create tests/test_signals.py:

```python
"""Tests for inventory signals."""
import pytest
from apps.orders.models import OrderStatus

class TestOrderCompletionSignal:
    """Test order completion triggers inventory deduction."""

    def test_completing_order_deducts_stock(self, order_with_ingredients, db):
        """Marking order as completed triggers stock deduction."""
        order = order_with_ingredients.order
        stock_item = order_with_ingredients.stock_item
        initial_qty = stock_item.current_quantity

        # Complete the order
        order.status = OrderStatus.COMPLETED
        order.save()

        stock_item.refresh_from_db()
        assert stock_item.current_quantity < initial_qty

    def test_pending_order_does_not_deduct(self, order_with_ingredients, db):
        """Pending orders do not trigger deduction."""
        order = order_with_ingredients.order
        stock_item = order_with_ingredients.stock_item
        initial_qty = stock_item.current_quantity

        order.status = OrderStatus.PENDING
        order.save()

        stock_item.refresh_from_db()
        assert stock_item.current_quantity == initial_qty

    def test_cancelled_order_does_not_deduct(self, order_with_ingredients, db):
        """Cancelled orders do not trigger deduction."""
        order = order_with_ingredients.order
        stock_item = order_with_ingredients.stock_item
        initial_qty = stock_item.current_quantity

        order.status = OrderStatus.CANCELLED
        order.save()

        stock_item.refresh_from_db()
        assert stock_item.current_quantity == initial_qty

    def test_duplicate_completion_does_not_double_deduct(self, completed_order_with_ingredients, db):
        """Re-saving completed order does not deduct again."""
        order = completed_order_with_ingredients.order
        stock_item = completed_order_with_ingredients.stock_item

        # Get quantity after first completion
        stock_item.refresh_from_db()
        qty_after_first = stock_item.current_quantity

        # Re-save the order
        order.notes = "Updated notes"
        order.save()

        stock_item.refresh_from_db()
        assert stock_item.current_quantity == qty_after_first
```
  </action>
  <verify>
cd apps/api && python manage.py migrate
cd apps/api && pytest apps/inventory/tests/test_services.py apps/inventory/tests/test_signals.py -v --tb=short
  </verify>
  <done>
Recipe API endpoints working (CRUD for MenuItemIngredient). Signal handler tested: deducts on completion only, logs warnings for insufficient stock, prevents double-deduction.
  </done>
</task>

</tasks>

<verification>
1. Recipe mapping CRUD works:
   - POST /api/inventory/recipes/ creates mapping
   - GET /api/inventory/recipes/?menu_item={id} returns ingredients for menu item

2. Order completion triggers deduction:
   - Create order with items that have ingredient mappings
   - Complete order (status = completed)
   - Verify stock quantities decreased
   - Verify StockMovement records created with reference_type='Order'

3. Edge cases handled:
   - Menu items without ingredients: No error, completes normally
   - Insufficient stock: Logs warning, creates negative movement, completes
   - Double completion: Does not deduct twice

4. All tests pass:
   - pytest apps/inventory/tests/ -v
</verification>

<success_criteria>
- MenuItemIngredient model links MenuItem to StockItem with quantity_required
- Signal handler fires on Order.status == 'completed'
- deduct_ingredients_for_order processes all order items and their ingredients
- Insufficient stock logs warning but does not block order completion
- API: CRUD for recipes at /api/inventory/recipes/
- All tests pass including signal integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-inventory/03-02-SUMMARY.md`
</output>
