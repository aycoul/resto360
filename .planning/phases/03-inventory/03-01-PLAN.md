---
phase: 03-inventory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/apps/inventory/__init__.py
  - apps/api/apps/inventory/apps.py
  - apps/api/apps/inventory/models.py
  - apps/api/apps/inventory/serializers.py
  - apps/api/apps/inventory/views.py
  - apps/api/apps/inventory/urls.py
  - apps/api/apps/inventory/admin.py
  - apps/api/apps/inventory/services.py
  - apps/api/apps/inventory/migrations/0001_initial.py
  - apps/api/apps/inventory/tests/__init__.py
  - apps/api/apps/inventory/tests/factories.py
  - apps/api/apps/inventory/tests/conftest.py
  - apps/api/apps/inventory/tests/test_models.py
  - apps/api/apps/inventory/tests/test_api.py
  - apps/api/config/settings/base.py
  - apps/api/config/urls.py
  - requirements/base.txt
autonomous: true

must_haves:
  truths:
    - "Manager can create stock items with name, SKU, quantity, and unit"
    - "Manager can add stock to items (receipts)"
    - "Manager can adjust stock quantities with reasons"
    - "All stock changes create immutable movement records"
    - "Stock quantities update atomically (no race conditions)"
  artifacts:
    - path: "apps/api/apps/inventory/models.py"
      provides: "StockItem and StockMovement models"
      contains: ["class StockItem", "class StockMovement", "HistoricalRecords"]
    - path: "apps/api/apps/inventory/services.py"
      provides: "Atomic stock operations"
      contains: ["select_for_update", "F("]
    - path: "apps/api/apps/inventory/views.py"
      provides: "Stock API endpoints"
      exports: ["StockItemViewSet", "StockMovementViewSet"]
  key_links:
    - from: "apps/api/apps/inventory/views.py"
      to: "apps/api/apps/inventory/services.py"
      via: "service function calls in viewset actions"
      pattern: "add_stock|deduct_stock|adjust_stock"
    - from: "apps/api/apps/inventory/services.py"
      to: "apps/api/apps/inventory/models.py"
      via: "F() expressions for atomic updates"
      pattern: "F\\('current_quantity'\\)"
---

<objective>
Create the inventory foundation: StockItem and StockMovement models with CRUD API and atomic stock operations.

Purpose: Enable managers to track stock items and all movements with full audit trail. This is the foundation for recipe mapping and automatic deduction in subsequent plans.

Output: Working inventory app with models, migrations, API endpoints, and services for atomic stock operations.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-inventory/03-RESEARCH.md

# Existing patterns to follow
@apps/api/apps/core/models.py
@apps/api/apps/core/managers.py
@apps/api/apps/menu/models.py
@apps/api/apps/menu/views.py
@apps/api/apps/menu/serializers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inventory app with models</name>
  <files>
    apps/api/apps/inventory/__init__.py
    apps/api/apps/inventory/apps.py
    apps/api/apps/inventory/models.py
    apps/api/apps/inventory/admin.py
    apps/api/apps/inventory/migrations/0001_initial.py
    apps/api/config/settings/base.py
    requirements/base.txt
  </files>
  <action>
1. Add django-simple-history to requirements/base.txt:
   ```
   django-simple-history>=3.11.0
   ```

2. Create inventory app structure at apps/api/apps/inventory/:
   - __init__.py (empty)
   - apps.py with InventoryConfig (name='apps.inventory')

3. Create models.py with:
   - UnitType TextChoices: kg, g, L, mL, piece, portion, other
   - MovementType TextChoices: in, out, adjustment
   - MovementReason TextChoices: purchase, order_usage, waste, theft, correction, transfer, initial

   - StockItem(TenantModel):
     - name: CharField(max_length=200)
     - sku: CharField(max_length=50, blank=True) - optional SKU
     - unit: CharField(max_length=20, choices=UnitType.choices)
     - current_quantity: DecimalField(max_digits=10, decimal_places=4, default=0)
     - low_stock_threshold: DecimalField(max_digits=10, decimal_places=4, null=True, blank=True)
     - low_stock_alert_sent: BooleanField(default=False) - prevent alert spam
     - is_active: BooleanField(default=True)
     - history = HistoricalRecords() - from django-simple-history
     - all_objects = models.Manager() FIRST, then objects = TenantManager()
     - Meta: unique_together = ['restaurant', 'sku'] (only if sku is not blank), ordering = ['name']
     - Use CheckConstraint for non-negative current_quantity

   - StockMovement(TenantModel):
     - stock_item: ForeignKey(StockItem, on_delete=PROTECT, related_name='movements')
     - quantity_change: DecimalField(max_digits=10, decimal_places=4) - positive for in, negative for out
     - movement_type: CharField(choices=MovementType.choices)
     - reason: CharField(choices=MovementReason.choices)
     - notes: TextField(blank=True)
     - reference_type: CharField(max_length=50, blank=True) - e.g., 'Order'
     - reference_id: UUIDField(null=True, blank=True)
     - balance_after: DecimalField(max_digits=10, decimal_places=4) - snapshot
     - created_by: ForeignKey(User, on_delete=SET_NULL, null=True)
     - all_objects = models.Manager() FIRST, then objects = TenantManager()
     - Meta: ordering = ['-created_at'], indexes on [stock_item, -created_at], [restaurant, -created_at]
     - Override save() to prevent updates (movements are immutable)

4. Create admin.py with:
   - StockItemAdmin(SimpleHistoryAdmin) with list_display, list_filter, search_fields
   - StockMovementAdmin with read-only permissions (has_change_permission returns False)

5. Add 'apps.inventory' to INSTALLED_APPS in config/settings/base.py (after 'apps.orders')
   Also add 'simple_history' to INSTALLED_APPS

6. Run: python manage.py makemigrations inventory
  </action>
  <verify>
cd apps/api && python manage.py makemigrations inventory --dry-run
cd apps/api && python manage.py check
  </verify>
  <done>
StockItem and StockMovement models defined with django-simple-history integration. Migration file created. App registered in settings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create atomic stock services</name>
  <files>
    apps/api/apps/inventory/services.py
  </files>
  <action>
Create services.py with atomic stock operations following research patterns:

1. Define InsufficientStockError exception class

2. add_stock(stock_item_id, quantity, reason, user, notes='', reference=None):
   - Use transaction.atomic() with select_for_update()
   - Use F() expression: StockItem.objects.filter(id=...).update(current_quantity=F('current_quantity') + quantity)
   - refresh_from_db() to get updated value
   - Clear low_stock_alert_sent if now above threshold
   - Create StockMovement record with movement_type='in', balance_after
   - Return updated stock_item

3. deduct_stock(stock_item_id, quantity, reason, user, notes='', reference=None):
   - Use transaction.atomic() with select_for_update()
   - Check if current_quantity >= quantity, raise InsufficientStockError if not
   - Use F() expression for atomic deduction
   - Create StockMovement with movement_type='out', negative quantity_change
   - Call check_low_stock_alert(stock_item) after deduction
   - Return updated stock_item

4. adjust_stock(stock_item_id, new_quantity, reason, user, notes=''):
   - Use transaction.atomic() with select_for_update()
   - Calculate difference: new_quantity - current_quantity
   - Use F() expression or direct update
   - Create StockMovement with movement_type='adjustment'
   - Handle low stock alert logic
   - Return updated stock_item

5. check_low_stock_alert(stock_item):
   - If threshold is None, return
   - If current_quantity <= threshold AND not alert_sent:
     - Set alert_sent = True, save with update_fields
     - Log warning (Celery task integration comes in Plan 03)
   - If current_quantity > threshold AND alert_sent:
     - Clear alert_sent flag

Key patterns from research:
- Always use select_for_update() before F() updates
- F() expressions prevent race conditions at DB level
- Movements are immutable - create new records, never update
- balance_after provides point-in-time snapshot for reports
  </action>
  <verify>
cd apps/api && python -c "from apps.inventory.services import add_stock, deduct_stock, adjust_stock, InsufficientStockError; print('Services imported successfully')"
  </verify>
  <done>
Atomic stock services implemented with F() expressions and select_for_update() for race-condition-safe operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoints and tests</name>
  <files>
    apps/api/apps/inventory/serializers.py
    apps/api/apps/inventory/views.py
    apps/api/apps/inventory/urls.py
    apps/api/config/urls.py
    apps/api/apps/inventory/tests/__init__.py
    apps/api/apps/inventory/tests/factories.py
    apps/api/apps/inventory/tests/conftest.py
    apps/api/apps/inventory/tests/test_models.py
    apps/api/apps/inventory/tests/test_api.py
  </files>
  <action>
1. Create serializers.py:
   - StockItemSerializer: All fields, read_only for current_quantity (updated via services only)
   - StockItemListSerializer: Condensed for list views (id, name, sku, unit, current_quantity, is_low_stock)
   - StockMovementSerializer: All fields, read_only (movements are created via service)
   - AddStockSerializer: quantity (DecimalField, min_value=0.0001), reason (choice), notes
   - AdjustStockSerializer: new_quantity (DecimalField, min_value=0), reason (choice), notes

2. Create views.py with TenantModelViewSet pattern (see menu/views.py):
   - StockItemViewSet:
     - get_queryset(): filter by restaurant from tenant context
     - list/retrieve/create/update/destroy for CRUD
     - @action(detail=True, methods=['post']) add_stock: validates AddStockSerializer, calls service
     - @action(detail=True, methods=['post']) adjust: validates AdjustStockSerializer, calls service
     - @action(detail=True, methods=['get']) movements: returns movement history for item

   - StockMovementViewSet (read-only):
     - get_queryset(): filter by restaurant, support ?stock_item=uuid filter
     - list only (no create/update/destroy - created via services)

3. Create urls.py:
   - router = DefaultRouter()
   - router.register('stock-items', StockItemViewSet, basename='stock-item')
   - router.register('movements', StockMovementViewSet, basename='stock-movement')
   - urlpatterns = router.urls

4. Wire up in config/urls.py:
   - path('api/inventory/', include('apps.inventory.urls'))

5. Create tests/factories.py:
   - StockItemFactory with Faker for name, sku
   - StockMovementFactory

6. Create tests/conftest.py with fixtures (follow menu/tests/conftest.py pattern)

7. Create tests/test_models.py:
   - Test StockItem creation with all fields
   - Test StockMovement immutability (save on existing raises error)
   - Test unique_together constraint for sku

8. Create tests/test_api.py:
   - Test CRUD operations for stock items
   - Test add_stock action creates movement record
   - Test adjust action with positive/negative adjustments
   - Test movements endpoint filtering
   - Test tenant isolation (can't see other restaurant's items)
  </action>
  <verify>
cd apps/api && python manage.py migrate
cd apps/api && pytest apps/inventory/tests/ -v --tb=short
curl -s http://localhost:8000/api/inventory/stock-items/ -H "Authorization: Bearer $TOKEN" | head -20 || echo "Server not running - tests sufficient"
  </verify>
  <done>
API endpoints created: GET/POST /api/inventory/stock-items/, POST /api/inventory/stock-items/{id}/add_stock/, POST /api/inventory/stock-items/{id}/adjust/, GET /api/inventory/movements/. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. Models exist and migrations applied:
   - cd apps/api && python manage.py showmigrations inventory
   - Should show: [X] 0001_initial

2. Stock operations are atomic:
   - Run concurrent add_stock calls in tests
   - Final quantity should equal sum of all additions

3. Movement immutability enforced:
   - Attempting to update StockMovement raises ValueError

4. API endpoints functional:
   - All CRUD tests pass
   - Tenant isolation verified
</verification>

<success_criteria>
- StockItem model with history tracking (django-simple-history)
- StockMovement model with immutable records
- add_stock, deduct_stock, adjust_stock services using F() expressions
- API endpoints for CRUD and stock operations
- All tests pass: pytest apps/inventory/tests/ -v
</success_criteria>

<output>
After completion, create `.planning/phases/03-inventory/03-01-SUMMARY.md`
</output>
