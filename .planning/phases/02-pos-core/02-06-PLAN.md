---
phase: 02-pos-core
plan: 06
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - apps/web/app/[locale]/kitchen/page.tsx
  - apps/web/app/[locale]/kitchen/layout.tsx
  - apps/web/components/kitchen/OrderQueue.tsx
  - apps/web/components/kitchen/OrderCard.tsx
  - apps/web/components/kitchen/OrderStatusColumn.tsx
  - apps/web/lib/hooks/useKitchenSocket.ts
  - apps/web/lib/hooks/useKitchenQueue.ts
autonomous: true

must_haves:
  truths:
    - "Kitchen display shows orders in status columns (pending/preparing/ready)"
    - "New orders appear automatically via WebSocket"
    - "Status changes update display in real-time"
    - "Kitchen staff can update order status"
    - "Orders are sorted by creation time (oldest first)"
    - "Display works when backend is temporarily unavailable"
  artifacts:
    - path: "apps/web/app/[locale]/kitchen/page.tsx"
      provides: "Kitchen display page"
      contains: "OrderQueue"
    - path: "apps/web/components/kitchen/OrderCard.tsx"
      provides: "Individual order card with status actions"
      contains: "OrderCard"
    - path: "apps/web/lib/hooks/useKitchenSocket.ts"
      provides: "WebSocket connection hook"
      contains: "useKitchenSocket"
  key_links:
    - from: "apps/web/lib/hooks/useKitchenSocket.ts"
      to: "ws/kitchen/"
      via: "WebSocket connection"
      pattern: "new WebSocket"
    - from: "apps/web/components/kitchen/OrderCard.tsx"
      to: "apps/web/lib/hooks/useKitchenSocket.ts"
      via: "Status update action"
      pattern: "updateStatus"
---

<objective>
Build the kitchen display interface with real-time WebSocket updates for order queue management.

Purpose: Kitchen staff need to see incoming orders and track preparation progress. Real-time updates ensure efficient order flow without manual refresh.

Output: Kitchen display page at /kitchen with live order queue organized by status columns.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pos-core/02-RESEARCH.md

# Depends on WebSocket backend and frontend foundation
@.planning/phases/02-pos-core/02-03-SUMMARY.md
@.planning/phases/02-pos-core/02-04-SUMMARY.md

# API types and client
@apps/web/lib/api/types.ts
@apps/web/lib/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket connection hook</name>
  <files>
    apps/web/lib/hooks/useKitchenSocket.ts
    apps/web/lib/hooks/useKitchenQueue.ts
  </files>
  <action>
    1. Create apps/web/lib/hooks/useKitchenSocket.ts:
       ```typescript
       'use client';

       import { useEffect, useRef, useState, useCallback } from 'react';
       import { getAccessToken } from '@/lib/api/client';
       import { Order } from '@/lib/api/types';

       type KitchenMessage =
         | { type: 'initial_queue'; orders: Order[] }
         | { type: 'order_created'; order: Order }
         | { type: 'order_updated'; order: Order }
         | { type: 'order_status_changed'; order_id: string; status: string };

       interface UseKitchenSocketOptions {
         restaurantId: string;
         onInitialQueue?: (orders: Order[]) => void;
         onOrderCreated?: (order: Order) => void;
         onOrderUpdated?: (order: Order) => void;
         onStatusChanged?: (orderId: string, status: string) => void;
       }

       export function useKitchenSocket({
         restaurantId,
         onInitialQueue,
         onOrderCreated,
         onOrderUpdated,
         onStatusChanged,
       }: UseKitchenSocketOptions) {
         const wsRef = useRef<WebSocket | null>(null);
         const [isConnected, setIsConnected] = useState(false);
         const [error, setError] = useState<string | null>(null);
         const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
         const reconnectAttempts = useRef(0);

         const connect = useCallback(() => {
           const token = getAccessToken();
           if (!token) {
             setError('No authentication token');
             return;
           }

           const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000';
           const ws = new WebSocket(
             `${wsUrl}/ws/kitchen/${restaurantId}/?token=${token}`
           );

           ws.onopen = () => {
             setIsConnected(true);
             setError(null);
             reconnectAttempts.current = 0;
           };

           ws.onmessage = (event) => {
             try {
               const message: KitchenMessage = JSON.parse(event.data);

               switch (message.type) {
                 case 'initial_queue':
                   onInitialQueue?.(message.orders);
                   break;
                 case 'order_created':
                   onOrderCreated?.(message.order);
                   break;
                 case 'order_updated':
                   onOrderUpdated?.(message.order);
                   break;
                 case 'order_status_changed':
                   onStatusChanged?.(message.order_id, message.status);
                   break;
               }
             } catch (e) {
               console.error('Failed to parse WebSocket message:', e);
             }
           };

           ws.onerror = () => {
             setError('WebSocket connection error');
           };

           ws.onclose = (event) => {
             setIsConnected(false);
             wsRef.current = null;

             // Reconnect with exponential backoff
             if (event.code !== 1000) { // Not a clean close
               const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
               reconnectAttempts.current += 1;
               reconnectTimeoutRef.current = setTimeout(connect, delay);
             }
           };

           wsRef.current = ws;
         }, [restaurantId, onInitialQueue, onOrderCreated, onOrderUpdated, onStatusChanged]);

         const disconnect = useCallback(() => {
           if (reconnectTimeoutRef.current) {
             clearTimeout(reconnectTimeoutRef.current);
           }
           if (wsRef.current) {
             wsRef.current.close(1000);
             wsRef.current = null;
           }
         }, []);

         const sendStatusUpdate = useCallback((orderId: string, status: string) => {
           if (wsRef.current?.readyState === WebSocket.OPEN) {
             wsRef.current.send(JSON.stringify({
               type: 'update_status',
               order_id: orderId,
               status,
             }));
           }
         }, []);

         useEffect(() => {
           connect();
           return disconnect;
         }, [connect, disconnect]);

         return {
           isConnected,
           error,
           sendStatusUpdate,
           reconnect: connect,
         };
       }
       ```

    2. Create apps/web/lib/hooks/useKitchenQueue.ts:
       ```typescript
       'use client';

       import { useState, useCallback, useMemo } from 'react';
       import { Order } from '@/lib/api/types';
       import { api } from '@/lib/api/client';

       type OrderStatus = 'pending' | 'preparing' | 'ready' | 'completed' | 'cancelled';

       export function useKitchenQueue() {
         const [orders, setOrders] = useState<Order[]>([]);
         const [isLoading, setIsLoading] = useState(true);

         const handleInitialQueue = useCallback((initialOrders: Order[]) => {
           setOrders(initialOrders);
           setIsLoading(false);
         }, []);

         const handleOrderCreated = useCallback((order: Order) => {
           setOrders(prev => {
             // Check if order already exists
             if (prev.some(o => o.id === order.id)) {
               return prev;
             }
             // Add to end, maintaining sort by created_at
             return [...prev, order].sort(
               (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
             );
           });
         }, []);

         const handleOrderUpdated = useCallback((order: Order) => {
           setOrders(prev =>
             prev.map(o => (o.id === order.id ? order : o))
           );
         }, []);

         const handleStatusChanged = useCallback((orderId: string, status: string) => {
           setOrders(prev =>
             prev.map(o =>
               o.id === orderId ? { ...o, status: status as OrderStatus } : o
             )
           );
         }, []);

         const updateOrderStatus = useCallback(async (orderId: string, status: OrderStatus) => {
           try {
             // Optimistic update
             setOrders(prev =>
               prev.map(o => (o.id === orderId ? { ...o, status } : o))
             );

             // API call
             await api.patch(`/api/v1/orders/${orderId}/status/`, { status });
           } catch (error) {
             console.error('Failed to update order status:', error);
             // Revert on error - refetch from server would be better
           }
         }, []);

         const pendingOrders = useMemo(
           () => orders.filter(o => o.status === 'pending'),
           [orders]
         );

         const preparingOrders = useMemo(
           () => orders.filter(o => o.status === 'preparing'),
           [orders]
         );

         const readyOrders = useMemo(
           () => orders.filter(o => o.status === 'ready'),
           [orders]
         );

         return {
           orders,
           pendingOrders,
           preparingOrders,
           readyOrders,
           isLoading,
           handleInitialQueue,
           handleOrderCreated,
           handleOrderUpdated,
           handleStatusChanged,
           updateOrderStatus,
         };
       }
       ```
  </action>
  <verify>Import hooks and verify TypeScript compilation</verify>
  <done>WebSocket hook with reconnection, queue state management ready</done>
</task>

<task type="auto">
  <name>Task 2: Create kitchen display page and layout</name>
  <files>
    apps/web/app/[locale]/kitchen/layout.tsx
    apps/web/app/[locale]/kitchen/page.tsx
  </files>
  <action>
    1. Create apps/web/app/[locale]/kitchen/layout.tsx:
       ```typescript
       export default function KitchenLayout({ children }: { children: React.ReactNode }) {
         return (
           <div className="min-h-screen bg-gray-900">
             {children}
           </div>
         );
       }
       ```

    2. Create apps/web/app/[locale]/kitchen/page.tsx:
       ```typescript
       'use client';

       import { useTranslations } from 'next-intl';
       import { useKitchenSocket } from '@/lib/hooks/useKitchenSocket';
       import { useKitchenQueue } from '@/lib/hooks/useKitchenQueue';
       import { OrderQueue } from '@/components/kitchen/OrderQueue';
       import { LocaleSwitcher } from '@/components/ui/LocaleSwitcher';

       // In real app, get this from auth context
       const MOCK_RESTAURANT_ID = 'restaurant-uuid-here';

       export default function KitchenPage() {
         const t = useTranslations('kitchen');
         const {
           pendingOrders,
           preparingOrders,
           readyOrders,
           isLoading,
           handleInitialQueue,
           handleOrderCreated,
           handleOrderUpdated,
           handleStatusChanged,
           updateOrderStatus,
         } = useKitchenQueue();

         const { isConnected, error } = useKitchenSocket({
           restaurantId: MOCK_RESTAURANT_ID,
           onInitialQueue: handleInitialQueue,
           onOrderCreated: handleOrderCreated,
           onOrderUpdated: handleOrderUpdated,
           onStatusChanged: handleStatusChanged,
         });

         return (
           <div className="h-screen flex flex-col">
             {/* Header */}
             <header className="bg-gray-800 text-white px-6 py-4 flex items-center justify-between">
               <div className="flex items-center gap-4">
                 <h1 className="text-2xl font-bold">{t('title')}</h1>
                 <div className={`w-3 h-3 rounded-full ${
                   isConnected ? 'bg-green-500' : 'bg-red-500'
                 }`} />
                 {error && <span className="text-red-400 text-sm">{error}</span>}
               </div>
               <div className="flex items-center gap-4">
                 <span className="text-gray-400">
                   {new Date().toLocaleTimeString()}
                 </span>
                 <LocaleSwitcher />
               </div>
             </header>

             {/* Queue */}
             {isLoading ? (
               <div className="flex-1 flex items-center justify-center text-white">
                 <p>{t('queue')}...</p>
               </div>
             ) : (
               <OrderQueue
                 pendingOrders={pendingOrders}
                 preparingOrders={preparingOrders}
                 readyOrders={readyOrders}
                 onUpdateStatus={updateOrderStatus}
               />
             )}
           </div>
         );
       }
       ```

    Note: The MOCK_RESTAURANT_ID will need to be replaced with actual restaurant ID from auth context in real implementation.
  </action>
  <verify>Visit http://localhost:3000/fr/kitchen, verify page renders with header</verify>
  <done>Kitchen page with WebSocket connection and status indicator</done>
</task>

<task type="auto">
  <name>Task 3: Build order queue components</name>
  <files>
    apps/web/components/kitchen/OrderQueue.tsx
    apps/web/components/kitchen/OrderStatusColumn.tsx
    apps/web/components/kitchen/OrderCard.tsx
  </files>
  <action>
    1. Create apps/web/components/kitchen/OrderQueue.tsx:
       ```typescript
       'use client';

       import { Order } from '@/lib/api/types';
       import { OrderStatusColumn } from './OrderStatusColumn';

       interface OrderQueueProps {
         pendingOrders: Order[];
         preparingOrders: Order[];
         readyOrders: Order[];
         onUpdateStatus: (orderId: string, status: 'pending' | 'preparing' | 'ready' | 'completed') => void;
       }

       export function OrderQueue({
         pendingOrders,
         preparingOrders,
         readyOrders,
         onUpdateStatus,
       }: OrderQueueProps) {
         return (
           <div className="flex-1 flex overflow-hidden">
             <OrderStatusColumn
               title="pending"
               orders={pendingOrders}
               color="yellow"
               nextStatus="preparing"
               onUpdateStatus={onUpdateStatus}
             />
             <OrderStatusColumn
               title="preparing"
               orders={preparingOrders}
               color="blue"
               nextStatus="ready"
               onUpdateStatus={onUpdateStatus}
             />
             <OrderStatusColumn
               title="ready"
               orders={readyOrders}
               color="green"
               nextStatus="completed"
               onUpdateStatus={onUpdateStatus}
             />
           </div>
         );
       }
       ```

    2. Create apps/web/components/kitchen/OrderStatusColumn.tsx:
       ```typescript
       'use client';

       import { useTranslations } from 'next-intl';
       import { Order } from '@/lib/api/types';
       import { OrderCard } from './OrderCard';

       interface OrderStatusColumnProps {
         title: 'pending' | 'preparing' | 'ready';
         orders: Order[];
         color: 'yellow' | 'blue' | 'green';
         nextStatus: 'preparing' | 'ready' | 'completed';
         onUpdateStatus: (orderId: string, status: string) => void;
       }

       const colorClasses = {
         yellow: {
           bg: 'bg-yellow-500/20',
           border: 'border-yellow-500',
           header: 'bg-yellow-500',
         },
         blue: {
           bg: 'bg-blue-500/20',
           border: 'border-blue-500',
           header: 'bg-blue-500',
         },
         green: {
           bg: 'bg-green-500/20',
           border: 'border-green-500',
           header: 'bg-green-500',
         },
       };

       export function OrderStatusColumn({
         title,
         orders,
         color,
         nextStatus,
         onUpdateStatus,
       }: OrderStatusColumnProps) {
         const t = useTranslations('kitchen');
         const colors = colorClasses[color];

         return (
           <div className={`flex-1 flex flex-col border-r border-gray-700 ${colors.bg}`}>
             {/* Column Header */}
             <div className={`${colors.header} text-white px-4 py-3 flex items-center justify-between`}>
               <h2 className="font-bold text-lg">{t(title)}</h2>
               <span className="bg-white/20 px-2 py-0.5 rounded text-sm">
                 {orders.length}
               </span>
             </div>

             {/* Orders */}
             <div className="flex-1 overflow-y-auto p-4 space-y-4">
               {orders.map(order => (
                 <OrderCard
                   key={order.id}
                   order={order}
                   nextStatus={nextStatus}
                   onStatusUpdate={(status) => onUpdateStatus(order.id, status)}
                 />
               ))}
               {orders.length === 0 && (
                 <p className="text-gray-500 text-center py-8">
                   No orders
                 </p>
               )}
             </div>
           </div>
         );
       }
       ```

    3. Create apps/web/components/kitchen/OrderCard.tsx:
       ```typescript
       'use client';

       import { useTranslations } from 'next-intl';
       import { Order } from '@/lib/api/types';
       import { Button } from '@/components/ui/Button';

       interface OrderCardProps {
         order: Order;
         nextStatus: 'preparing' | 'ready' | 'completed';
         onStatusUpdate: (status: string) => void;
       }

       export function OrderCard({ order, nextStatus, onStatusUpdate }: OrderCardProps) {
         const t = useTranslations('kitchen');

         const orderTypeLabel = {
           dine_in: 'Dine In',
           takeout: 'Takeout',
           delivery: 'Delivery',
         }[order.order_type];

         const actionLabel = {
           preparing: t('markPreparing'),
           ready: t('markReady'),
           completed: t('markComplete'),
         }[nextStatus];

         const timeSinceCreated = getTimeSince(new Date(order.created_at));

         return (
           <div className="bg-white rounded-lg shadow-lg overflow-hidden">
             {/* Header */}
             <div className="bg-gray-800 text-white px-4 py-2 flex items-center justify-between">
               <span className="font-bold text-lg">#{order.order_number}</span>
               <div className="flex items-center gap-2">
                 <span className="text-sm bg-white/20 px-2 py-0.5 rounded">
                   {orderTypeLabel}
                 </span>
                 {order.table && (
                   <span className="text-sm bg-blue-500 px-2 py-0.5 rounded">
                     {order.table}
                   </span>
                 )}
               </div>
             </div>

             {/* Items */}
             <div className="p-4">
               <ul className="space-y-2">
                 {order.items.map((item, index) => (
                   <li key={index} className="flex justify-between">
                     <div>
                       <span className="font-medium">
                         {item.quantity}x {item.menu_item_name}
                       </span>
                       {item.modifiers.length > 0 && (
                         <p className="text-sm text-gray-500 ml-4">
                           {item.modifiers.map(m => m.modifier_option_name).join(', ')}
                         </p>
                       )}
                       {item.notes && (
                         <p className="text-sm text-orange-600 ml-4 italic">
                           {item.notes}
                         </p>
                       )}
                     </div>
                   </li>
                 ))}
               </ul>

               {order.notes && (
                 <div className="mt-3 p-2 bg-orange-100 rounded text-orange-800 text-sm">
                   Note: {order.notes}
                 </div>
               )}
             </div>

             {/* Footer */}
             <div className="px-4 py-3 bg-gray-50 flex items-center justify-between">
               <span className="text-sm text-gray-500">{timeSinceCreated}</span>
               <Button
                 onClick={() => onStatusUpdate(nextStatus)}
                 size="sm"
                 variant={nextStatus === 'completed' ? 'secondary' : 'primary'}
               >
                 {actionLabel}
               </Button>
             </div>
           </div>
         );
       }

       function getTimeSince(date: Date): string {
         const now = new Date();
         const diffMs = now.getTime() - date.getTime();
         const diffMins = Math.floor(diffMs / 60000);

         if (diffMins < 1) return 'Just now';
         if (diffMins < 60) return `${diffMins} min ago`;
         const diffHours = Math.floor(diffMins / 60);
         return `${diffHours}h ${diffMins % 60}m ago`;
       }
       ```
  </action>
  <verify>Visit http://localhost:3000/fr/kitchen, verify columns render with mock data if backend running</verify>
  <done>Order queue with status columns and cards ready</done>
</task>

<task type="auto">
  <name>Task 4: Add auto-refresh and sound notifications</name>
  <files>
    apps/web/components/kitchen/OrderQueue.tsx
    apps/web/lib/hooks/useKitchenQueue.ts
    apps/web/public/sounds/new-order.mp3
  </files>
  <action>
    1. Update apps/web/lib/hooks/useKitchenQueue.ts to include sound notification:
       ```typescript
       'use client';

       import { useState, useCallback, useMemo, useRef, useEffect } from 'react';
       import { Order } from '@/lib/api/types';
       import { api } from '@/lib/api/client';

       type OrderStatus = 'pending' | 'preparing' | 'ready' | 'completed' | 'cancelled';

       export function useKitchenQueue() {
         const [orders, setOrders] = useState<Order[]>([]);
         const [isLoading, setIsLoading] = useState(true);
         const audioRef = useRef<HTMLAudioElement | null>(null);

         // Initialize audio
         useEffect(() => {
           if (typeof window !== 'undefined') {
             audioRef.current = new Audio('/sounds/new-order.mp3');
             audioRef.current.volume = 0.5;
           }
         }, []);

         const playNewOrderSound = useCallback(() => {
           if (audioRef.current) {
             audioRef.current.currentTime = 0;
             audioRef.current.play().catch(() => {
               // Autoplay may be blocked, that's ok
             });
           }
         }, []);

         const handleInitialQueue = useCallback((initialOrders: Order[]) => {
           setOrders(initialOrders);
           setIsLoading(false);
         }, []);

         const handleOrderCreated = useCallback((order: Order) => {
           setOrders(prev => {
             if (prev.some(o => o.id === order.id)) {
               return prev;
             }
             return [...prev, order].sort(
               (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
             );
           });
           // Play sound for new order
           playNewOrderSound();
         }, [playNewOrderSound]);

         const handleOrderUpdated = useCallback((order: Order) => {
           setOrders(prev =>
             prev.map(o => (o.id === order.id ? order : o))
           );
         }, []);

         const handleStatusChanged = useCallback((orderId: string, status: string) => {
           setOrders(prev => {
             // Remove completed/cancelled orders after short delay
             if (status === 'completed' || status === 'cancelled') {
               setTimeout(() => {
                 setOrders(current => current.filter(o => o.id !== orderId));
               }, 2000);
             }
             return prev.map(o =>
               o.id === orderId ? { ...o, status: status as OrderStatus } : o
             );
           });
         }, []);

         const updateOrderStatus = useCallback(async (orderId: string, status: OrderStatus) => {
           try {
             setOrders(prev =>
               prev.map(o => (o.id === orderId ? { ...o, status } : o))
             );

             await api.patch(`/api/v1/orders/${orderId}/status/`, { status });

             // Remove completed orders after delay
             if (status === 'completed') {
               setTimeout(() => {
                 setOrders(prev => prev.filter(o => o.id !== orderId));
               }, 2000);
             }
           } catch (error) {
             console.error('Failed to update order status:', error);
           }
         }, []);

         const pendingOrders = useMemo(
           () => orders.filter(o => o.status === 'pending'),
           [orders]
         );

         const preparingOrders = useMemo(
           () => orders.filter(o => o.status === 'preparing'),
           [orders]
         );

         const readyOrders = useMemo(
           () => orders.filter(o => o.status === 'ready'),
           [orders]
         );

         return {
           orders,
           pendingOrders,
           preparingOrders,
           readyOrders,
           isLoading,
           handleInitialQueue,
           handleOrderCreated,
           handleOrderUpdated,
           handleStatusChanged,
           updateOrderStatus,
         };
       }
       ```

    2. Create placeholder sound file apps/web/public/sounds/new-order.mp3:
       Note: Need to add an actual MP3 file. For now, can use a simple beep sound.
       Can download from freesound.org or generate programmatically.

       Alternative: Use Web Audio API for simple beep:
       ```typescript
       // In useKitchenQueue.ts, replace audioRef with:
       const playNewOrderSound = useCallback(() => {
         if (typeof window === 'undefined') return;
         try {
           const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
           const oscillator = audioContext.createOscillator();
           const gainNode = audioContext.createGain();

           oscillator.connect(gainNode);
           gainNode.connect(audioContext.destination);

           oscillator.frequency.value = 800;
           oscillator.type = 'sine';
           gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
           gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

           oscillator.start(audioContext.currentTime);
           oscillator.stop(audioContext.currentTime + 0.5);
         } catch {
           // Audio not supported
         }
       }, []);
       ```

    3. Add auto-time update to kitchen page header (already has time display):
       Update apps/web/app/[locale]/kitchen/page.tsx header to auto-update time:
       ```typescript
       // Add inside KitchenPage component:
       const [currentTime, setCurrentTime] = useState(new Date());

       useEffect(() => {
         const interval = setInterval(() => {
           setCurrentTime(new Date());
         }, 1000);
         return () => clearInterval(interval);
       }, []);

       // In header, use:
       <span className="text-gray-400">
         {currentTime.toLocaleTimeString()}
       </span>
       ```
  </action>
  <verify>New orders trigger sound notification, time updates every second</verify>
  <done>Sound notifications and auto-refresh working</done>
</task>

</tasks>

<verification>
1. Kitchen page loads at /kitchen
2. WebSocket connects (green indicator)
3. Initial queue loads from WebSocket
4. New orders appear automatically
5. Status updates work (click button -> order moves column)
6. Sound plays on new order (if not blocked)
7. Completed orders fade out after 2 seconds
8. Time updates in header
</verification>

<success_criteria>
- Kitchen display shows three status columns (pending/preparing/ready)
- WebSocket connection with reconnection on failure
- New orders appear in real-time without refresh
- Status can be updated by clicking action button
- Order cards show all relevant info (number, type, items, modifiers, notes, time)
- Sound notification on new order
- Works with translated labels (French/English)
- Graceful handling when WebSocket disconnects
</success_criteria>

<output>
After completion, create `.planning/phases/02-pos-core/02-06-SUMMARY.md`
</output>
