---
phase: 02-pos-core
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - apps/api/requirements/base.txt
  - apps/api/config/asgi.py
  - apps/api/config/settings/base.py
  - apps/api/apps/orders/consumers.py
  - apps/api/apps/orders/routing.py
  - apps/api/apps/orders/signals.py
autonomous: true

must_haves:
  truths:
    - "Kitchen display receives real-time order updates via WebSocket"
    - "New orders appear on kitchen display without refresh"
    - "Status changes broadcast to all connected kitchen displays"
    - "WebSocket connections are authenticated"
    - "Orders are scoped to restaurant (multi-tenant WebSocket)"
  artifacts:
    - path: "apps/api/apps/orders/consumers.py"
      provides: "KitchenConsumer WebSocket consumer"
      contains: "class KitchenConsumer"
    - path: "apps/api/apps/orders/routing.py"
      provides: "WebSocket URL routing"
      contains: "websocket_urlpatterns"
    - path: "apps/api/apps/orders/signals.py"
      provides: "Signal handlers for order events"
      contains: "notify_kitchen"
    - path: "apps/api/config/asgi.py"
      provides: "ASGI application with WebSocket support"
      contains: "ProtocolTypeRouter"
  key_links:
    - from: "apps/api/apps/orders/signals.py"
      to: "apps/api/apps/orders/consumers.py"
      via: "Channel layer group_send"
      pattern: "group_send.*kitchen_"
    - from: "apps/api/apps/orders/views.py"
      to: "apps/api/apps/orders/signals.py"
      via: "Post-save notification"
      pattern: "notify_kitchen"
---

<objective>
Add Django Channels WebSocket support for real-time kitchen display updates.

Purpose: Kitchen staff need to see new orders and status changes in real-time without refreshing. This enables efficient order flow from cashier to kitchen.

Output: WebSocket endpoint at /ws/kitchen/{restaurant_id}/ that broadcasts order events to all connected kitchen displays.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pos-core/02-RESEARCH.md

# Depends on Plan 02
@.planning/phases/02-pos-core/02-02-SUMMARY.md

# Core infrastructure
@apps/api/apps/orders/models.py
@apps/api/apps/orders/serializers.py
@apps/api/config/asgi.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Django Channels and configure ASGI</name>
  <files>
    apps/api/requirements/base.txt
    apps/api/config/settings/base.py
    apps/api/config/asgi.py
  </files>
  <action>
    1. Add to requirements/base.txt:
       - channels>=4.3.2
       - channels-redis>=4.0

    2. Install: pip install -r requirements/base.txt

    3. Update config/settings/base.py:
       - Add 'channels' to INSTALLED_APPS (before 'django.contrib.staticfiles')
       - Add ASGI_APPLICATION = 'config.asgi.application'
       - Add CHANNEL_LAYERS configuration:
         ```python
         CHANNEL_LAYERS = {
             'default': {
                 'BACKEND': 'channels_redis.core.RedisChannelLayer',
                 'CONFIG': {
                     'hosts': [env('REDIS_URL', default='redis://localhost:6379/1')],
                 },
             },
         }
         ```
       - For testing, add in testing.py:
         ```python
         CHANNEL_LAYERS = {
             'default': {
                 'BACKEND': 'channels.layers.InMemoryChannelLayer'
             }
         }
         ```

    4. Update config/asgi.py:
       ```python
       import os
       from django.core.asgi import get_asgi_application
       from channels.routing import ProtocolTypeRouter, URLRouter
       from channels.auth import AuthMiddlewareStack
       from channels.security.websocket import AllowedHostsOriginValidator

       os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings.production')

       django_asgi_app = get_asgi_application()

       from apps.orders.routing import websocket_urlpatterns

       application = ProtocolTypeRouter({
           'http': django_asgi_app,
           'websocket': AllowedHostsOriginValidator(
               AuthMiddlewareStack(
                   URLRouter(websocket_urlpatterns)
               )
           ),
       })
       ```
  </action>
  <verify>python apps/api/manage.py check --settings=config.settings.development</verify>
  <done>Django Channels installed, ASGI configured with Redis channel layer</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket consumer and routing</name>
  <files>
    apps/api/apps/orders/consumers.py
    apps/api/apps/orders/routing.py
    apps/api/apps/orders/middleware.py
  </files>
  <action>
    Create apps/api/apps/orders/consumers.py:
    ```python
    import json
    from channels.generic.websocket import AsyncWebsocketConsumer
    from channels.db import database_sync_to_async
    from django.contrib.auth import get_user_model

    User = get_user_model()

    class KitchenConsumer(AsyncWebsocketConsumer):
        async def connect(self):
            self.restaurant_id = self.scope['url_route']['kwargs']['restaurant_id']

            # Verify user is authenticated and belongs to this restaurant
            user = self.scope.get('user')
            if not user or not user.is_authenticated:
                await self.close(code=4001)
                return

            # Verify user has access to this restaurant
            if str(user.restaurant_id) != self.restaurant_id:
                await self.close(code=4003)
                return

            self.room_group_name = f'kitchen_{self.restaurant_id}'

            # Join room group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            await self.accept()

            # Send current queue on connect
            queue = await self.get_kitchen_queue()
            await self.send(text_data=json.dumps({
                'type': 'initial_queue',
                'orders': queue
            }))

        async def disconnect(self, close_code):
            if hasattr(self, 'room_group_name'):
                await self.channel_layer.group_discard(
                    self.room_group_name,
                    self.channel_name
                )

        async def receive(self, text_data):
            """Handle incoming messages (e.g., status updates from kitchen)"""
            data = json.loads(text_data)
            message_type = data.get('type')

            if message_type == 'update_status':
                order_id = data.get('order_id')
                new_status = data.get('status')
                success = await self.update_order_status(order_id, new_status)
                if success:
                    # Broadcast will happen via signal
                    pass

        async def order_created(self, event):
            """Handle new order event - called by channel layer group_send"""
            await self.send(text_data=json.dumps({
                'type': 'order_created',
                'order': event['order']
            }))

        async def order_updated(self, event):
            """Handle order update event - called by channel layer group_send"""
            await self.send(text_data=json.dumps({
                'type': 'order_updated',
                'order': event['order']
            }))

        async def order_status_changed(self, event):
            """Handle status change event - called by channel layer group_send"""
            await self.send(text_data=json.dumps({
                'type': 'order_status_changed',
                'order_id': event['order_id'],
                'status': event['status']
            }))

        @database_sync_to_async
        def get_kitchen_queue(self):
            from apps.orders.models import Order, OrderStatus
            from apps.orders.serializers import OrderSerializer

            orders = Order.objects.filter(
                restaurant_id=self.restaurant_id,
                status__in=[OrderStatus.PENDING, OrderStatus.PREPARING, OrderStatus.READY]
            ).select_related('table', 'created_by').prefetch_related(
                'items__menu_item', 'items__modifiers__modifier_option'
            ).order_by('created_at')

            return OrderSerializer(orders, many=True).data

        @database_sync_to_async
        def update_order_status(self, order_id, new_status):
            from apps.orders.models import Order
            try:
                order = Order.objects.get(id=order_id, restaurant_id=self.restaurant_id)
                order.status = new_status
                order.save(update_fields=['status', 'updated_at'])
                return True
            except Order.DoesNotExist:
                return False
    ```

    Create apps/api/apps/orders/routing.py:
    ```python
    from django.urls import re_path
    from . import consumers

    websocket_urlpatterns = [
        re_path(
            r'ws/kitchen/(?P<restaurant_id>[0-9a-f-]+)/$',
            consumers.KitchenConsumer.as_asgi()
        ),
    ]
    ```

    Create JWT WebSocket authentication middleware in apps/api/apps/orders/middleware.py:
    ```python
    from channels.db import database_sync_to_async
    from channels.middleware import BaseMiddleware
    from django.contrib.auth import get_user_model
    from django.contrib.auth.models import AnonymousUser
    from rest_framework_simplejwt.tokens import AccessToken
    from rest_framework_simplejwt.exceptions import TokenError
    from urllib.parse import parse_qs

    User = get_user_model()

    @database_sync_to_async
    def get_user_from_token(token_str):
        try:
            token = AccessToken(token_str)
            user_id = token.payload.get('user_id')
            return User.objects.get(id=user_id)
        except (TokenError, User.DoesNotExist):
            return AnonymousUser()

    class JWTAuthMiddleware(BaseMiddleware):
        async def __call__(self, scope, receive, send):
            query_string = parse_qs(scope.get('query_string', b'').decode())
            token = query_string.get('token', [None])[0]

            if token:
                scope['user'] = await get_user_from_token(token)
            else:
                scope['user'] = AnonymousUser()

            return await super().__call__(scope, receive, send)
    ```

    Update config/asgi.py to use JWT middleware:
    ```python
    from apps.orders.middleware import JWTAuthMiddleware

    application = ProtocolTypeRouter({
        'http': django_asgi_app,
        'websocket': AllowedHostsOriginValidator(
            JWTAuthMiddleware(
                URLRouter(websocket_urlpatterns)
            )
        ),
    })
    ```
  </action>
  <verify>Django check passes with WebSocket routing configured</verify>
  <done>KitchenConsumer created with JWT authentication, routing configured</done>
</task>

<task type="auto">
  <name>Task 3: Create signals to broadcast order events via WebSocket</name>
  <files>
    apps/api/apps/orders/signals.py
    apps/api/apps/orders/apps.py
    apps/api/apps/orders/views.py
  </files>
  <action>
    Create apps/api/apps/orders/signals.py:
    ```python
    from asgiref.sync import async_to_sync
    from channels.layers import get_channel_layer
    from django.db.models.signals import post_save
    from django.dispatch import receiver
    from .models import Order
    from .serializers import OrderSerializer

    def notify_kitchen_order_created(order):
        """
        Notify kitchen displays of new order.

        This function calls get_channel_layer() to get the channel layer,
        then uses async_to_sync(channel_layer.group_send) to send to the
        'kitchen_{restaurant_id}' group. The message has type 'order_created'
        which triggers KitchenConsumer.order_created() method in consumers.py.
        """
        channel_layer = get_channel_layer()
        if channel_layer is None:
            return  # No channel layer configured (e.g., in tests without Redis)

        async_to_sync(channel_layer.group_send)(
            f'kitchen_{order.restaurant_id}',
            {
                'type': 'order_created',  # Maps to consumer.order_created method
                'order': OrderSerializer(order).data
            }
        )

    def notify_kitchen_order_updated(order):
        """
        Notify kitchen displays of order update.

        Uses channel_layer.group_send to broadcast to kitchen_{restaurant_id} group.
        Message type 'order_updated' triggers KitchenConsumer.order_updated().
        """
        channel_layer = get_channel_layer()
        if channel_layer is None:
            return

        async_to_sync(channel_layer.group_send)(
            f'kitchen_{order.restaurant_id}',
            {
                'type': 'order_updated',  # Maps to consumer.order_updated method
                'order': OrderSerializer(order).data
            }
        )

    def notify_kitchen_status_changed(order):
        """
        Notify kitchen displays of status change.

        Uses channel_layer.group_send to broadcast to kitchen_{restaurant_id} group.
        Message type 'order_status_changed' triggers KitchenConsumer.order_status_changed().
        """
        channel_layer = get_channel_layer()
        if channel_layer is None:
            return

        async_to_sync(channel_layer.group_send)(
            f'kitchen_{order.restaurant_id}',
            {
                'type': 'order_status_changed',  # Maps to consumer.order_status_changed method
                'order_id': str(order.id),
                'status': order.status
            }
        )
    ```

    Update apps/api/apps/orders/apps.py:
    ```python
    from django.apps import AppConfig

    class OrdersConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'apps.orders'

        def ready(self):
            # Import signals to register them
            pass  # We'll call notify functions explicitly from views
    ```

    Update apps/api/apps/orders/views.py:
    - In OrderViewSet.perform_create(), after order is saved:
      ```python
      from .signals import notify_kitchen_order_created
      # After serializer.save() completes:
      notify_kitchen_order_created(serializer.instance)
      # This calls group_send('kitchen_{restaurant_id}', {'type': 'order_created', ...})
      # which triggers KitchenConsumer.order_created() for all connected clients
      ```

    - In OrderStatusUpdateView.patch(), after status is updated:
      ```python
      from .signals import notify_kitchen_status_changed
      # After order.save() completes:
      notify_kitchen_status_changed(order)
      # This calls group_send('kitchen_{restaurant_id}', {'type': 'order_status_changed', ...})
      # which triggers KitchenConsumer.order_status_changed() for all connected clients
      ```

    **Key wiring flow:**
    1. views.py calls notify_kitchen_order_created(order)
    2. signals.py gets channel_layer and calls group_send to 'kitchen_{restaurant_id}'
    3. Django Channels routes the message to all KitchenConsumer instances in that group
    4. consumer.order_created(event) is called, which sends JSON to the WebSocket client
  </action>
  <verify>Create order via API and check that signal functions execute without error</verify>
  <done>Signal functions created and wired to views, WebSocket notifications ready</done>
</task>

<task type="auto">
  <name>Task 4: Create WebSocket tests</name>
  <files>
    apps/api/apps/orders/tests/test_consumers.py
    apps/api/apps/orders/tests/test_signals.py
  </files>
  <action>
    Create test_consumers.py:
    ```python
    import pytest
    from channels.testing import WebsocketCommunicator
    from channels.routing import URLRouter
    from django.contrib.auth import get_user_model
    from rest_framework_simplejwt.tokens import AccessToken
    from apps.orders.routing import websocket_urlpatterns
    from apps.orders.middleware import JWTAuthMiddleware

    User = get_user_model()

    @pytest.fixture
    def application():
        return JWTAuthMiddleware(URLRouter(websocket_urlpatterns))

    @pytest.mark.asyncio
    @pytest.mark.django_db(transaction=True)
    async def test_kitchen_consumer_connect_authenticated(application, owner_user):
        """Test authenticated user can connect to kitchen WebSocket"""
        token = AccessToken.for_user(owner_user)
        communicator = WebsocketCommunicator(
            application,
            f"/ws/kitchen/{owner_user.restaurant_id}/?token={token}"
        )
        connected, _ = await communicator.connect()
        assert connected

        # Should receive initial queue
        response = await communicator.receive_json_from()
        assert response['type'] == 'initial_queue'
        assert 'orders' in response

        await communicator.disconnect()

    @pytest.mark.asyncio
    @pytest.mark.django_db(transaction=True)
    async def test_kitchen_consumer_reject_unauthenticated(application):
        """Test unauthenticated user cannot connect"""
        communicator = WebsocketCommunicator(
            application,
            "/ws/kitchen/some-uuid/"
        )
        connected, code = await communicator.connect()
        assert not connected or code == 4001

    @pytest.mark.asyncio
    @pytest.mark.django_db(transaction=True)
    async def test_kitchen_consumer_reject_wrong_restaurant(application, owner_user, other_restaurant):
        """Test user cannot connect to different restaurant's kitchen"""
        token = AccessToken.for_user(owner_user)
        communicator = WebsocketCommunicator(
            application,
            f"/ws/kitchen/{other_restaurant.id}/?token={token}"
        )
        connected, code = await communicator.connect()
        assert not connected or code == 4003

    @pytest.mark.asyncio
    @pytest.mark.django_db(transaction=True)
    async def test_kitchen_consumer_receives_new_order(application, owner_user, order_factory):
        """Test kitchen display receives new order notification"""
        token = AccessToken.for_user(owner_user)
        communicator = WebsocketCommunicator(
            application,
            f"/ws/kitchen/{owner_user.restaurant_id}/?token={token}"
        )
        await communicator.connect()

        # Clear initial queue message
        await communicator.receive_json_from()

        # Create order (this should trigger notification)
        # Note: In actual test, need to trigger via channel layer directly
        from channels.layers import get_channel_layer
        from asgiref.sync import async_to_sync
        channel_layer = get_channel_layer()

        await channel_layer.group_send(
            f'kitchen_{owner_user.restaurant_id}',
            {
                'type': 'order_created',
                'order': {'id': 'test-order', 'order_number': 1}
            }
        )

        response = await communicator.receive_json_from()
        assert response['type'] == 'order_created'
        assert response['order']['id'] == 'test-order'

        await communicator.disconnect()
    ```

    Create test_signals.py:
    ```python
    import pytest
    from unittest.mock import patch, MagicMock
    from apps.orders.signals import (
        notify_kitchen_order_created,
        notify_kitchen_order_updated,
        notify_kitchen_status_changed
    )

    @pytest.mark.django_db
    def test_notify_kitchen_order_created(order):
        """Test order created notification sends to channel layer"""
        with patch('apps.orders.signals.get_channel_layer') as mock_get_layer:
            mock_layer = MagicMock()
            mock_get_layer.return_value = mock_layer

            notify_kitchen_order_created(order)

            mock_layer.group_send.assert_called_once()
            call_args = mock_layer.group_send.call_args
            assert f'kitchen_{order.restaurant_id}' in call_args[0][0]
            assert call_args[0][1]['type'] == 'order_created'

    @pytest.mark.django_db
    def test_notify_kitchen_status_changed(order):
        """Test status change notification sends to channel layer"""
        with patch('apps.orders.signals.get_channel_layer') as mock_get_layer:
            mock_layer = MagicMock()
            mock_get_layer.return_value = mock_layer

            notify_kitchen_status_changed(order)

            mock_layer.group_send.assert_called_once()
            call_args = mock_layer.group_send.call_args
            assert call_args[0][1]['type'] == 'order_status_changed'
            assert call_args[0][1]['order_id'] == str(order.id)

    @pytest.mark.django_db
    def test_notify_no_channel_layer_graceful():
        """Test notification functions handle missing channel layer gracefully"""
        with patch('apps.orders.signals.get_channel_layer', return_value=None):
            # Should not raise exception
            notify_kitchen_order_created(MagicMock(restaurant_id='test'))
    ```

    Add pytest-asyncio to requirements/testing.txt:
    - pytest-asyncio>=0.23.0

    Run: pytest apps/api/apps/orders/tests/test_consumers.py apps/api/apps/orders/tests/test_signals.py -v
  </action>
  <verify>pytest apps/api/apps/orders/tests/test_consumers.py apps/api/apps/orders/tests/test_signals.py -v (all tests pass)</verify>
  <done>WebSocket consumer and signal tests passing</done>
</task>

</tasks>

<verification>
1. Django check passes: python apps/api/manage.py check
2. ASGI application loads correctly
3. All tests pass: pytest apps/api/apps/orders/tests/test_consumers.py apps/api/apps/orders/tests/test_signals.py -v
4. Lint passes: ruff check apps/api/apps/orders/
5. WebSocket connection works with valid JWT token
6. Order creation triggers WebSocket notification
</verification>

<success_criteria>
- Django Channels configured with Redis channel layer
- KitchenConsumer WebSocket consumer handles connect/disconnect/receive
- JWT authentication via query string for WebSocket connections
- Signal functions broadcast order events to kitchen displays
- Multi-tenant isolation: users can only connect to their restaurant's kitchen
- Initial queue sent on WebSocket connect
- All WebSocket tests pass (minimum 6 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pos-core/02-03-SUMMARY.md`
</output>
