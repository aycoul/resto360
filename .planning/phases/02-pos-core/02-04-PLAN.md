---
phase: 02-pos-core
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/next.config.js
  - apps/web/tsconfig.json
  - apps/web/tailwind.config.ts
  - apps/web/app/layout.tsx
  - apps/web/app/[locale]/layout.tsx
  - apps/web/middleware.ts
  - apps/web/i18n/request.ts
  - apps/web/messages/en.json
  - apps/web/messages/fr.json
  - apps/web/lib/db/schema.ts
  - apps/web/lib/api/client.ts
autonomous: true

must_haves:
  truths:
    - "Next.js app runs at http://localhost:3000"
    - "PWA manifest and service worker are configured"
    - "French and English translations load correctly"
    - "Locale switcher changes language"
    - "IndexedDB database schema is defined with Dexie"
    - "API client handles authentication headers"
  artifacts:
    - path: "apps/web/package.json"
      provides: "Next.js dependencies"
      contains: "next-intl"
    - path: "apps/web/middleware.ts"
      provides: "i18n routing middleware"
      contains: "createMiddleware"
    - path: "apps/web/lib/db/schema.ts"
      provides: "Dexie IndexedDB schema"
      contains: "class RestaurantDB"
    - path: "apps/web/lib/api/client.ts"
      provides: "Authenticated API client"
      contains: "fetch"
  key_links:
    - from: "apps/web/middleware.ts"
      to: "apps/web/app/[locale]/layout.tsx"
      via: "Locale routing"
      pattern: "locale.*params"
    - from: "apps/web/lib/api/client.ts"
      to: "apps/web/lib/db/schema.ts"
      via: "Offline fallback"
      pattern: "db\\."
---

<objective>
Create the Next.js PWA foundation with i18n (French/English), service worker, and IndexedDB schema.

Purpose: Establish the frontend architecture for offline-first POS operation. This provides the base layer for all subsequent frontend features.

Output: Working Next.js app with PWA capabilities, locale routing, Dexie database, and API client ready for POS features.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pos-core/02-RESEARCH.md

# No backend dependency - runs parallel with 02-01
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Next.js project with PWA and i18n packages</name>
  <files>
    apps/web/package.json
    apps/web/tsconfig.json
    apps/web/next.config.js
    apps/web/tailwind.config.ts
    apps/web/postcss.config.js
    apps/web/.gitignore
  </files>
  <action>
    1. Create apps/web directory:
       ```bash
       mkdir -p apps/web
       cd apps/web
       ```

    2. Initialize Next.js project with TypeScript and Tailwind:
       ```bash
       npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir=false --import-alias="@/*"
       ```
       When prompted, accept defaults.

    3. Install additional dependencies:
       ```bash
       npm install dexie dexie-react-hooks @ducanh2912/next-pwa next-intl @tanstack/react-query
       npm install -D @types/node
       ```

    4. Update next.config.js for PWA:
       ```javascript
       const withPWA = require('@ducanh2912/next-pwa').default({
         dest: 'public',
         disable: process.env.NODE_ENV === 'development',
         register: true,
         skipWaiting: true,
       });

       /** @type {import('next').NextConfig} */
       const nextConfig = {
         reactStrictMode: true,
         // API proxy for development
         async rewrites() {
           return [
             {
               source: '/api/:path*',
               destination: 'http://localhost:8000/api/:path*',
             },
           ];
         },
       };

       module.exports = withPWA(nextConfig);
       ```

    5. Create public/manifest.json:
       ```json
       {
         "name": "RESTO360 POS",
         "short_name": "RESTO360",
         "description": "Restaurant POS System",
         "start_url": "/",
         "display": "standalone",
         "background_color": "#ffffff",
         "theme_color": "#1f2937",
         "icons": [
           {
             "src": "/icon-192.png",
             "sizes": "192x192",
             "type": "image/png"
           },
           {
             "src": "/icon-512.png",
             "sizes": "512x512",
             "type": "image/png"
           }
         ]
       }
       ```

    6. Create placeholder icons (apps/web/public/):
       - icon-192.png (192x192 placeholder)
       - icon-512.png (512x512 placeholder)
       Note: Use simple colored squares for now, replace with real icons later.

    7. Update apps/web/.gitignore to include:
       ```
       # PWA
       public/sw.js
       public/workbox-*.js
       ```
  </action>
  <verify>cd apps/web && npm run dev (Next.js starts at localhost:3000)</verify>
  <done>Next.js project created with PWA configuration, all dependencies installed</done>
</task>

<task type="auto">
  <name>Task 2: Configure i18n with next-intl (French/English)</name>
  <files>
    apps/web/middleware.ts
    apps/web/i18n/request.ts
    apps/web/i18n/routing.ts
    apps/web/messages/en.json
    apps/web/messages/fr.json
    apps/web/app/[locale]/layout.tsx
    apps/web/app/[locale]/page.tsx
    apps/web/app/layout.tsx
  </files>
  <action>
    1. Create apps/web/i18n/routing.ts:
       ```typescript
       import { defineRouting } from 'next-intl/routing';

       export const routing = defineRouting({
         locales: ['fr', 'en'],
         defaultLocale: 'fr',
         localePrefix: 'always'
       });

       export const locales = routing.locales;
       export type Locale = (typeof locales)[number];
       ```

    2. Create apps/web/i18n/request.ts:
       ```typescript
       import { getRequestConfig } from 'next-intl/server';
       import { routing } from './routing';

       export default getRequestConfig(async ({ requestLocale }) => {
         let locale = await requestLocale;

         if (!locale || !routing.locales.includes(locale as any)) {
           locale = routing.defaultLocale;
         }

         return {
           locale,
           messages: (await import(`../messages/${locale}.json`)).default
         };
       });
       ```

    3. Create apps/web/middleware.ts:
       ```typescript
       import createMiddleware from 'next-intl/middleware';
       import { routing } from './i18n/routing';

       export default createMiddleware(routing);

       export const config = {
         matcher: ['/', '/(fr|en)/:path*']
       };
       ```

    4. Create apps/web/messages/fr.json:
       ```json
       {
         "common": {
           "loading": "Chargement...",
           "error": "Une erreur s'est produite",
           "save": "Enregistrer",
           "cancel": "Annuler",
           "delete": "Supprimer",
           "edit": "Modifier",
           "add": "Ajouter",
           "search": "Rechercher",
           "logout": "Deconnexion",
           "login": "Connexion"
         },
         "pos": {
           "title": "Point de Vente",
           "cart": {
             "title": "Panier",
             "empty": "Votre panier est vide",
             "total": "Total",
             "subtotal": "Sous-total",
             "clear": "Vider le panier",
             "checkout": "Valider la commande"
           },
           "menu": {
             "title": "Menu",
             "categories": "Categories",
             "items": "Articles",
             "unavailable": "Non disponible"
           },
           "order": {
             "type": "Type de commande",
             "dineIn": "Sur place",
             "takeout": "A emporter",
             "delivery": "Livraison",
             "table": "Table",
             "notes": "Notes",
             "submit": "Envoyer la commande"
           }
         },
         "kitchen": {
           "title": "Cuisine",
           "queue": "File d'attente",
           "pending": "En attente",
           "preparing": "En preparation",
           "ready": "Pret",
           "markPreparing": "Commencer",
           "markReady": "Pret",
           "markComplete": "Termine"
         },
         "offline": {
           "status": "Hors ligne",
           "syncing": "Synchronisation...",
           "pendingOrders": "commandes en attente",
           "lastSync": "Derniere synchronisation"
         }
       }
       ```

    5. Create apps/web/messages/en.json:
       ```json
       {
         "common": {
           "loading": "Loading...",
           "error": "An error occurred",
           "save": "Save",
           "cancel": "Cancel",
           "delete": "Delete",
           "edit": "Edit",
           "add": "Add",
           "search": "Search",
           "logout": "Logout",
           "login": "Login"
         },
         "pos": {
           "title": "Point of Sale",
           "cart": {
             "title": "Cart",
             "empty": "Your cart is empty",
             "total": "Total",
             "subtotal": "Subtotal",
             "clear": "Clear cart",
             "checkout": "Checkout"
           },
           "menu": {
             "title": "Menu",
             "categories": "Categories",
             "items": "Items",
             "unavailable": "Unavailable"
           },
           "order": {
             "type": "Order type",
             "dineIn": "Dine in",
             "takeout": "Takeout",
             "delivery": "Delivery",
             "table": "Table",
             "notes": "Notes",
             "submit": "Submit order"
           }
         },
         "kitchen": {
           "title": "Kitchen",
           "queue": "Order Queue",
           "pending": "Pending",
           "preparing": "Preparing",
           "ready": "Ready",
           "markPreparing": "Start",
           "markReady": "Ready",
           "markComplete": "Complete"
         },
         "offline": {
           "status": "Offline",
           "syncing": "Syncing...",
           "pendingOrders": "pending orders",
           "lastSync": "Last sync"
         }
       }
       ```

    6. Update apps/web/app/layout.tsx (root layout):
       ```typescript
       import type { Metadata } from 'next';
       import './globals.css';

       export const metadata: Metadata = {
         title: 'RESTO360 POS',
         description: 'Restaurant POS System',
         manifest: '/manifest.json',
       };

       export default function RootLayout({
         children,
       }: {
         children: React.ReactNode;
       }) {
         return children;
       }
       ```

    7. Create apps/web/app/[locale]/layout.tsx:
       ```typescript
       import { NextIntlClientProvider } from 'next-intl';
       import { getMessages, setRequestLocale } from 'next-intl/server';
       import { routing } from '@/i18n/routing';

       export function generateStaticParams() {
         return routing.locales.map((locale) => ({ locale }));
       }

       export default async function LocaleLayout({
         children,
         params,
       }: {
         children: React.ReactNode;
         params: Promise<{ locale: string }>;
       }) {
         const { locale } = await params;
         setRequestLocale(locale);
         const messages = await getMessages();

         return (
           <html lang={locale}>
             <body>
               <NextIntlClientProvider messages={messages}>
                 {children}
               </NextIntlClientProvider>
             </body>
           </html>
         );
       }
       ```

    8. Create apps/web/app/[locale]/page.tsx:
       ```typescript
       import { useTranslations } from 'next-intl';
       import { setRequestLocale } from 'next-intl/server';
       import Link from 'next/link';

       export default async function HomePage({
         params,
       }: {
         params: Promise<{ locale: string }>;
       }) {
         const { locale } = await params;
         setRequestLocale(locale);

         return (
           <main className="min-h-screen p-8">
             <h1 className="text-3xl font-bold mb-4">RESTO360</h1>
             <nav className="space-y-2">
               <Link href={`/${locale}/pos`} className="block p-4 bg-blue-500 text-white rounded">
                 POS
               </Link>
               <Link href={`/${locale}/kitchen`} className="block p-4 bg-green-500 text-white rounded">
                 Kitchen
               </Link>
             </nav>
             <div className="mt-8">
               <Link href="/en" className="mr-4">English</Link>
               <Link href="/fr">Francais</Link>
             </div>
           </main>
         );
       }
       ```
  </action>
  <verify>Visit http://localhost:3000/fr and http://localhost:3000/en to see translated content</verify>
  <done>i18n configured, French as default, locale switcher working</done>
</task>

<task type="auto">
  <name>Task 3: Create Dexie IndexedDB schema and API client</name>
  <files>
    apps/web/lib/db/schema.ts
    apps/web/lib/db/sync.ts
    apps/web/lib/api/client.ts
    apps/web/lib/api/types.ts
    apps/web/lib/hooks/useOnlineStatus.ts
  </files>
  <action>
    1. Create apps/web/lib/db/schema.ts:
       ```typescript
       import Dexie, { Table } from 'dexie';

       // Types for IndexedDB storage
       export interface LocalMenuItem {
         id: string;
         categoryId: string;
         name: string;
         description: string;
         price: number;
         thumbnailUrl: string | null;
         isAvailable: boolean;
         modifiers: LocalModifier[];
         syncedAt: Date;
       }

       export interface LocalModifier {
         id: string;
         name: string;
         required: boolean;
         maxSelections: number;
         options: LocalModifierOption[];
       }

       export interface LocalModifierOption {
         id: string;
         name: string;
         priceAdjustment: number;
         isAvailable: boolean;
       }

       export interface LocalCategory {
         id: string;
         name: string;
         displayOrder: number;
         isVisible: boolean;
         syncedAt: Date;
       }

       export interface LocalOrder {
         localId: string;
         serverId: string | null;
         orderNumber: number | null;
         orderType: 'dine_in' | 'takeout' | 'delivery';
         status: 'pending' | 'preparing' | 'ready' | 'completed' | 'cancelled';
         tableId: string | null;
         customerName: string;
         customerPhone: string;
         notes: string;
         items: LocalOrderItem[];
         subtotal: number;
         total: number;
         createdAt: Date;
         syncedAt: Date | null;
       }

       export interface LocalOrderItem {
         menuItemId: string;
         menuItemName: string;
         quantity: number;
         unitPrice: number;
         notes: string;
         modifiers: { optionId: string; optionName: string; priceAdjustment: number }[];
       }

       export interface PendingOperation {
         id?: number;
         type: 'CREATE_ORDER' | 'UPDATE_STATUS';
         payload: any;
         createdAt: Date;
         syncStatus: 'pending' | 'syncing' | 'failed';
         retryCount: number;
         lastError?: string;
       }

       export interface SyncMeta {
         key: string;
         value: string | Date;
       }

       class RestaurantDB extends Dexie {
         categories!: Table<LocalCategory>;
         menuItems!: Table<LocalMenuItem>;
         orders!: Table<LocalOrder>;
         pendingOps!: Table<PendingOperation>;
         syncMeta!: Table<SyncMeta>;

         constructor() {
           super('resto360');

           this.version(1).stores({
             categories: 'id, name, displayOrder',
             menuItems: 'id, categoryId, name, isAvailable',
             orders: 'localId, serverId, status, createdAt',
             pendingOps: '++id, type, syncStatus, createdAt',
             syncMeta: 'key'
           });
         }
       }

       export const db = new RestaurantDB();

       // Helper to check if database is available
       export async function isDatabaseReady(): Promise<boolean> {
         try {
           await db.open();
           return true;
         } catch {
           return false;
         }
       }
       ```

    2. Create apps/web/lib/db/sync.ts:
       ```typescript
       import { db, PendingOperation } from './schema';

       // Add operation to sync queue
       export async function queueOperation(
         type: PendingOperation['type'],
         payload: any
       ): Promise<number> {
         return db.pendingOps.add({
           type,
           payload,
           createdAt: new Date(),
           syncStatus: 'pending',
           retryCount: 0,
         });
       }

       // Get all pending operations
       export async function getPendingOperations(): Promise<PendingOperation[]> {
         return db.pendingOps
           .where('syncStatus')
           .equals('pending')
           .sortBy('createdAt');
       }

       // Mark operation as syncing
       export async function markSyncing(id: number): Promise<void> {
         await db.pendingOps.update(id, { syncStatus: 'syncing' });
       }

       // Mark operation as synced (delete it)
       export async function markSynced(id: number): Promise<void> {
         await db.pendingOps.delete(id);
       }

       // Mark operation as failed
       export async function markFailed(id: number, error: string): Promise<void> {
         const op = await db.pendingOps.get(id);
         if (op) {
           await db.pendingOps.update(id, {
             syncStatus: op.retryCount >= 3 ? 'failed' : 'pending',
             retryCount: op.retryCount + 1,
             lastError: error,
           });
         }
       }

       // Update sync metadata
       export async function updateSyncMeta(key: string, value: string | Date): Promise<void> {
         await db.syncMeta.put({ key, value });
       }

       // Get sync metadata
       export async function getSyncMeta(key: string): Promise<string | Date | undefined> {
         const record = await db.syncMeta.get(key);
         return record?.value;
       }

       // Get pending operation count
       export async function getPendingCount(): Promise<number> {
         return db.pendingOps.where('syncStatus').equals('pending').count();
       }
       ```

    3. Create apps/web/lib/api/types.ts:
       ```typescript
       export interface Category {
         id: string;
         name: string;
         display_order: number;
         is_visible: boolean;
         items: MenuItem[];
       }

       export interface MenuItem {
         id: string;
         category: string;
         name: string;
         description: string;
         price: number;
         thumbnail_url: string | null;
         is_available: boolean;
         modifiers: Modifier[];
       }

       export interface Modifier {
         id: string;
         name: string;
         required: boolean;
         max_selections: number;
         options: ModifierOption[];
       }

       export interface ModifierOption {
         id: string;
         name: string;
         price_adjustment: number;
         is_available: boolean;
       }

       export interface Order {
         id: string;
         order_number: number;
         order_type: 'dine_in' | 'takeout' | 'delivery';
         status: 'pending' | 'preparing' | 'ready' | 'completed' | 'cancelled';
         table: string | null;
         customer_name: string;
         customer_phone: string;
         notes: string;
         subtotal: number;
         total: number;
         items: OrderItem[];
         created_at: string;
       }

       export interface OrderItem {
         id: string;
         menu_item: string;
         menu_item_name: string;
         quantity: number;
         unit_price: number;
         notes: string;
         modifiers: OrderItemModifier[];
       }

       export interface OrderItemModifier {
         modifier_option: string;
         modifier_option_name: string;
         price_adjustment: number;
       }

       export interface CreateOrderPayload {
         order_type: 'dine_in' | 'takeout' | 'delivery';
         table?: string;
         customer_name?: string;
         customer_phone?: string;
         notes?: string;
         items: {
           menu_item_id: string;
           quantity: number;
           notes?: string;
           modifiers: { modifier_option_id: string }[];
         }[];
       }

       export interface AuthTokens {
         access: string;
         refresh: string;
       }
       ```

    4. Create apps/web/lib/api/client.ts:
       ```typescript
       import { AuthTokens } from './types';

       const API_BASE = process.env.NEXT_PUBLIC_API_URL || '';

       // Token storage (in memory for security, persist to sessionStorage)
       let accessToken: string | null = null;
       let refreshToken: string | null = null;

       export function setTokens(tokens: AuthTokens): void {
         accessToken = tokens.access;
         refreshToken = tokens.refresh;
         if (typeof window !== 'undefined') {
           sessionStorage.setItem('accessToken', tokens.access);
           sessionStorage.setItem('refreshToken', tokens.refresh);
         }
       }

       export function getAccessToken(): string | null {
         if (!accessToken && typeof window !== 'undefined') {
           accessToken = sessionStorage.getItem('accessToken');
         }
         return accessToken;
       }

       export function getRefreshToken(): string | null {
         if (!refreshToken && typeof window !== 'undefined') {
           refreshToken = sessionStorage.getItem('refreshToken');
         }
         return refreshToken;
       }

       export function clearTokens(): void {
         accessToken = null;
         refreshToken = null;
         if (typeof window !== 'undefined') {
           sessionStorage.removeItem('accessToken');
           sessionStorage.removeItem('refreshToken');
         }
       }

       async function refreshAccessToken(): Promise<boolean> {
         const refresh = getRefreshToken();
         if (!refresh) return false;

         try {
           const response = await fetch(`${API_BASE}/api/v1/auth/token/refresh/`, {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ refresh }),
           });

           if (response.ok) {
             const data = await response.json();
             setTokens({ access: data.access, refresh: data.refresh || refresh });
             return true;
           }
         } catch {
           // Refresh failed
         }

         clearTokens();
         return false;
       }

       export async function apiRequest<T>(
         path: string,
         options: RequestInit = {}
       ): Promise<T> {
         const token = getAccessToken();
         const headers: HeadersInit = {
           'Content-Type': 'application/json',
           ...options.headers,
         };

         if (token) {
           (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`;
         }

         let response = await fetch(`${API_BASE}${path}`, {
           ...options,
           headers,
         });

         // Handle 401 - try to refresh token
         if (response.status === 401 && token) {
           const refreshed = await refreshAccessToken();
           if (refreshed) {
             (headers as Record<string, string>)['Authorization'] = `Bearer ${getAccessToken()}`;
             response = await fetch(`${API_BASE}${path}`, {
               ...options,
               headers,
             });
           }
         }

         if (!response.ok) {
           const error = await response.json().catch(() => ({ detail: 'Request failed' }));
           throw new Error(error.detail || `HTTP ${response.status}`);
         }

         return response.json();
       }

       // Convenience methods
       export const api = {
         get: <T>(path: string) => apiRequest<T>(path),
         post: <T>(path: string, data: unknown) =>
           apiRequest<T>(path, { method: 'POST', body: JSON.stringify(data) }),
         patch: <T>(path: string, data: unknown) =>
           apiRequest<T>(path, { method: 'PATCH', body: JSON.stringify(data) }),
         delete: <T>(path: string) => apiRequest<T>(path, { method: 'DELETE' }),
       };
       ```

    5. Create apps/web/lib/hooks/useOnlineStatus.ts:
       ```typescript
       'use client';

       import { useState, useEffect } from 'react';

       export function useOnlineStatus(): boolean {
         const [isOnline, setIsOnline] = useState(
           typeof window !== 'undefined' ? navigator.onLine : true
         );

         useEffect(() => {
           const handleOnline = () => setIsOnline(true);
           const handleOffline = () => setIsOnline(false);

           window.addEventListener('online', handleOnline);
           window.addEventListener('offline', handleOffline);

           return () => {
             window.removeEventListener('online', handleOnline);
             window.removeEventListener('offline', handleOffline);
           };
         }, []);

         return isOnline;
       }
       ```
  </action>
  <verify>Import db from lib/db/schema in a component and verify no TypeScript errors</verify>
  <done>Dexie schema defined, API client with auth ready, online status hook created</done>
</task>

<task type="auto">
  <name>Task 4: Create shared components and providers</name>
  <files>
    apps/web/components/providers/QueryProvider.tsx
    apps/web/components/ui/OfflineIndicator.tsx
    apps/web/components/ui/LocaleSwitcher.tsx
    apps/web/components/ui/Button.tsx
    apps/web/app/[locale]/layout.tsx
  </files>
  <action>
    1. Create apps/web/components/providers/QueryProvider.tsx:
       ```typescript
       'use client';

       import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
       import { useState } from 'react';

       export function QueryProvider({ children }: { children: React.ReactNode }) {
         const [queryClient] = useState(
           () =>
             new QueryClient({
               defaultOptions: {
                 queries: {
                   staleTime: 60 * 1000, // 1 minute
                   gcTime: 5 * 60 * 1000, // 5 minutes
                   retry: 1,
                   refetchOnWindowFocus: false,
                 },
               },
             })
         );

         return (
           <QueryClientProvider client={queryClient}>
             {children}
           </QueryClientProvider>
         );
       }
       ```

    2. Create apps/web/components/ui/OfflineIndicator.tsx:
       ```typescript
       'use client';

       import { useTranslations } from 'next-intl';
       import { useOnlineStatus } from '@/lib/hooks/useOnlineStatus';
       import { useLiveQuery } from 'dexie-react-hooks';
       import { db } from '@/lib/db/schema';

       export function OfflineIndicator() {
         const t = useTranslations('offline');
         const isOnline = useOnlineStatus();

         const pendingCount = useLiveQuery(
           () => db.pendingOps.where('syncStatus').equals('pending').count(),
           [],
           0
         );

         if (isOnline && pendingCount === 0) {
           return null;
         }

         return (
           <div className={`fixed bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg ${
             isOnline ? 'bg-yellow-500' : 'bg-red-500'
           } text-white`}>
             {!isOnline && (
               <span className="flex items-center gap-2">
                 <span className="w-2 h-2 bg-white rounded-full animate-pulse" />
                 {t('status')}
               </span>
             )}
             {pendingCount > 0 && (
               <span className="text-sm">
                 {pendingCount} {t('pendingOrders')}
               </span>
             )}
           </div>
         );
       }
       ```

    3. Create apps/web/components/ui/LocaleSwitcher.tsx:
       ```typescript
       'use client';

       import { useLocale } from 'next-intl';
       import { useRouter, usePathname } from 'next/navigation';

       export function LocaleSwitcher() {
         const locale = useLocale();
         const router = useRouter();
         const pathname = usePathname();

         const switchLocale = (newLocale: string) => {
           const newPath = pathname.replace(`/${locale}`, `/${newLocale}`);
           router.push(newPath);
         };

         return (
           <div className="flex gap-2">
             <button
               onClick={() => switchLocale('fr')}
               className={`px-2 py-1 rounded ${
                 locale === 'fr' ? 'bg-blue-500 text-white' : 'bg-gray-200'
               }`}
             >
               FR
             </button>
             <button
               onClick={() => switchLocale('en')}
               className={`px-2 py-1 rounded ${
                 locale === 'en' ? 'bg-blue-500 text-white' : 'bg-gray-200'
               }`}
             >
               EN
             </button>
           </div>
         );
       }
       ```

    4. Create apps/web/components/ui/Button.tsx:
       ```typescript
       import { ButtonHTMLAttributes, forwardRef } from 'react';

       interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
         variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
         size?: 'sm' | 'md' | 'lg';
       }

       export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
         ({ variant = 'primary', size = 'md', className = '', children, ...props }, ref) => {
           const baseStyles = 'font-medium rounded-lg transition-colors disabled:opacity-50';

           const variants = {
             primary: 'bg-blue-600 text-white hover:bg-blue-700',
             secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',
             danger: 'bg-red-600 text-white hover:bg-red-700',
             ghost: 'bg-transparent hover:bg-gray-100',
           };

           const sizes = {
             sm: 'px-3 py-1.5 text-sm',
             md: 'px-4 py-2 text-base',
             lg: 'px-6 py-3 text-lg',
           };

           return (
             <button
               ref={ref}
               className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`}
               {...props}
             >
               {children}
             </button>
           );
         }
       );

       Button.displayName = 'Button';
       ```

    5. Update apps/web/app/[locale]/layout.tsx to include providers:
       ```typescript
       import { NextIntlClientProvider } from 'next-intl';
       import { getMessages, setRequestLocale } from 'next-intl/server';
       import { routing } from '@/i18n/routing';
       import { QueryProvider } from '@/components/providers/QueryProvider';
       import { OfflineIndicator } from '@/components/ui/OfflineIndicator';
       import '../globals.css';

       export function generateStaticParams() {
         return routing.locales.map((locale) => ({ locale }));
       }

       export default async function LocaleLayout({
         children,
         params,
       }: {
         children: React.ReactNode;
         params: Promise<{ locale: string }>;
       }) {
         const { locale } = await params;
         setRequestLocale(locale);
         const messages = await getMessages();

         return (
           <html lang={locale}>
             <body className="min-h-screen bg-gray-50">
               <NextIntlClientProvider messages={messages}>
                 <QueryProvider>
                   {children}
                   <OfflineIndicator />
                 </QueryProvider>
               </NextIntlClientProvider>
             </body>
           </html>
         );
       }
       ```
  </action>
  <verify>npm run build (Next.js builds without errors)</verify>
  <done>Shared components created, providers configured, layout updated</done>
</task>

</tasks>

<verification>
1. npm run dev starts without errors: http://localhost:3000
2. npm run build completes successfully
3. Visiting /fr shows French content, /en shows English content
4. LocaleSwitcher changes language
5. OfflineIndicator shows when network is disconnected
6. No TypeScript errors in lib/db or lib/api
</verification>

<success_criteria>
- Next.js 14+ app running with App Router
- PWA manifest and service worker configured
- next-intl i18n with French (default) and English
- Dexie IndexedDB schema defined for offline storage
- API client with JWT token handling
- TanStack Query provider configured
- OfflineIndicator component shows connectivity status
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-pos-core/02-04-SUMMARY.md`
</output>
