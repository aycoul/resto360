---
phase: 02-pos-core
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-04"]
files_modified:
  - apps/web/app/[locale]/pos/page.tsx
  - apps/web/app/[locale]/pos/layout.tsx
  - apps/web/components/pos/MenuGrid.tsx
  - apps/web/components/pos/CategoryTabs.tsx
  - apps/web/components/pos/MenuItemCard.tsx
  - apps/web/components/pos/Cart.tsx
  - apps/web/components/pos/CartItem.tsx
  - apps/web/components/pos/ModifierModal.tsx
  - apps/web/components/pos/OrderTypeSelector.tsx
  - apps/web/components/pos/CheckoutModal.tsx
  - apps/web/lib/hooks/useMenu.ts
  - apps/web/lib/hooks/useCart.ts
  - apps/web/lib/hooks/useOrders.ts
  - apps/web/lib/db/operations.ts
autonomous: true

must_haves:
  truths:
    - "Cashier can see menu categories and items"
    - "Cashier can add items to cart with modifiers"
    - "Cashier can adjust quantity and remove items"
    - "Cashier can select order type (dine-in/takeout/delivery)"
    - "Cashier can submit order and see confirmation"
    - "Orders are created locally first, then synced"
    - "POS works without internet connection"
  artifacts:
    - path: "apps/web/app/[locale]/pos/page.tsx"
      provides: "POS main page"
      contains: "MenuGrid"
    - path: "apps/web/components/pos/Cart.tsx"
      provides: "Cart component with items and totals"
      contains: "CartItem"
    - path: "apps/web/lib/hooks/useCart.ts"
      provides: "Cart state management"
      contains: "useCart"
    - path: "apps/web/lib/db/operations.ts"
      provides: "Offline order creation"
      contains: "createOfflineOrder"
  key_links:
    - from: "apps/web/components/pos/MenuItemCard.tsx"
      to: "apps/web/lib/hooks/useCart.ts"
      via: "addToCart function"
      pattern: "addToCart"
    - from: "apps/web/components/pos/CheckoutModal.tsx"
      to: "apps/web/lib/db/operations.ts"
      via: "createOfflineOrder"
      pattern: "createOfflineOrder"
---

<objective>
Build the POS cashier interface with menu display, cart management, and offline-first order creation.

Purpose: Enable cashiers to take orders efficiently on tablets. The interface must work offline, storing orders in IndexedDB and syncing when connection is restored.

Output: Fully functional POS page at /pos with menu grid, cart, modifier selection, and order submission.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-pos-core/02-RESEARCH.md

# Depends on backend and frontend foundation
@.planning/phases/02-pos-core/02-02-SUMMARY.md
@.planning/phases/02-pos-core/02-04-SUMMARY.md

# Frontend foundation
@apps/web/lib/db/schema.ts
@apps/web/lib/api/client.ts
@apps/web/messages/fr.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create menu data hooks with offline support</name>
  <files>
    apps/web/lib/hooks/useMenu.ts
    apps/web/lib/db/operations.ts
  </files>
  <action>
    1. Create apps/web/lib/hooks/useMenu.ts:
       ```typescript
       'use client';

       import { useQuery } from '@tanstack/react-query';
       import { useLiveQuery } from 'dexie-react-hooks';
       import { api } from '@/lib/api/client';
       import { db, LocalCategory, LocalMenuItem } from '@/lib/db/schema';
       import { Category } from '@/lib/api/types';
       import { useOnlineStatus } from './useOnlineStatus';

       // Sync menu from API to IndexedDB
       async function syncMenuToLocal(categories: Category[]): Promise<void> {
         const now = new Date();

         await db.transaction('rw', db.categories, db.menuItems, async () => {
           // Clear existing data
           await db.categories.clear();
           await db.menuItems.clear();

           // Store categories
           for (const category of categories) {
             await db.categories.add({
               id: category.id,
               name: category.name,
               displayOrder: category.display_order,
               isVisible: category.is_visible,
               syncedAt: now,
             });

             // Store menu items
             for (const item of category.items) {
               await db.menuItems.add({
                 id: item.id,
                 categoryId: category.id,
                 name: item.name,
                 description: item.description,
                 price: item.price,
                 thumbnailUrl: item.thumbnail_url,
                 isAvailable: item.is_available,
                 modifiers: item.modifiers.map(m => ({
                   id: m.id,
                   name: m.name,
                   required: m.required,
                   maxSelections: m.max_selections,
                   options: m.options.map(o => ({
                     id: o.id,
                     name: o.name,
                     priceAdjustment: o.price_adjustment,
                     isAvailable: o.is_available,
                   })),
                 })),
                 syncedAt: now,
               });
             }
           }
         });
       }

       export function useMenu() {
         const isOnline = useOnlineStatus();

         // Fetch from API when online
         const apiQuery = useQuery({
           queryKey: ['menu'],
           queryFn: async () => {
             const data = await api.get<{ categories: Category[] }>('/api/v1/menu/full/');
             await syncMenuToLocal(data.categories);
             return data.categories;
           },
           enabled: isOnline,
           staleTime: 5 * 60 * 1000, // 5 minutes
         });

         // Read from IndexedDB (reactive)
         const localCategories = useLiveQuery(
           () => db.categories.orderBy('displayOrder').toArray(),
           [],
           []
         );

         const localItems = useLiveQuery(
           () => db.menuItems.toArray(),
           [],
           []
         );

         // Organize items by category
         const categoriesWithItems = localCategories.map(cat => ({
           ...cat,
           items: localItems.filter(item => item.categoryId === cat.id),
         }));

         return {
           categories: categoriesWithItems,
           isLoading: apiQuery.isLoading && localCategories.length === 0,
           error: apiQuery.error,
           refetch: apiQuery.refetch,
           isOnline,
         };
       }

       // Get single menu item by ID
       export function useMenuItem(itemId: string) {
         return useLiveQuery(
           () => db.menuItems.get(itemId),
           [itemId]
         );
       }
       ```

    2. Create apps/web/lib/db/operations.ts:
       ```typescript
       import { db, LocalOrder, LocalOrderItem, PendingOperation } from './schema';
       import { queueOperation } from './sync';
       import { api } from '@/lib/api/client';
       import { CreateOrderPayload, Order } from '@/lib/api/types';

       // Create order offline-first
       export async function createOfflineOrder(
         orderData: Omit<LocalOrder, 'localId' | 'serverId' | 'orderNumber' | 'status' | 'createdAt' | 'syncedAt'>
       ): Promise<string> {
         const localId = crypto.randomUUID();
         const now = new Date();

         // 1. Store order locally
         await db.orders.add({
           localId,
           serverId: null,
           orderNumber: null,
           status: 'pending',
           createdAt: now,
           syncedAt: null,
           ...orderData,
         });

         // 2. Queue sync operation
         const apiPayload: CreateOrderPayload = {
           order_type: orderData.orderType,
           table: orderData.tableId || undefined,
           customer_name: orderData.customerName || undefined,
           customer_phone: orderData.customerPhone || undefined,
           notes: orderData.notes || undefined,
           items: orderData.items.map(item => ({
             menu_item_id: item.menuItemId,
             quantity: item.quantity,
             notes: item.notes || undefined,
             modifiers: item.modifiers.map(m => ({ modifier_option_id: m.optionId })),
           })),
         };

         await queueOperation('CREATE_ORDER', {
           localId,
           payload: apiPayload,
         });

         // 3. Trigger sync if online
         if (typeof navigator !== 'undefined' && navigator.onLine) {
           syncPendingOrders();
         }

         return localId;
       }

       // Sync pending orders to server
       export async function syncPendingOrders(): Promise<void> {
         const pendingOps = await db.pendingOps
           .where('syncStatus')
           .equals('pending')
           .sortBy('createdAt');

         for (const op of pendingOps) {
           if (op.type === 'CREATE_ORDER') {
             await syncCreateOrder(op);
           }
         }
       }

       async function syncCreateOrder(op: PendingOperation): Promise<void> {
         if (!op.id) return;

         try {
           // Mark as syncing
           await db.pendingOps.update(op.id, { syncStatus: 'syncing' });

           // Send to API
           const result = await api.post<Order>('/api/v1/orders/', op.payload.payload);

           // Update local order with server data
           await db.orders.update(op.payload.localId, {
             serverId: result.id,
             orderNumber: result.order_number,
             status: result.status,
             syncedAt: new Date(),
           });

           // Remove operation from queue
           await db.pendingOps.delete(op.id);
         } catch (error) {
           // Mark as failed and increment retry count
           const retryCount = (op.retryCount || 0) + 1;
           await db.pendingOps.update(op.id, {
             syncStatus: retryCount >= 3 ? 'failed' : 'pending',
             retryCount,
             lastError: error instanceof Error ? error.message : 'Unknown error',
           });
         }
       }

       // Get local orders
       export async function getLocalOrders(): Promise<LocalOrder[]> {
         return db.orders.orderBy('createdAt').reverse().toArray();
       }

       // Update local order status
       export async function updateLocalOrderStatus(
         localId: string,
         status: LocalOrder['status']
       ): Promise<void> {
         await db.orders.update(localId, { status });
       }
       ```
  </action>
  <verify>Import useMenu in a test component, verify no TypeScript errors</verify>
  <done>Menu hook with offline sync, order operations with queue ready</done>
</task>

<task type="auto">
  <name>Task 2: Create cart state management</name>
  <files>
    apps/web/lib/hooks/useCart.ts
    apps/web/lib/store/cartStore.ts
  </files>
  <action>
    1. Create apps/web/lib/store/cartStore.ts (using React context, not external store):
       ```typescript
       'use client';

       import { createContext, useContext, useReducer, ReactNode } from 'react';
       import { LocalOrderItem, LocalMenuItem, LocalModifierOption } from '@/lib/db/schema';

       export interface CartItem extends LocalOrderItem {
         id: string; // temporary ID for cart
       }

       interface CartState {
         items: CartItem[];
         orderType: 'dine_in' | 'takeout' | 'delivery';
         tableId: string | null;
         customerName: string;
         customerPhone: string;
         notes: string;
       }

       type CartAction =
         | { type: 'ADD_ITEM'; payload: CartItem }
         | { type: 'REMOVE_ITEM'; payload: string }
         | { type: 'UPDATE_QUANTITY'; payload: { id: string; quantity: number } }
         | { type: 'UPDATE_ITEM_NOTES'; payload: { id: string; notes: string } }
         | { type: 'SET_ORDER_TYPE'; payload: 'dine_in' | 'takeout' | 'delivery' }
         | { type: 'SET_TABLE'; payload: string | null }
         | { type: 'SET_CUSTOMER_NAME'; payload: string }
         | { type: 'SET_CUSTOMER_PHONE'; payload: string }
         | { type: 'SET_NOTES'; payload: string }
         | { type: 'CLEAR_CART' };

       const initialState: CartState = {
         items: [],
         orderType: 'dine_in',
         tableId: null,
         customerName: '',
         customerPhone: '',
         notes: '',
       };

       function cartReducer(state: CartState, action: CartAction): CartState {
         switch (action.type) {
           case 'ADD_ITEM':
             return { ...state, items: [...state.items, action.payload] };

           case 'REMOVE_ITEM':
             return { ...state, items: state.items.filter(i => i.id !== action.payload) };

           case 'UPDATE_QUANTITY':
             return {
               ...state,
               items: state.items.map(i =>
                 i.id === action.payload.id
                   ? { ...i, quantity: action.payload.quantity }
                   : i
               ),
             };

           case 'UPDATE_ITEM_NOTES':
             return {
               ...state,
               items: state.items.map(i =>
                 i.id === action.payload.id
                   ? { ...i, notes: action.payload.notes }
                   : i
               ),
             };

           case 'SET_ORDER_TYPE':
             return {
               ...state,
               orderType: action.payload,
               tableId: action.payload !== 'dine_in' ? null : state.tableId,
             };

           case 'SET_TABLE':
             return { ...state, tableId: action.payload };

           case 'SET_CUSTOMER_NAME':
             return { ...state, customerName: action.payload };

           case 'SET_CUSTOMER_PHONE':
             return { ...state, customerPhone: action.payload };

           case 'SET_NOTES':
             return { ...state, notes: action.payload };

           case 'CLEAR_CART':
             return initialState;

           default:
             return state;
         }
       }

       const CartContext = createContext<{
         state: CartState;
         dispatch: React.Dispatch<CartAction>;
       } | null>(null);

       export function CartProvider({ children }: { children: ReactNode }) {
         const [state, dispatch] = useReducer(cartReducer, initialState);
         return (
           <CartContext.Provider value={{ state, dispatch }}>
             {children}
           </CartContext.Provider>
         );
       }

       export function useCartContext() {
         const context = useContext(CartContext);
         if (!context) {
           throw new Error('useCartContext must be used within CartProvider');
         }
         return context;
       }
       ```

    2. Create apps/web/lib/hooks/useCart.ts:
       ```typescript
       'use client';

       import { useCartContext, CartItem } from '@/lib/store/cartStore';
       import { LocalMenuItem } from '@/lib/db/schema';

       export function useCart() {
         const { state, dispatch } = useCartContext();

         const addItem = (
           menuItem: LocalMenuItem,
           quantity: number = 1,
           selectedModifiers: { optionId: string; optionName: string; priceAdjustment: number }[] = [],
           notes: string = ''
         ) => {
           const modifierTotal = selectedModifiers.reduce(
             (sum, m) => sum + m.priceAdjustment,
             0
           );

           const cartItem: CartItem = {
             id: crypto.randomUUID(),
             menuItemId: menuItem.id,
             menuItemName: menuItem.name,
             quantity,
             unitPrice: menuItem.price + modifierTotal,
             notes,
             modifiers: selectedModifiers,
           };

           dispatch({ type: 'ADD_ITEM', payload: cartItem });
         };

         const removeItem = (id: string) => {
           dispatch({ type: 'REMOVE_ITEM', payload: id });
         };

         const updateQuantity = (id: string, quantity: number) => {
           if (quantity <= 0) {
             removeItem(id);
           } else {
             dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
           }
         };

         const updateItemNotes = (id: string, notes: string) => {
           dispatch({ type: 'UPDATE_ITEM_NOTES', payload: { id, notes } });
         };

         const setOrderType = (orderType: 'dine_in' | 'takeout' | 'delivery') => {
           dispatch({ type: 'SET_ORDER_TYPE', payload: orderType });
         };

         const setTable = (tableId: string | null) => {
           dispatch({ type: 'SET_TABLE', payload: tableId });
         };

         const setCustomerName = (name: string) => {
           dispatch({ type: 'SET_CUSTOMER_NAME', payload: name });
         };

         const setCustomerPhone = (phone: string) => {
           dispatch({ type: 'SET_CUSTOMER_PHONE', payload: phone });
         };

         const setNotes = (notes: string) => {
           dispatch({ type: 'SET_NOTES', payload: notes });
         };

         const clearCart = () => {
           dispatch({ type: 'CLEAR_CART' });
         };

         const subtotal = state.items.reduce(
           (sum, item) => sum + item.unitPrice * item.quantity,
           0
         );

         const total = subtotal; // Add tax/fees here if needed

         const itemCount = state.items.reduce((sum, item) => sum + item.quantity, 0);

         return {
           items: state.items,
           orderType: state.orderType,
           tableId: state.tableId,
           customerName: state.customerName,
           customerPhone: state.customerPhone,
           notes: state.notes,
           subtotal,
           total,
           itemCount,
           addItem,
           removeItem,
           updateQuantity,
           updateItemNotes,
           setOrderType,
           setTable,
           setCustomerName,
           setCustomerPhone,
           setNotes,
           clearCart,
         };
       }
       ```
  </action>
  <verify>Import useCart, verify type-checking passes</verify>
  <done>Cart state management with context provider ready</done>
</task>

<task type="auto">
  <name>Task 3: Build POS page and components</name>
  <files>
    apps/web/app/[locale]/pos/layout.tsx
    apps/web/app/[locale]/pos/page.tsx
    apps/web/components/pos/CategoryTabs.tsx
    apps/web/components/pos/MenuGrid.tsx
    apps/web/components/pos/MenuItemCard.tsx
    apps/web/components/pos/Cart.tsx
    apps/web/components/pos/CartItem.tsx
  </files>
  <action>
    1. Create apps/web/app/[locale]/pos/layout.tsx:
       ```typescript
       import { CartProvider } from '@/lib/store/cartStore';

       export default function POSLayout({ children }: { children: React.ReactNode }) {
         return <CartProvider>{children}</CartProvider>;
       }
       ```

    2. Create apps/web/app/[locale]/pos/page.tsx:
       ```typescript
       'use client';

       import { useState } from 'react';
       import { useTranslations } from 'next-intl';
       import { useMenu } from '@/lib/hooks/useMenu';
       import { CategoryTabs } from '@/components/pos/CategoryTabs';
       import { MenuGrid } from '@/components/pos/MenuGrid';
       import { Cart } from '@/components/pos/Cart';
       import { LocaleSwitcher } from '@/components/ui/LocaleSwitcher';

       export default function POSPage() {
         const t = useTranslations('pos');
         const { categories, isLoading, isOnline } = useMenu();
         const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(null);

         // Default to first category
         const activeCategory = selectedCategoryId
           ? categories.find(c => c.id === selectedCategoryId)
           : categories[0];

         if (isLoading) {
           return (
             <div className="flex items-center justify-center min-h-screen">
               <p className="text-gray-500">{t('menu.title')}...</p>
             </div>
           );
         }

         return (
           <div className="flex h-screen bg-gray-100">
             {/* Left: Menu Section */}
             <div className="flex-1 flex flex-col overflow-hidden">
               {/* Header */}
               <header className="bg-white shadow-sm px-4 py-3 flex items-center justify-between">
                 <h1 className="text-xl font-bold">{t('title')}</h1>
                 <div className="flex items-center gap-4">
                   {!isOnline && (
                     <span className="text-red-500 text-sm">Offline</span>
                   )}
                   <LocaleSwitcher />
                 </div>
               </header>

               {/* Category Tabs */}
               <CategoryTabs
                 categories={categories}
                 selectedId={activeCategory?.id || null}
                 onSelect={setSelectedCategoryId}
               />

               {/* Menu Grid */}
               <div className="flex-1 overflow-y-auto p-4">
                 {activeCategory && (
                   <MenuGrid items={activeCategory.items} />
                 )}
               </div>
             </div>

             {/* Right: Cart Section */}
             <div className="w-96 bg-white shadow-lg flex flex-col">
               <Cart />
             </div>
           </div>
         );
       }
       ```

    3. Create apps/web/components/pos/CategoryTabs.tsx:
       ```typescript
       'use client';

       import { LocalCategory } from '@/lib/db/schema';

       interface CategoryTabsProps {
         categories: (LocalCategory & { items: any[] })[];
         selectedId: string | null;
         onSelect: (id: string) => void;
       }

       export function CategoryTabs({ categories, selectedId, onSelect }: CategoryTabsProps) {
         return (
           <div className="flex gap-2 px-4 py-2 bg-white border-b overflow-x-auto">
             {categories.map(category => (
               <button
                 key={category.id}
                 onClick={() => onSelect(category.id)}
                 className={`px-4 py-2 rounded-lg whitespace-nowrap transition-colors ${
                   selectedId === category.id
                     ? 'bg-blue-600 text-white'
                     : 'bg-gray-100 hover:bg-gray-200'
                 }`}
               >
                 {category.name}
                 <span className="ml-2 text-sm opacity-75">
                   ({category.items.length})
                 </span>
               </button>
             ))}
           </div>
         );
       }
       ```

    4. Create apps/web/components/pos/MenuGrid.tsx:
       ```typescript
       'use client';

       import { LocalMenuItem } from '@/lib/db/schema';
       import { MenuItemCard } from './MenuItemCard';

       interface MenuGridProps {
         items: LocalMenuItem[];
       }

       export function MenuGrid({ items }: MenuGridProps) {
         const availableItems = items.filter(item => item.isAvailable);
         const unavailableItems = items.filter(item => !item.isAvailable);

         return (
           <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
             {availableItems.map(item => (
               <MenuItemCard key={item.id} item={item} />
             ))}
             {unavailableItems.map(item => (
               <MenuItemCard key={item.id} item={item} disabled />
             ))}
           </div>
         );
       }
       ```

    5. Create apps/web/components/pos/MenuItemCard.tsx:
       ```typescript
       'use client';

       import { useState } from 'react';
       import { useTranslations } from 'next-intl';
       import { LocalMenuItem } from '@/lib/db/schema';
       import { useCart } from '@/lib/hooks/useCart';
       import { ModifierModal } from './ModifierModal';

       interface MenuItemCardProps {
         item: LocalMenuItem;
         disabled?: boolean;
       }

       export function MenuItemCard({ item, disabled }: MenuItemCardProps) {
         const t = useTranslations('pos.menu');
         const { addItem } = useCart();
         const [showModifiers, setShowModifiers] = useState(false);

         const handleClick = () => {
           if (disabled) return;

           // If item has modifiers, show modal
           if (item.modifiers.length > 0) {
             setShowModifiers(true);
           } else {
             // Add directly to cart
             addItem(item);
           }
         };

         const handleAddWithModifiers = (
           selectedModifiers: { optionId: string; optionName: string; priceAdjustment: number }[]
         ) => {
           addItem(item, 1, selectedModifiers);
           setShowModifiers(false);
         };

         return (
           <>
             <button
               onClick={handleClick}
               disabled={disabled}
               className={`bg-white rounded-lg shadow p-4 text-left transition-transform hover:scale-105 ${
                 disabled ? 'opacity-50 cursor-not-allowed' : ''
               }`}
             >
               {item.thumbnailUrl && (
                 <img
                   src={item.thumbnailUrl}
                   alt={item.name}
                   className="w-full h-24 object-cover rounded mb-2"
                 />
               )}
               <h3 className="font-medium text-gray-900">{item.name}</h3>
               {item.description && (
                 <p className="text-sm text-gray-500 line-clamp-2">{item.description}</p>
               )}
               <p className="mt-2 font-bold text-blue-600">
                 {item.price.toLocaleString()} XOF
               </p>
               {disabled && (
                 <span className="text-xs text-red-500">{t('unavailable')}</span>
               )}
             </button>

             {showModifiers && (
               <ModifierModal
                 item={item}
                 onClose={() => setShowModifiers(false)}
                 onAdd={handleAddWithModifiers}
               />
             )}
           </>
         );
       }
       ```

    6. Create apps/web/components/pos/Cart.tsx:
       ```typescript
       'use client';

       import { useState } from 'react';
       import { useTranslations } from 'next-intl';
       import { useCart } from '@/lib/hooks/useCart';
       import { CartItem } from './CartItem';
       import { CheckoutModal } from './CheckoutModal';
       import { Button } from '@/components/ui/Button';

       export function Cart() {
         const t = useTranslations('pos.cart');
         const { items, subtotal, total, itemCount, clearCart } = useCart();
         const [showCheckout, setShowCheckout] = useState(false);

         return (
           <>
             <div className="flex flex-col h-full">
               {/* Header */}
               <div className="p-4 border-b">
                 <div className="flex items-center justify-between">
                   <h2 className="text-lg font-bold">{t('title')}</h2>
                   {items.length > 0 && (
                     <button
                       onClick={clearCart}
                       className="text-sm text-red-500 hover:text-red-700"
                     >
                       {t('clear')}
                     </button>
                   )}
                 </div>
               </div>

               {/* Items */}
               <div className="flex-1 overflow-y-auto p-4">
                 {items.length === 0 ? (
                   <p className="text-gray-400 text-center py-8">{t('empty')}</p>
                 ) : (
                   <div className="space-y-3">
                     {items.map(item => (
                       <CartItem key={item.id} item={item} />
                     ))}
                   </div>
                 )}
               </div>

               {/* Footer */}
               <div className="p-4 border-t bg-gray-50">
                 <div className="flex justify-between mb-2">
                   <span className="text-gray-600">{t('subtotal')}</span>
                   <span>{subtotal.toLocaleString()} XOF</span>
                 </div>
                 <div className="flex justify-between mb-4 text-lg font-bold">
                   <span>{t('total')}</span>
                   <span>{total.toLocaleString()} XOF</span>
                 </div>
                 <Button
                   onClick={() => setShowCheckout(true)}
                   disabled={items.length === 0}
                   className="w-full"
                   size="lg"
                 >
                   {t('checkout')} ({itemCount})
                 </Button>
               </div>
             </div>

             {showCheckout && (
               <CheckoutModal onClose={() => setShowCheckout(false)} />
             )}
           </>
         );
       }
       ```

    7. Create apps/web/components/pos/CartItem.tsx:
       ```typescript
       'use client';

       import { useCart } from '@/lib/hooks/useCart';
       import { CartItem as CartItemType } from '@/lib/store/cartStore';

       interface CartItemProps {
         item: CartItemType;
       }

       export function CartItem({ item }: CartItemProps) {
         const { updateQuantity, removeItem } = useCart();

         return (
           <div className="bg-gray-50 rounded-lg p-3">
             <div className="flex justify-between items-start mb-2">
               <div>
                 <h4 className="font-medium">{item.menuItemName}</h4>
                 {item.modifiers.length > 0 && (
                   <p className="text-sm text-gray-500">
                     {item.modifiers.map(m => m.optionName).join(', ')}
                   </p>
                 )}
                 {item.notes && (
                   <p className="text-xs text-gray-400 italic">{item.notes}</p>
                 )}
               </div>
               <button
                 onClick={() => removeItem(item.id)}
                 className="text-red-500 hover:text-red-700"
               >
                 &times;
               </button>
             </div>
             <div className="flex items-center justify-between">
               <div className="flex items-center gap-2">
                 <button
                   onClick={() => updateQuantity(item.id, item.quantity - 1)}
                   className="w-8 h-8 rounded bg-gray-200 hover:bg-gray-300"
                 >
                   -
                 </button>
                 <span className="w-8 text-center">{item.quantity}</span>
                 <button
                   onClick={() => updateQuantity(item.id, item.quantity + 1)}
                   className="w-8 h-8 rounded bg-gray-200 hover:bg-gray-300"
                 >
                   +
                 </button>
               </div>
               <span className="font-medium">
                 {(item.unitPrice * item.quantity).toLocaleString()} XOF
               </span>
             </div>
           </div>
         );
       }
       ```
  </action>
  <verify>Visit http://localhost:3000/fr/pos, verify menu grid and cart render</verify>
  <done>POS page with menu grid and cart components working</done>
</task>

<task type="auto">
  <name>Task 4: Build modifier modal and checkout flow</name>
  <files>
    apps/web/components/pos/ModifierModal.tsx
    apps/web/components/pos/OrderTypeSelector.tsx
    apps/web/components/pos/CheckoutModal.tsx
    apps/web/lib/hooks/useOrders.ts
  </files>
  <action>
    1. Create apps/web/components/pos/ModifierModal.tsx:
       ```typescript
       'use client';

       import { useState } from 'react';
       import { useTranslations } from 'next-intl';
       import { LocalMenuItem } from '@/lib/db/schema';
       import { Button } from '@/components/ui/Button';

       interface ModifierModalProps {
         item: LocalMenuItem;
         onClose: () => void;
         onAdd: (modifiers: { optionId: string; optionName: string; priceAdjustment: number }[]) => void;
       }

       export function ModifierModal({ item, onClose, onAdd }: ModifierModalProps) {
         const t = useTranslations('common');
         const [selectedOptions, setSelectedOptions] = useState<Record<string, string[]>>({});

         const toggleOption = (modifierId: string, optionId: string, maxSelections: number) => {
           setSelectedOptions(prev => {
             const current = prev[modifierId] || [];
             if (current.includes(optionId)) {
               return { ...prev, [modifierId]: current.filter(id => id !== optionId) };
             }
             if (maxSelections === 1) {
               return { ...prev, [modifierId]: [optionId] };
             }
             if (maxSelections === 0 || current.length < maxSelections) {
               return { ...prev, [modifierId]: [...current, optionId] };
             }
             return prev;
           });
         };

         const handleAdd = () => {
           // Check required modifiers
           const missingRequired = item.modifiers.filter(
             m => m.required && (!selectedOptions[m.id] || selectedOptions[m.id].length === 0)
           );
           if (missingRequired.length > 0) {
             alert(`Please select: ${missingRequired.map(m => m.name).join(', ')}`);
             return;
           }

           // Collect selected modifiers
           const modifiers: { optionId: string; optionName: string; priceAdjustment: number }[] = [];
           for (const modifier of item.modifiers) {
             const selected = selectedOptions[modifier.id] || [];
             for (const optionId of selected) {
               const option = modifier.options.find(o => o.id === optionId);
               if (option) {
                 modifiers.push({
                   optionId: option.id,
                   optionName: option.name,
                   priceAdjustment: option.priceAdjustment,
                 });
               }
             }
           }

           onAdd(modifiers);
         };

         const totalAdjustment = Object.entries(selectedOptions).reduce((sum, [modifierId, optionIds]) => {
           const modifier = item.modifiers.find(m => m.id === modifierId);
           if (!modifier) return sum;
           return sum + optionIds.reduce((optSum, optId) => {
             const option = modifier.options.find(o => o.id === optId);
             return optSum + (option?.priceAdjustment || 0);
           }, 0);
         }, 0);

         return (
           <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
             <div className="bg-white rounded-lg w-full max-w-md max-h-[80vh] overflow-hidden">
               <div className="p-4 border-b">
                 <h2 className="text-lg font-bold">{item.name}</h2>
                 <p className="text-sm text-gray-500">
                   Base: {item.price.toLocaleString()} XOF
                 </p>
               </div>

               <div className="p-4 overflow-y-auto max-h-[50vh]">
                 {item.modifiers.map(modifier => (
                   <div key={modifier.id} className="mb-4">
                     <h3 className="font-medium mb-2">
                       {modifier.name}
                       {modifier.required && <span className="text-red-500 ml-1">*</span>}
                       {modifier.maxSelections > 1 && (
                         <span className="text-sm text-gray-500 ml-2">
                           (max {modifier.maxSelections})
                         </span>
                       )}
                     </h3>
                     <div className="space-y-2">
                       {modifier.options.filter(o => o.isAvailable).map(option => {
                         const isSelected = (selectedOptions[modifier.id] || []).includes(option.id);
                         return (
                           <button
                             key={option.id}
                             onClick={() => toggleOption(modifier.id, option.id, modifier.maxSelections)}
                             className={`w-full p-2 rounded border text-left flex justify-between ${
                               isSelected
                                 ? 'border-blue-500 bg-blue-50'
                                 : 'border-gray-200 hover:border-gray-300'
                             }`}
                           >
                             <span>{option.name}</span>
                             {option.priceAdjustment !== 0 && (
                               <span className={option.priceAdjustment > 0 ? 'text-blue-600' : 'text-green-600'}>
                                 {option.priceAdjustment > 0 ? '+' : ''}
                                 {option.priceAdjustment.toLocaleString()} XOF
                               </span>
                             )}
                           </button>
                         );
                       })}
                     </div>
                   </div>
                 ))}
               </div>

               <div className="p-4 border-t flex justify-between items-center">
                 <div>
                   <span className="font-bold">
                     Total: {(item.price + totalAdjustment).toLocaleString()} XOF
                   </span>
                 </div>
                 <div className="flex gap-2">
                   <Button variant="secondary" onClick={onClose}>
                     {t('cancel')}
                   </Button>
                   <Button onClick={handleAdd}>
                     {t('add')}
                   </Button>
                 </div>
               </div>
             </div>
           </div>
         );
       }
       ```

    2. Create apps/web/components/pos/OrderTypeSelector.tsx:
       ```typescript
       'use client';

       import { useTranslations } from 'next-intl';
       import { useCart } from '@/lib/hooks/useCart';

       export function OrderTypeSelector() {
         const t = useTranslations('pos.order');
         const { orderType, setOrderType } = useCart();

         const types = [
           { value: 'dine_in', label: t('dineIn') },
           { value: 'takeout', label: t('takeout') },
           { value: 'delivery', label: t('delivery') },
         ] as const;

         return (
           <div>
             <label className="block text-sm font-medium text-gray-700 mb-2">
               {t('type')}
             </label>
             <div className="flex gap-2">
               {types.map(type => (
                 <button
                   key={type.value}
                   onClick={() => setOrderType(type.value)}
                   className={`flex-1 py-2 rounded-lg transition-colors ${
                     orderType === type.value
                       ? 'bg-blue-600 text-white'
                       : 'bg-gray-100 hover:bg-gray-200'
                   }`}
                 >
                   {type.label}
                 </button>
               ))}
             </div>
           </div>
         );
       }
       ```

    3. Create apps/web/components/pos/CheckoutModal.tsx:
       ```typescript
       'use client';

       import { useState } from 'react';
       import { useTranslations } from 'next-intl';
       import { useCart } from '@/lib/hooks/useCart';
       import { createOfflineOrder } from '@/lib/db/operations';
       import { OrderTypeSelector } from './OrderTypeSelector';
       import { Button } from '@/components/ui/Button';

       interface CheckoutModalProps {
         onClose: () => void;
       }

       export function CheckoutModal({ onClose }: CheckoutModalProps) {
         const t = useTranslations('pos.order');
         const tCommon = useTranslations('common');
         const {
           items,
           orderType,
           tableId,
           customerName,
           customerPhone,
           notes,
           subtotal,
           total,
           setTable,
           setCustomerName,
           setCustomerPhone,
           setNotes,
           clearCart,
         } = useCart();

         const [isSubmitting, setIsSubmitting] = useState(false);
         const [orderCreated, setOrderCreated] = useState(false);
         const [localOrderId, setLocalOrderId] = useState<string | null>(null);

         const handleSubmit = async () => {
           // Validate
           if (orderType === 'dine_in' && !tableId) {
             alert('Please select a table');
             return;
           }

           setIsSubmitting(true);
           try {
             const orderId = await createOfflineOrder({
               orderType,
               tableId,
               customerName,
               customerPhone,
               notes,
               items: items.map(item => ({
                 menuItemId: item.menuItemId,
                 menuItemName: item.menuItemName,
                 quantity: item.quantity,
                 unitPrice: item.unitPrice,
                 notes: item.notes,
                 modifiers: item.modifiers,
               })),
               subtotal,
               total,
             });

             setLocalOrderId(orderId);
             setOrderCreated(true);
             clearCart();
           } catch (error) {
             alert('Failed to create order');
           } finally {
             setIsSubmitting(false);
           }
         };

         if (orderCreated) {
           return (
             <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
               <div className="bg-white rounded-lg p-6 w-full max-w-md text-center">
                 <div className="text-green-500 text-5xl mb-4">&#10003;</div>
                 <h2 className="text-xl font-bold mb-2">Order Created!</h2>
                 <p className="text-gray-500 mb-4">
                   Order has been queued for processing.
                 </p>
                 <Button onClick={onClose} className="w-full">
                   Continue
                 </Button>
               </div>
             </div>
           );
         }

         return (
           <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
             <div className="bg-white rounded-lg w-full max-w-md max-h-[80vh] overflow-hidden">
               <div className="p-4 border-b">
                 <h2 className="text-lg font-bold">{t('submit')}</h2>
               </div>

               <div className="p-4 space-y-4 overflow-y-auto max-h-[50vh]">
                 <OrderTypeSelector />

                 {orderType === 'dine_in' && (
                   <div>
                     <label className="block text-sm font-medium text-gray-700 mb-2">
                       {t('table')}
                     </label>
                     <input
                       type="text"
                       value={tableId || ''}
                       onChange={e => setTable(e.target.value || null)}
                       placeholder="Table number"
                       className="w-full p-2 border rounded"
                     />
                   </div>
                 )}

                 {orderType === 'delivery' && (
                   <>
                     <div>
                       <label className="block text-sm font-medium text-gray-700 mb-2">
                         Customer Name
                       </label>
                       <input
                         type="text"
                         value={customerName}
                         onChange={e => setCustomerName(e.target.value)}
                         className="w-full p-2 border rounded"
                       />
                     </div>
                     <div>
                       <label className="block text-sm font-medium text-gray-700 mb-2">
                         Phone
                       </label>
                       <input
                         type="tel"
                         value={customerPhone}
                         onChange={e => setCustomerPhone(e.target.value)}
                         className="w-full p-2 border rounded"
                       />
                     </div>
                   </>
                 )}

                 <div>
                   <label className="block text-sm font-medium text-gray-700 mb-2">
                     {t('notes')}
                   </label>
                   <textarea
                     value={notes}
                     onChange={e => setNotes(e.target.value)}
                     className="w-full p-2 border rounded"
                     rows={2}
                   />
                 </div>

                 <div className="border-t pt-4">
                   <div className="flex justify-between text-lg font-bold">
                     <span>Total</span>
                     <span>{total.toLocaleString()} XOF</span>
                   </div>
                 </div>
               </div>

               <div className="p-4 border-t flex gap-2">
                 <Button variant="secondary" onClick={onClose} className="flex-1">
                   {tCommon('cancel')}
                 </Button>
                 <Button
                   onClick={handleSubmit}
                   disabled={isSubmitting}
                   className="flex-1"
                 >
                   {isSubmitting ? tCommon('loading') : t('submit')}
                 </Button>
               </div>
             </div>
           </div>
         );
       }
       ```

    4. Create apps/web/lib/hooks/useOrders.ts:
       ```typescript
       'use client';

       import { useLiveQuery } from 'dexie-react-hooks';
       import { db, LocalOrder } from '@/lib/db/schema';

       export function useLocalOrders() {
         const orders = useLiveQuery(
           () => db.orders.orderBy('createdAt').reverse().toArray(),
           [],
           []
         );

         const pendingOrders = orders.filter(o => o.status === 'pending');
         const preparingOrders = orders.filter(o => o.status === 'preparing');
         const readyOrders = orders.filter(o => o.status === 'ready');

         return {
           orders,
           pendingOrders,
           preparingOrders,
           readyOrders,
         };
       }

       export function useOrder(localId: string) {
         return useLiveQuery(
           () => db.orders.get({ localId }),
           [localId]
         );
       }
       ```
  </action>
  <verify>Complete checkout flow: add item, open checkout, submit order</verify>
  <done>Modifier modal and checkout flow working, orders stored locally</done>
</task>

</tasks>

<verification>
1. npm run dev starts without errors
2. Menu loads from API or IndexedDB (offline)
3. Items can be added to cart with modifiers
4. Cart shows correct totals
5. Order type can be selected
6. Order submits and stores in IndexedDB
7. Pending operation is queued for sync
8. Offline indicator shows when disconnected
</verification>

<success_criteria>
- POS page displays menu categories and items
- Items with modifiers show modifier selection modal
- Cart updates in real-time with correct totals
- Order type selection affects visible fields (table for dine-in)
- Order creation stores in IndexedDB first
- Sync operation queued for background processing
- UI works without internet connection
- All translations used (no hardcoded English)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pos-core/02-05-SUMMARY.md`
</output>
