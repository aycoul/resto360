---
phase: 04-payments
plan: 05
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03", "04-04"]
files_modified:
  - apps/api/apps/payments/serializers.py
  - apps/api/apps/payments/views.py
  - apps/api/apps/payments/urls.py
  - apps/api/apps/payments/services.py
  - apps/api/apps/payments/tests/test_api.py
autonomous: true

must_haves:
  truths:
    - "Payment can be initiated with order ID and provider code"
    - "Idempotency key prevents duplicate payment creation"
    - "Mobile money payments return redirect URL"
    - "Cash payments succeed immediately"
    - "Payment status can be retrieved by ID"
  artifacts:
    - path: "apps/api/apps/payments/views.py"
      provides: "Payment initiation and status endpoints"
      contains: "PaymentViewSet"
    - path: "apps/api/apps/payments/services.py"
      provides: "Payment orchestration logic"
      contains: "initiate_payment"
  key_links:
    - from: "apps/api/apps/payments/services.py"
      to: "apps/api/apps/payments/providers/__init__.py"
      via: "get_provider"
      pattern: "get_provider\\(provider_code\\)"
    - from: "apps/api/apps/payments/views.py"
      to: "apps/api/apps/payments/services.py"
      via: "Service call"
      pattern: "initiate_payment"
---

<objective>
Create the payment initiation and status API endpoints with idempotency enforcement.

Purpose: Expose payment functionality via REST API. Cashiers can initiate payments, customers can be redirected to mobile money providers, and the system prevents double-charging.

Output: Working payment API endpoints for initiating payments and checking status.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments/04-RESEARCH.md
@.planning/phases/04-payments/04-01-SUMMARY.md
@.planning/phases/04-payments/04-02-SUMMARY.md
@.planning/phases/04-payments/04-03-SUMMARY.md
@.planning/phases/04-payments/04-04-SUMMARY.md

@apps/api/apps/payments/models.py
@apps/api/apps/payments/providers/__init__.py
@apps/api/apps/payments/services.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment orchestration service</name>
  <files>
    apps/api/apps/payments/services.py
  </files>
  <action>
Update services.py to add payment orchestration logic:

**initiate_payment(order, payment_method, idempotency_key, request) -> dict:**
```python
def initiate_payment(
    order: "Order",
    payment_method: "PaymentMethod",
    idempotency_key: str,
    request,
    callback_url: str = None,
    success_url: str = None,
    error_url: str = None,
) -> dict:
    """
    Initiate a payment for an order.

    Returns dict with:
    - payment: Payment instance
    - redirect_url: URL for mobile money redirect (or None for cash)
    - status: Current payment status
    """
    from django.db import transaction
    from .models import Payment, PaymentStatus
    from .providers import get_provider
    from .tasks import poll_payment_status

    # Check idempotency - return existing payment if found
    existing = check_idempotency(idempotency_key)
    if existing:
        return {
            "payment": existing,
            "redirect_url": existing.provider_response.get("redirect_url"),
            "status": existing.status,
            "is_duplicate": True,
        }

    # Get provider
    provider_code = payment_method.provider_code
    provider = get_provider(provider_code)

    # Build URLs (use defaults if not provided)
    base_url = request.build_absolute_uri("/")[:-1]  # Remove trailing slash
    callback_url = callback_url or f"{base_url}/api/payments/webhooks/{provider_code}/"
    success_url = success_url or f"{base_url}/payments/success/"
    error_url = error_url or f"{base_url}/payments/error/"

    with transaction.atomic():
        # Create payment record
        payment = Payment.objects.create(
            restaurant=order.restaurant,
            order=order,
            payment_method=payment_method,
            amount=order.total,
            idempotency_key=idempotency_key,
            provider_code=provider_code,
        )

        # Acquire idempotency lock
        if not acquire_idempotency_lock(idempotency_key, str(payment.id)):
            # Race condition - another request won
            payment.delete()
            existing = check_idempotency(idempotency_key)
            return {
                "payment": existing,
                "redirect_url": existing.provider_response.get("redirect_url") if existing else None,
                "status": existing.status if existing else PaymentStatus.FAILED,
                "is_duplicate": True,
            }

        # Initiate with provider
        result = provider.initiate_payment(
            amount=order.total,
            currency="XOF",
            order_reference=f"ORD-{order.order_number}",
            customer_phone=order.customer_phone or "",
            idempotency_key=idempotency_key,
            callback_url=callback_url,
            success_url=success_url,
            error_url=error_url,
        )

        # Update payment with provider response
        payment.provider_reference = result.provider_reference
        payment.provider_response = {
            "redirect_url": result.redirect_url,
            "raw_response": result.raw_response,
        }

        if result.status == ProviderStatus.SUCCESS:
            # Cash payments succeed immediately
            payment.mark_success()
        elif result.status == ProviderStatus.FAILED:
            payment.mark_failed(result.error_code, result.error_message)
        else:
            # PENDING - transition to PROCESSING
            payment.start_processing()
            # Schedule polling for unreliable webhooks
            if provider_code in ["orange", "mtn"]:
                poll_payment_status.apply_async(
                    args=[str(payment.id)],
                    countdown=120  # Poll after 2 minutes
                )

        payment.save()

    return {
        "payment": payment,
        "redirect_url": result.redirect_url,
        "status": payment.status,
        "is_duplicate": False,
    }
```

**get_payment_status(payment_id, restaurant) -> dict:**
```python
def get_payment_status(payment_id: str, restaurant) -> dict:
    """Get current payment status."""
    from .models import Payment

    payment = Payment.objects.filter(
        id=payment_id,
        restaurant=restaurant,
    ).first()

    if not payment:
        return None

    return {
        "id": str(payment.id),
        "order_id": str(payment.order_id),
        "amount": payment.amount,
        "status": payment.status,
        "provider_code": payment.provider_code,
        "provider_reference": payment.provider_reference,
        "initiated_at": payment.initiated_at.isoformat(),
        "completed_at": payment.completed_at.isoformat() if payment.completed_at else None,
    }
```

**Important:**
- Use transaction.atomic() for payment creation + lock
- Schedule polling for Orange and MTN (unreliable webhooks)
- Return is_duplicate flag for idempotent responses
  </action>
  <verify>
    python -c "from apps.payments.services import initiate_payment, get_payment_status; print('Services OK')"
  </verify>
  <done>
    - initiate_payment handles all provider types
    - Idempotency enforced with cache + DB
    - Polling scheduled for unreliable providers
  </done>
</task>

<task type="auto">
  <name>Task 2: Create payment API endpoints</name>
  <files>
    apps/api/apps/payments/serializers.py
    apps/api/apps/payments/views.py
    apps/api/apps/payments/urls.py
  </files>
  <action>
1. Add to serializers.py:

**InitiatePaymentSerializer:**
- order_id: UUIDField(required=True)
- payment_method_id: UUIDField(required=True)
- idempotency_key: CharField(max_length=255, required=True)
- success_url: URLField(required=False, allow_blank=True)
- error_url: URLField(required=False, allow_blank=True)

**PaymentStatusSerializer:**
- id: UUIDField(read_only=True)
- order_id: UUIDField(read_only=True)
- amount: IntegerField(read_only=True)
- status: CharField(read_only=True)
- provider_code: CharField(read_only=True)
- provider_reference: CharField(read_only=True)
- redirect_url: CharField(read_only=True, allow_null=True)
- initiated_at: DateTimeField(read_only=True)
- completed_at: DateTimeField(read_only=True, allow_null=True)

2. Update views.py:

**PaymentViewSet(TenantContextMixin, GenericViewSet):**
- permission_classes = [IsAuthenticated]

- @action(detail=False, methods=['post'])
  def initiate(self, request):
    - Validate with InitiatePaymentSerializer
    - Get order by ID (verify belongs to restaurant)
    - Get payment_method by ID (verify belongs to restaurant and is active)
    - Call services.initiate_payment()
    - Return 200/201 with PaymentStatusSerializer data + redirect_url

- @action(detail=True, methods=['get'])
  def status(self, request, pk=None):
    - Call services.get_payment_status(pk, restaurant)
    - Return 200 with status data or 404

- list(self, request):
    - Get payments for restaurant
    - Filter by order_id, status, provider_code (query params)
    - Return paginated list

3. Add webhook views (from 04-02 if not already):

**WebhookViewMixin:**
- authentication_classes = []
- permission_classes = []

**WaveWebhookView(WebhookViewMixin, APIView):**
- POST: Verify signature, queue for processing, return 200

**OrangeWebhookView(WebhookViewMixin, APIView):**
- POST: Parse body, queue for processing, return 200

**MTNWebhookView(WebhookViewMixin, APIView):**
- POST: Parse body, queue for processing, return 200

4. Update urls.py:
```python
router.register(r'', views.PaymentViewSet, basename='payment')

urlpatterns = [
    path('', include(router.urls)),
    path('webhooks/wave/', views.WaveWebhookView.as_view(), name='webhook-wave'),
    path('webhooks/orange/', views.OrangeWebhookView.as_view(), name='webhook-orange'),
    path('webhooks/mtn/', views.MTNWebhookView.as_view(), name='webhook-mtn'),
]
```

**Important:**
- Webhook endpoints have NO authentication (providers can't auth)
- Use csrf_exempt decorator on webhook views
- Return 200 quickly from webhooks (queue processing)
  </action>
  <verify>
    python apps/api/manage.py check
    python -c "from apps.payments.views import PaymentViewSet, WaveWebhookView; print('Views OK')"
  </verify>
  <done>
    - PaymentViewSet has initiate and status actions
    - Webhook views exist for all providers
    - URLs registered correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add API integration tests</name>
  <files>
    apps/api/apps/payments/tests/test_api.py
  </files>
  <action>
Create tests/test_api.py with comprehensive API tests:

**Fixtures:**
- restaurant, user (cashier role)
- order (belonging to restaurant)
- payment_method_cash, payment_method_wave (active)

**test_initiate_cash_payment:**
- POST /api/payments/initiate/ with cash payment method
- Assert 201, status == SUCCESS, redirect_url == None

**test_initiate_wave_payment:**
- Mock Wave API response
- POST /api/payments/initiate/ with wave payment method
- Assert 201, status == PROCESSING, redirect_url present

**test_initiate_payment_idempotent:**
- POST same idempotency_key twice
- Assert second request returns same payment, is_duplicate=true

**test_initiate_payment_invalid_order:**
- POST with non-existent order_id
- Assert 400 or 404

**test_initiate_payment_inactive_method:**
- Deactivate payment method
- POST with that method
- Assert 400

**test_get_payment_status:**
- Create payment
- GET /api/payments/{id}/status/
- Assert 200 with correct status

**test_get_payment_status_404:**
- GET with invalid ID
- Assert 404

**test_list_payments:**
- Create multiple payments
- GET /api/payments/
- Assert paginated list

**test_list_payments_filter_by_status:**
- Create payments with different statuses
- GET /api/payments/?status=success
- Assert only SUCCESS payments returned

**test_webhook_wave_success:**
- Create PROCESSING payment
- POST to /api/payments/webhooks/wave/ with valid signature
- Assert 200
- (Processing is async; payment status may not change in sync test)

**test_webhook_invalid_signature:**
- POST with invalid signature
- Assert 401

**test_webhook_no_auth_required:**
- POST without auth headers
- Assert NOT 403 (webhooks don't require auth)

**Important:**
- Use unittest.mock.patch for provider API calls
- Test tenant isolation (payment from other restaurant not accessible)
- Test idempotency thoroughly
  </action>
  <verify>
    cd apps/api && python -m pytest apps/payments/tests/test_api.py -v --tb=short
  </verify>
  <done>
    - Payment initiation tests pass (5+ tests)
    - Payment status tests pass (2+ tests)
    - Payment list tests pass (2+ tests)
    - Webhook tests pass (3+ tests)
    - 12+ total API tests pass
  </done>
</task>

</tasks>

<verification>
1. API endpoints work: `curl -X POST http://localhost:8000/api/payments/initiate/ -H "Authorization: Bearer ..." -d '...'`
2. All tests pass: `cd apps/api && python -m pytest apps/payments/tests/test_api.py -v`
3. Webhooks accessible: `curl -X POST http://localhost:8000/api/payments/webhooks/wave/`
</verification>

<success_criteria>
- POST /api/payments/initiate/ creates payment and returns redirect URL for mobile money
- Idempotency key prevents duplicate payments
- Cash payments succeed immediately with no redirect
- GET /api/payments/{id}/status/ returns current payment status
- Webhook endpoints receive provider callbacks
- 12+ API tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments/04-05-SUMMARY.md`
</output>
