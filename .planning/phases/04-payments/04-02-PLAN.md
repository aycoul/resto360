---
phase: 04-payments
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/apps/payments/providers/wave.py
  - apps/api/apps/payments/webhooks/__init__.py
  - apps/api/apps/payments/webhooks/verification.py
  - apps/api/apps/payments/webhooks/handlers.py
  - apps/api/apps/payments/tasks.py
  - apps/api/apps/payments/tests/test_wave.py
  - apps/api/apps/payments/tests/test_webhooks.py
  - apps/api/config/settings/base.py
autonomous: true
user_setup:
  - service: wave
    why: "Mobile money payment processing"
    env_vars:
      - name: WAVE_API_KEY
        source: "Wave Business Dashboard -> Settings -> API Keys"
      - name: WAVE_WEBHOOK_SECRET
        source: "Wave Business Dashboard -> Settings -> Webhooks -> Signing Secret"
    dashboard_config:
      - task: "Create webhook endpoint"
        location: "Wave Business Dashboard -> Settings -> Webhooks"
        value: "https://your-domain.com/api/payments/webhooks/wave/"

must_haves:
  truths:
    - "Wave checkout session can be created with amount and order reference"
    - "Wave webhook signature is verified using HMAC-SHA256"
    - "Webhook events are processed asynchronously via Celery"
    - "Payment status is updated based on webhook event type"
  artifacts:
    - path: "apps/api/apps/payments/providers/wave.py"
      provides: "WaveProvider implementation"
      contains: "class WaveProvider(PaymentProvider)"
    - path: "apps/api/apps/payments/webhooks/verification.py"
      provides: "Signature verification utilities"
      contains: "verify_wave_signature"
    - path: "apps/api/apps/payments/tasks.py"
      provides: "Celery task for webhook processing"
      contains: "@shared_task"
  key_links:
    - from: "apps/api/apps/payments/providers/wave.py"
      to: "https://api.wave.com"
      via: "requests.post"
      pattern: "api\\.wave\\.com"
    - from: "apps/api/apps/payments/tasks.py"
      to: "apps/api/apps/payments/models.py"
      via: "Updates Payment status"
      pattern: "payment\\.(mark_success|mark_failed)"
---

<objective>
Implement Wave Money payment provider with webhook handling and async processing.

Purpose: Wave is the most popular mobile money provider in Ivory Coast. This plan enables customers to pay via Wave Money with real-time status updates.

Output: Working Wave provider that initiates payments, verifies webhooks, and updates payment status.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments/04-RESEARCH.md
@.planning/phases/04-payments/04-01-SUMMARY.md

# Provider base class
@apps/api/apps/payments/providers/base.py
@apps/api/apps/payments/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Wave provider</name>
  <files>
    apps/api/apps/payments/providers/wave.py
    apps/api/apps/payments/providers/__init__.py
    apps/api/config/settings/base.py
  </files>
  <action>
1. Add Wave settings to settings/base.py:
```python
# Wave Money Configuration
WAVE_API_KEY = env("WAVE_API_KEY", default="")
WAVE_WEBHOOK_SECRET = env("WAVE_WEBHOOK_SECRET", default="")
WAVE_API_URL = env("WAVE_API_URL", default="https://api.wave.com/v1")
```

2. Create providers/wave.py with WaveProvider class:

**WaveProvider(PaymentProvider):**

Properties:
- provider_code = "wave"
- api_key (from settings)
- webhook_secret (from settings)
- api_url (from settings)

Methods:
- __init__(): Load config from Django settings
- initiate_payment(...) -> PaymentResult:
  - POST to {api_url}/checkout/sessions
  - Headers: Authorization: Bearer {api_key}, Content-Type: application/json
  - Body: amount (string!), currency="XOF", client_reference=order_reference, success_url, error_url
  - Optional: restrict_payer_mobile if customer_phone provided
  - Return PaymentResult with provider_reference=response["id"], redirect_url=response["wave_launch_url"], status=PENDING
  - Handle errors: return PaymentResult with status=FAILED and error details

- check_status(provider_reference) -> PaymentResult:
  - GET to {api_url}/checkout/sessions/{provider_reference}
  - Map status: "complete" -> SUCCESS, "expired" -> EXPIRED, else PENDING
  - Return PaymentResult with mapped status

- process_refund(provider_reference, amount=None) -> RefundResult:
  - POST to {api_url}/checkout/sessions/{provider_reference}/refund
  - Body: amount (string) if partial, omit for full refund
  - Return RefundResult(success=True) or with error_message

- verify_webhook(headers, body) -> bool:
  - Delegate to verification.verify_wave_signature()

- parse_webhook(body) -> dict:
  - Parse JSON body
  - Return normalized dict: {event_type, payment_reference, status, amount, ...}

3. Update providers/__init__.py:
   - Import WaveProvider
   - Add "wave" to get_provider() mapping

**Important:**
- Wave expects amount as STRING, not integer
- Always use requests.post/get with timeout=30
- Handle requests.RequestException for network errors
  </action>
  <verify>
    python -c "from apps.payments.providers.wave import WaveProvider; p = WaveProvider(); print(f'Provider: {p.provider_code}')"
  </verify>
  <done>
    - WaveProvider class implements all PaymentProvider methods
    - Settings loaded from environment variables
    - get_provider("wave") returns WaveProvider instance
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook verification and handlers</name>
  <files>
    apps/api/apps/payments/webhooks/__init__.py
    apps/api/apps/payments/webhooks/verification.py
    apps/api/apps/payments/webhooks/handlers.py
    apps/api/apps/payments/tasks.py
  </files>
  <action>
1. Create webhooks/__init__.py (empty)

2. Create webhooks/verification.py with Wave signature verification:

```python
def parse_wave_signature(header: str) -> tuple[str, list[str]]:
    """Parse Wave-Signature header into timestamp and signatures."""
    # Format: t=timestamp,v1=signature1,v1=signature2
    parts = header.split(',')
    timestamp = None
    signatures = []
    for part in parts:
        key, _, value = part.strip().partition('=')
        if key == 't':
            timestamp = value
        elif key == 'v1':
            signatures.append(value)
    return timestamp, signatures

def verify_wave_signature(
    wave_signature: str,
    raw_body: bytes,
    webhook_secret: str,
    max_age_seconds: int = 300
) -> bool:
    """Verify Wave webhook signature with replay attack prevention."""
    import hmac
    import hashlib
    import time

    timestamp, signatures = parse_wave_signature(wave_signature)
    if not timestamp or not signatures:
        return False

    # Check timestamp freshness (replay attack prevention)
    try:
        webhook_time = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - webhook_time) > max_age_seconds:
            return False
    except ValueError:
        return False

    # Compute expected signature: HMAC-SHA256(timestamp + body, secret)
    payload = timestamp.encode('utf-8') + raw_body
    expected = hmac.new(
        webhook_secret.encode('utf-8'),
        payload,
        hashlib.sha256
    ).hexdigest()

    # Constant-time comparison
    return any(hmac.compare_digest(expected, sig) for sig in signatures)
```

3. Create webhooks/handlers.py with webhook processing logic:

```python
def process_wave_webhook(event_data: dict) -> None:
    """Process Wave webhook event and update payment status."""
    from apps.payments.models import Payment, PaymentStatus

    event_type = event_data.get("type")
    checkout_session_id = event_data.get("data", {}).get("id")

    if not checkout_session_id:
        return  # Invalid event

    payment = Payment.objects.filter(
        provider_code="wave",
        provider_reference=checkout_session_id
    ).first()

    if not payment:
        return  # Payment not found

    if event_type == "checkout.session.completed":
        if payment.status == PaymentStatus.PROCESSING:
            payment.mark_success()
            payment.provider_response = event_data
            payment.save()
    elif event_type == "checkout.session.expired":
        if payment.status == PaymentStatus.PROCESSING:
            payment.mark_expired()
            payment.provider_response = event_data
            payment.save()
```

4. Create tasks.py with Celery task:

```python
from celery import shared_task
import json

@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def process_webhook_event(self, provider_code: str, headers: dict, body: str):
    """Process webhook event asynchronously."""
    from .webhooks.handlers import process_wave_webhook

    try:
        event_data = json.loads(body)

        if provider_code == "wave":
            process_wave_webhook(event_data)
        # Add other providers here

    except Exception as exc:
        # Retry on failure
        raise self.retry(exc=exc)
```

**Important:**
- ALWAYS access request.body (raw bytes) BEFORE any JSON parsing
- Webhook handlers must be idempotent (same event processed twice = same result)
- Use @shared_task for Celery, not @app.task
  </action>
  <verify>
    python -c "from apps.payments.webhooks.verification import verify_wave_signature; print('Verification OK')"
    python -c "from apps.payments.tasks import process_webhook_event; print('Tasks OK')"
  </verify>
  <done>
    - Wave signature verification function works
    - Webhook handler updates payment status
    - Celery task queues webhook processing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Wave provider and webhook tests</name>
  <files>
    apps/api/apps/payments/tests/test_wave.py
    apps/api/apps/payments/tests/test_webhooks.py
  </files>
  <action>
1. Create tests/test_wave.py:

**test_wave_provider_code:** Assert provider_code == "wave"

**test_initiate_payment_success:**
- Mock requests.post to return checkout session response
- Call initiate_payment with test data
- Assert PaymentResult has redirect_url and provider_reference

**test_initiate_payment_error:**
- Mock requests.post to raise RequestException
- Assert PaymentResult has status=FAILED and error_message

**test_check_status_success:**
- Mock requests.get to return status="complete"
- Assert PaymentResult has status=SUCCESS

**test_process_refund_success:**
- Mock requests.post to return 200
- Assert RefundResult.success is True

2. Create tests/test_webhooks.py:

**test_parse_wave_signature:**
- Input: "t=1234567890,v1=abc123,v1=def456"
- Assert timestamp == "1234567890", signatures == ["abc123", "def456"]

**test_verify_wave_signature_valid:**
- Compute valid signature using known secret and body
- Assert verify_wave_signature returns True

**test_verify_wave_signature_invalid:**
- Use wrong signature
- Assert returns False

**test_verify_wave_signature_expired:**
- Use timestamp > 5 minutes old
- Assert returns False

**test_process_wave_webhook_success:**
- Create Payment in PROCESSING status
- Call process_wave_webhook with checkout.session.completed event
- Assert payment status is now SUCCESS

**test_process_wave_webhook_expired:**
- Create Payment in PROCESSING status
- Call process_wave_webhook with checkout.session.expired event
- Assert payment status is now EXPIRED

**test_process_wave_webhook_idempotent:**
- Create Payment already in SUCCESS status
- Call process_wave_webhook with checkout.session.completed
- Assert no error, payment still SUCCESS

**Important:**
- Use @pytest.fixture for mocked responses
- Use unittest.mock.patch for requests
- Use freezegun or manual timestamp for time-based tests
  </action>
  <verify>
    cd apps/api && python -m pytest apps/payments/tests/test_wave.py apps/payments/tests/test_webhooks.py -v --tb=short
  </verify>
  <done>
    - Wave provider tests pass (5+ tests)
    - Webhook verification tests pass (4+ tests)
    - Webhook handler tests pass (3+ tests)
    - All tests pass without external API calls
  </done>
</task>

</tasks>

<verification>
1. Provider works: `python -c "from apps.payments.providers import get_provider; p = get_provider('wave'); print(p.provider_code)"`
2. Signature verification works with test data
3. All tests pass: `cd apps/api && python -m pytest apps/payments/tests/test_wave.py apps/payments/tests/test_webhooks.py -v`
</verification>

<success_criteria>
- WaveProvider creates checkout sessions via Wave API
- Webhook signatures verified using HMAC-SHA256 with timestamp
- Webhook events processed asynchronously via Celery
- Payment status updated (SUCCESS, EXPIRED) based on webhook
- 12+ tests pass covering provider, verification, and handlers
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments/04-02-SUMMARY.md`
</output>
