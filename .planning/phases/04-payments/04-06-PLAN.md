---
phase: 04-payments
plan: 06
type: execute
wave: 3
depends_on: ["04-01", "04-05"]
files_modified:
  - apps/api/apps/payments/services.py
  - apps/api/apps/payments/serializers.py
  - apps/api/apps/payments/views.py
  - apps/api/apps/payments/urls.py
  - apps/api/apps/payments/tests/test_reconciliation.py
  - apps/api/apps/payments/tests/test_refunds.py
autonomous: true

must_haves:
  truths:
    - "Daily reconciliation shows payments grouped by provider"
    - "Reconciliation includes totals and net amount after refunds"
    - "Refund can be initiated for successful mobile money payments"
    - "Partial refunds track refunded amount separately"
  artifacts:
    - path: "apps/api/apps/payments/services.py"
      provides: "Reconciliation and refund services"
      contains: "get_daily_reconciliation"
    - path: "apps/api/apps/payments/views.py"
      provides: "Reconciliation and refund endpoints"
      contains: "reconciliation"
  key_links:
    - from: "apps/api/apps/payments/services.py"
      to: "apps/api/apps/payments/models.py"
      via: "Aggregation queries"
      pattern: "Payment\\.objects\\.filter.*aggregate"
    - from: "apps/api/apps/payments/views.py"
      to: "apps/api/apps/payments/services.py"
      via: "Service calls"
      pattern: "get_daily_reconciliation|process_refund"
---

<objective>
Implement daily reconciliation report and refund functionality.

Purpose: Managers need to see daily payment summaries for accounting. Refunds are necessary for handling customer complaints and order cancellations.

Output: Reconciliation endpoint showing payments by method with totals, and refund endpoint for mobile money payments.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments/04-RESEARCH.md
@.planning/phases/04-payments/04-01-SUMMARY.md
@.planning/phases/04-payments/04-05-SUMMARY.md

@apps/api/apps/payments/models.py
@apps/api/apps/payments/services.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reconciliation service</name>
  <files>
    apps/api/apps/payments/services.py
  </files>
  <action>
Add reconciliation function to services.py:

**get_daily_reconciliation(restaurant, date=None) -> dict:**
```python
def get_daily_reconciliation(restaurant, date=None) -> dict:
    """
    Generate daily payment reconciliation report.

    Args:
        restaurant: Restaurant instance
        date: Date to report on (defaults to today)

    Returns:
        dict with by_provider breakdown, totals, refunds, and net_amount
    """
    from django.db.models import Sum, Count
    from django.utils import timezone
    from datetime import timedelta
    from .models import Payment, PaymentStatus

    if date is None:
        date = timezone.localdate()

    # Build datetime range for the day
    start = timezone.make_aware(
        timezone.datetime.combine(date, timezone.datetime.min.time())
    )
    end = start + timedelta(days=1)

    # Get successful payments for the day
    payments = Payment.objects.filter(
        restaurant=restaurant,
        status=PaymentStatus.SUCCESS,
        completed_at__gte=start,
        completed_at__lt=end,
    )

    # Aggregate by provider
    by_provider = payments.values("provider_code").annotate(
        count=Count("id"),
        total=Sum("amount"),
    ).order_by("provider_code")

    # Format provider names
    provider_names = {
        "wave": "Wave Money",
        "orange": "Orange Money",
        "mtn": "MTN MoMo",
        "cash": "Cash",
    }

    by_provider_formatted = [
        {
            "provider_code": item["provider_code"],
            "provider_name": provider_names.get(item["provider_code"], item["provider_code"]),
            "count": item["count"],
            "total": item["total"] or 0,
        }
        for item in by_provider
    ]

    # Calculate totals
    totals = payments.aggregate(
        total_count=Count("id"),
        total_amount=Sum("amount"),
    )

    # Get refunds (same day)
    refunds = Payment.objects.filter(
        restaurant=restaurant,
        status__in=[PaymentStatus.REFUNDED, PaymentStatus.PARTIALLY_REFUNDED],
        completed_at__gte=start,
        completed_at__lt=end,
    ).aggregate(
        refund_count=Count("id"),
        refund_amount=Sum("refunded_amount"),
    )

    # Get pending payments (initiated but not completed)
    pending = Payment.objects.filter(
        restaurant=restaurant,
        status=PaymentStatus.PROCESSING,
        initiated_at__gte=start,
        initiated_at__lt=end,
    ).aggregate(
        pending_count=Count("id"),
        pending_amount=Sum("amount"),
    )

    # Get failed payments
    failed = Payment.objects.filter(
        restaurant=restaurant,
        status__in=[PaymentStatus.FAILED, PaymentStatus.EXPIRED],
        initiated_at__gte=start,
        initiated_at__lt=end,
    ).aggregate(
        failed_count=Count("id"),
        failed_amount=Sum("amount"),
    )

    total_amount = totals["total_amount"] or 0
    refund_amount = refunds["refund_amount"] or 0

    return {
        "date": date.isoformat(),
        "restaurant_id": str(restaurant.id),
        "by_provider": by_provider_formatted,
        "totals": {
            "count": totals["total_count"] or 0,
            "amount": total_amount,
        },
        "refunds": {
            "count": refunds["refund_count"] or 0,
            "amount": refund_amount,
        },
        "pending": {
            "count": pending["pending_count"] or 0,
            "amount": pending["pending_amount"] or 0,
        },
        "failed": {
            "count": failed["failed_count"] or 0,
            "amount": failed["failed_amount"] or 0,
        },
        "net_amount": total_amount - refund_amount,
    }
```

**get_reconciliation_range(restaurant, start_date, end_date) -> list:**
```python
def get_reconciliation_range(restaurant, start_date, end_date) -> list:
    """Get reconciliation for a date range (max 90 days)."""
    from datetime import timedelta

    # Enforce max 90 days
    if (end_date - start_date).days > 90:
        raise ValueError("Date range cannot exceed 90 days")

    results = []
    current = start_date
    while current <= end_date:
        results.append(get_daily_reconciliation(restaurant, current))
        current += timedelta(days=1)

    return results
```

**Important:**
- Use timezone-aware datetime for accurate day boundaries
- Include pending and failed for complete picture
- Net amount = total - refunds
  </action>
  <verify>
    python -c "from apps.payments.services import get_daily_reconciliation; print('Reconciliation OK')"
  </verify>
  <done>
    - get_daily_reconciliation returns complete report
    - Payments grouped by provider with counts and totals
    - Refunds, pending, and failed included
    - Net amount calculated correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement refund service and API</name>
  <files>
    apps/api/apps/payments/services.py
    apps/api/apps/payments/serializers.py
    apps/api/apps/payments/views.py
    apps/api/apps/payments/urls.py
  </files>
  <action>
1. Add refund function to services.py:

**process_refund_request(payment, amount=None, reason="") -> dict:**
```python
def process_refund_request(payment, amount: int = None, reason: str = "") -> dict:
    """
    Process a refund request for a payment.

    Args:
        payment: Payment instance
        amount: Refund amount (None = full refund)
        reason: Reason for refund

    Returns:
        dict with success status and details
    """
    from .models import PaymentStatus
    from .providers import get_provider

    # Validate payment can be refunded
    if payment.status not in [PaymentStatus.SUCCESS, PaymentStatus.PARTIALLY_REFUNDED]:
        return {
            "success": False,
            "error": f"Cannot refund payment with status {payment.status}",
        }

    # Determine refund amount
    if amount is None:
        amount = payment.amount - payment.refunded_amount
    else:
        max_refundable = payment.amount - payment.refunded_amount
        if amount > max_refundable:
            return {
                "success": False,
                "error": f"Refund amount {amount} exceeds refundable amount {max_refundable}",
            }

    if amount <= 0:
        return {
            "success": False,
            "error": "Refund amount must be positive",
        }

    # Cash refunds are immediate (just mark as refunded)
    if payment.provider_code == "cash":
        if amount == payment.amount - payment.refunded_amount:
            payment.mark_refunded()
        else:
            payment.mark_partially_refunded(amount)
        payment.provider_response["refund_reason"] = reason
        payment.save()
        return {
            "success": True,
            "refund_type": "full" if payment.status == PaymentStatus.REFUNDED else "partial",
            "refunded_amount": amount,
        }

    # Mobile money refund via provider
    provider = get_provider(payment.provider_code)
    result = provider.process_refund(payment.provider_reference, amount)

    if not result.success:
        return {
            "success": False,
            "error": result.error_message or "Provider refund failed",
        }

    # Update payment status
    if amount == payment.amount - payment.refunded_amount:
        payment.mark_refunded()
    else:
        payment.mark_partially_refunded(amount)

    payment.provider_response["refund_reference"] = result.provider_reference
    payment.provider_response["refund_reason"] = reason
    payment.save()

    return {
        "success": True,
        "refund_type": "full" if payment.status == PaymentStatus.REFUNDED else "partial",
        "refunded_amount": amount,
        "provider_reference": result.provider_reference,
    }
```

2. Add serializers to serializers.py:

**RefundRequestSerializer:**
- amount: IntegerField(required=False, min_value=1, allow_null=True)
- reason: CharField(max_length=500, required=False, default="")

**ReconciliationSerializer:**
- date: DateField(read_only=True)
- restaurant_id: UUIDField(read_only=True)
- by_provider: ListField(read_only=True)
- totals: DictField(read_only=True)
- refunds: DictField(read_only=True)
- pending: DictField(read_only=True)
- failed: DictField(read_only=True)
- net_amount: IntegerField(read_only=True)

3. Update views.py:

**Add to PaymentViewSet:**
- @action(detail=True, methods=['post'])
  def refund(self, request, pk=None):
    - Get payment by pk (verify belongs to restaurant)
    - Validate with RefundRequestSerializer
    - Call services.process_refund_request()
    - Return 200 with result or 400 with error

**ReconciliationView(TenantContextMixin, APIView):**
- permission_classes = [IsAuthenticated, IsManagerOrOwner]
- GET: date query param (defaults to today)
    - Call services.get_daily_reconciliation(restaurant, date)
    - Return ReconciliationSerializer data
- GET with start_date and end_date: Range report
    - Call services.get_reconciliation_range()
    - Return list of ReconciliationSerializer data

4. Update urls.py:
```python
urlpatterns = [
    ...
    path('reconciliation/', views.ReconciliationView.as_view(), name='reconciliation'),
]
```

**Important:**
- Reconciliation requires manager or owner role
- Refund checks payment status before processing
- Partial refunds track cumulative refunded_amount
  </action>
  <verify>
    python apps/api/manage.py check
    python -c "from apps.payments.views import ReconciliationView; print('Views OK')"
  </verify>
  <done>
    - Refund service handles full and partial refunds
    - ReconciliationView returns daily report
    - Date range reports work with 90-day limit
    - URLs registered correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add reconciliation and refund tests</name>
  <files>
    apps/api/apps/payments/tests/test_reconciliation.py
    apps/api/apps/payments/tests/test_refunds.py
  </files>
  <action>
1. Create tests/test_reconciliation.py:

**test_daily_reconciliation_empty:**
- No payments for the day
- Assert totals.count == 0, net_amount == 0

**test_daily_reconciliation_single_provider:**
- Create 3 cash payments totaling 30000 XOF
- Assert by_provider has 1 entry with count=3, total=30000

**test_daily_reconciliation_multiple_providers:**
- Create 2 cash (20000) + 3 wave (45000) payments
- Assert by_provider has 2 entries
- Assert totals.count == 5, totals.amount == 65000

**test_reconciliation_includes_refunds:**
- Create payment of 10000, mark as refunded
- Assert refunds.count == 1, refunds.amount == 10000
- Assert net_amount == 0 (total - refund)

**test_reconciliation_date_filter:**
- Create payments on different days
- Get reconciliation for specific day
- Assert only that day's payments included

**test_reconciliation_range:**
- Create payments across 3 days
- Get range report
- Assert 3 reports returned

**test_reconciliation_range_max_90_days:**
- Request > 90 day range
- Assert ValueError raised

**test_reconciliation_api_requires_auth:**
- GET without auth
- Assert 401

**test_reconciliation_api_requires_manager:**
- GET as cashier (not manager)
- Assert 403

2. Create tests/test_refunds.py:

**test_refund_cash_full:**
- Create SUCCESS cash payment
- Call process_refund_request with no amount
- Assert status = REFUNDED, refunded_amount = original amount

**test_refund_cash_partial:**
- Create SUCCESS cash payment of 10000
- Refund 3000
- Assert status = PARTIALLY_REFUNDED, refunded_amount = 3000

**test_refund_mobile_money:**
- Create SUCCESS wave payment
- Mock provider.process_refund to return success
- Call process_refund_request
- Assert provider was called

**test_refund_exceeds_amount:**
- Create payment of 10000
- Try to refund 15000
- Assert error returned

**test_refund_already_refunded:**
- Create REFUNDED payment
- Try to refund again
- Assert error returned

**test_refund_pending_payment:**
- Create PROCESSING payment
- Try to refund
- Assert error (can't refund non-success)

**test_refund_api:**
- POST /api/payments/{id}/refund/
- Assert 200 with success result

**test_multiple_partial_refunds:**
- Create payment of 10000
- Refund 3000, then 4000
- Assert total refunded_amount = 7000
- Refund 3000 more -> fully refunded

**Important:**
- Use freezegun to control date in tests
- Create payments with different completed_at dates
- Mock provider refund calls
  </action>
  <verify>
    cd apps/api && python -m pytest apps/payments/tests/test_reconciliation.py apps/payments/tests/test_refunds.py -v --tb=short
  </verify>
  <done>
    - Reconciliation tests pass (9+ tests)
    - Refund tests pass (8+ tests)
    - Date filtering works correctly
    - Partial refunds tracked properly
  </done>
</task>

</tasks>

<verification>
1. Reconciliation works: `python -c "from apps.payments.services import get_daily_reconciliation; print('OK')"`
2. API endpoints work: `curl http://localhost:8000/api/payments/reconciliation/?date=2026-02-04` (with manager auth)
3. All tests pass: `cd apps/api && python -m pytest apps/payments/tests/test_reconciliation.py apps/payments/tests/test_refunds.py -v`
</verification>

<success_criteria>
- Daily reconciliation shows payments grouped by provider
- Totals, refunds, pending, failed all included
- Net amount correctly calculated
- Full and partial refunds work for all providers
- Refund validation prevents over-refunding
- Manager/owner role required for reconciliation
- 17+ tests pass covering reconciliation and refunds
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments/04-06-SUMMARY.md`
</output>
