---
phase: 04-payments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/apps/payments/__init__.py
  - apps/api/apps/payments/apps.py
  - apps/api/apps/payments/models.py
  - apps/api/apps/payments/admin.py
  - apps/api/apps/payments/providers/__init__.py
  - apps/api/apps/payments/providers/base.py
  - apps/api/apps/payments/services.py
  - apps/api/apps/payments/migrations/0001_initial.py
  - apps/api/config/settings/base.py
autonomous: true

must_haves:
  truths:
    - "Payment model exists with FSM status transitions"
    - "PaymentMethod model stores provider configs per restaurant"
    - "CashDrawerSession model tracks drawer open/close"
    - "PaymentProvider abstract base class defines interface"
    - "Idempotency service prevents duplicate payment creation"
  artifacts:
    - path: "apps/api/apps/payments/models.py"
      provides: "Payment, PaymentMethod, CashDrawerSession models with FSM"
      contains: "FSMField"
    - path: "apps/api/apps/payments/providers/base.py"
      provides: "PaymentProvider abstract base class"
      contains: "class PaymentProvider(ABC)"
    - path: "apps/api/apps/payments/services.py"
      provides: "Idempotency check and lock functions"
      contains: "check_idempotency"
  key_links:
    - from: "apps/api/apps/payments/models.py"
      to: "apps/api/apps/orders/models.py"
      via: "ForeignKey to Order"
      pattern: "ForeignKey.*orders\\.Order"
    - from: "apps/api/apps/payments/models.py"
      to: "apps/api/apps/core/models.py"
      via: "Extends TenantModel"
      pattern: "class Payment\\(TenantModel\\)"
---

<objective>
Create the payment domain foundation: models, provider abstraction, and idempotency service.

Purpose: Establish the data layer and patterns that all payment providers will use. This is the shared foundation for Wave, Orange, MTN, and Cash payments.

Output: Payment app with models, FSM state machine, provider ABC, and idempotency utilities.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-payments/04-RESEARCH.md

# Existing patterns to follow
@apps/api/apps/core/models.py
@apps/api/apps/orders/models.py
@apps/api/apps/inventory/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payments app with models and FSM</name>
  <files>
    apps/api/apps/payments/__init__.py
    apps/api/apps/payments/apps.py
    apps/api/apps/payments/models.py
    apps/api/apps/payments/admin.py
    apps/api/apps/payments/migrations/__init__.py
    apps/api/config/settings/base.py
  </files>
  <action>
1. Install django-fsm-2: Add `django-fsm-2` to requirements/base.txt

2. Create payments app structure:
   - __init__.py (empty)
   - apps.py with PaymentsConfig (name = "apps.payments")

3. Create models.py with:

**PaymentStatus enum (TextChoices):**
- PENDING, PROCESSING, SUCCESS, FAILED, REFUNDED, PARTIALLY_REFUNDED, EXPIRED

**PaymentMethod model (TenantModel):**
- provider_code: CharField(max_length=20) - 'wave', 'orange', 'mtn', 'cash'
- name: CharField(max_length=100) - Display name
- is_active: BooleanField(default=True)
- config: JSONField(default=dict) - Provider-specific config (NOT secrets)
- display_order: PositiveIntegerField(default=0)
- Managers: all_objects (first), objects (TenantManager)
- Meta: ordering=['display_order', 'name'], unique_together=[['restaurant', 'provider_code']]

**Payment model (TenantModel):**
- order: ForeignKey("orders.Order", CASCADE, related_name="payments")
- payment_method: ForeignKey(PaymentMethod, PROTECT)
- amount: PositiveIntegerField (XOF integer)
- status: FSMField(default=PaymentStatus.PENDING, choices=PaymentStatus.choices)
- idempotency_key: CharField(max_length=255, unique=True, db_index=True)
- provider_code: CharField(max_length=20)
- provider_reference: CharField(max_length=255, blank=True, db_index=True)
- provider_response: JSONField(default=dict)
- refunded_amount: PositiveIntegerField(default=0)
- initiated_at: DateTimeField(auto_now_add=True)
- completed_at: DateTimeField(null=True, blank=True)
- Managers: all_objects (first), objects (TenantManager)
- Meta: ordering=['-initiated_at'], indexes on [restaurant, status], [provider_reference]

**FSM transitions on Payment:**
- start_processing(): PENDING -> PROCESSING
- mark_success(): PROCESSING -> SUCCESS (sets completed_at)
- mark_failed(error_code, error_message): PROCESSING -> FAILED
- mark_expired(): PROCESSING -> EXPIRED
- mark_refunded(): SUCCESS -> REFUNDED (sets refunded_amount=amount)
- mark_partially_refunded(amount): SUCCESS -> PARTIALLY_REFUNDED

**CashDrawerSession model (TenantModel):**
- cashier: ForeignKey("authentication.User", PROTECT, related_name="cash_drawer_sessions")
- opened_at: DateTimeField(auto_now_add=True)
- opening_balance: PositiveIntegerField
- closed_at: DateTimeField(null=True, blank=True)
- closing_balance: PositiveIntegerField(null=True, blank=True)
- expected_balance: PositiveIntegerField(null=True, blank=True)
- variance: IntegerField(null=True, blank=True)
- variance_notes: TextField(blank=True)
- Managers: all_objects (first), objects (TenantManager)
- Meta: ordering=['-opened_at']
- Property: is_open -> closed_at is None
- Method: close(closing_balance, notes="") - calculates expected from cash payments

4. Create admin.py with PaymentAdmin, PaymentMethodAdmin, CashDrawerSessionAdmin

5. Add "apps.payments" to INSTALLED_APPS in settings/base.py (after "apps.inventory")

6. Run `python manage.py makemigrations payments` and `python manage.py migrate`

**Important:**
- Use PositiveIntegerField for XOF amounts (no decimals)
- Import FSMField from django_fsm, NOT django_fsm_2 (package name differs from import)
- Follow TenantModel pattern from inventory app (all_objects first, then objects = TenantManager())
  </action>
  <verify>
    python apps/api/manage.py check
    python apps/api/manage.py makemigrations --check --dry-run
  </verify>
  <done>
    - Payment, PaymentMethod, CashDrawerSession models exist with all fields
    - FSM transitions defined on Payment model
    - Migration 0001_initial.py created and applied
    - Django check passes with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create provider base class and idempotency service</name>
  <files>
    apps/api/apps/payments/providers/__init__.py
    apps/api/apps/payments/providers/base.py
    apps/api/apps/payments/services.py
  </files>
  <action>
1. Create providers/__init__.py with get_provider(provider_code) function that returns appropriate provider instance.

2. Create providers/base.py with:

**ProviderStatus enum:**
- PENDING, PROCESSING, SUCCESS, FAILED, EXPIRED

**PaymentResult dataclass:**
- provider_reference: str
- status: ProviderStatus
- redirect_url: Optional[str] = None
- error_code: Optional[str] = None
- error_message: Optional[str] = None
- raw_response: Optional[dict] = None

**RefundResult dataclass:**
- success: bool
- provider_reference: Optional[str] = None
- error_message: Optional[str] = None

**PaymentProvider ABC:**
- provider_code property (abstract)
- initiate_payment(amount, currency, order_reference, customer_phone, idempotency_key, callback_url, success_url, error_url) -> PaymentResult (abstract)
- check_status(provider_reference) -> PaymentResult (abstract)
- process_refund(provider_reference, amount=None) -> RefundResult (abstract)
- verify_webhook(headers, body) -> bool (abstract)
- parse_webhook(body) -> dict (abstract)

3. Create services.py with idempotency functions:

**Constants:**
- IDEMPOTENCY_TTL = 86400 (24 hours)

**Functions:**
- get_idempotency_lock_key(key: str) -> str: Returns "payment:idempotency:{key}"
- check_idempotency(idempotency_key: str) -> Optional[Payment]:
  - Check cache first (fast path)
  - Check database (slow path)
  - If found in DB but not cache, populate cache
  - Return existing Payment or None
- acquire_idempotency_lock(idempotency_key: str, payment_id: str) -> bool:
  - Use cache.add() for atomic lock (Redis SETNX)
  - Return True if lock acquired, False if already exists
- release_idempotency_lock(idempotency_key: str) -> None:
  - Delete lock from cache (for cleanup on failure)

**Important:**
- Use django.core.cache.cache for Redis operations
- cache.add() is atomic (uses Redis SETNX under the hood)
- Always check both cache AND database for idempotency
  </action>
  <verify>
    python -c "from apps.payments.providers.base import PaymentProvider, PaymentResult, RefundResult; print('Provider base OK')"
    python -c "from apps.payments.services import check_idempotency, acquire_idempotency_lock; print('Services OK')"
  </verify>
  <done>
    - PaymentProvider ABC exists with all abstract methods
    - PaymentResult and RefundResult dataclasses defined
    - Idempotency functions work with Redis cache
    - Imports succeed without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for models and services</name>
  <files>
    apps/api/apps/payments/tests/__init__.py
    apps/api/apps/payments/tests/conftest.py
    apps/api/apps/payments/tests/factories.py
    apps/api/apps/payments/tests/test_models.py
    apps/api/apps/payments/tests/test_services.py
  </files>
  <action>
1. Create tests/__init__.py (empty)

2. Create tests/conftest.py with pytest fixtures:
   - payment_method_factory: Creates PaymentMethod for a restaurant
   - payment_factory: Creates Payment linked to order and payment method
   - cash_drawer_session_factory: Creates open CashDrawerSession

3. Create tests/factories.py with Factory Boy factories:
   - PaymentMethodFactory (provider_code='cash', name='Cash', is_active=True)
   - PaymentFactory (amount=10000, status=PaymentStatus.PENDING)
   - CashDrawerSessionFactory (opening_balance=50000)

4. Create tests/test_models.py:
   - test_payment_fsm_pending_to_processing: Verify transition works
   - test_payment_fsm_processing_to_success: Verify completed_at is set
   - test_payment_fsm_processing_to_failed: Verify error stored
   - test_payment_fsm_invalid_transition: Verify TransitionNotAllowed raised for PENDING->SUCCESS
   - test_payment_method_unique_per_restaurant: Same provider_code fails for same restaurant
   - test_cash_drawer_is_open_property: True when closed_at is None
   - test_cash_drawer_close_calculates_variance: Expected vs actual balance

5. Create tests/test_services.py:
   - test_check_idempotency_returns_none_for_new_key
   - test_check_idempotency_returns_payment_for_existing_key
   - test_acquire_idempotency_lock_succeeds_for_new_key
   - test_acquire_idempotency_lock_fails_for_existing_key
   - test_idempotency_cache_populated_from_db

**Important:**
- Use @pytest.mark.django_db for database tests
- Follow existing test patterns from inventory/tests/
- TransitionNotAllowed is imported from django_fsm
  </action>
  <verify>
    cd apps/api && python -m pytest apps/payments/tests/ -v --tb=short
  </verify>
  <done>
    - All test files created
    - Model FSM transition tests pass
    - Idempotency service tests pass
    - All 10+ tests pass
  </done>
</task>

</tasks>

<verification>
1. Django check passes: `python apps/api/manage.py check`
2. Migrations are clean: `python apps/api/manage.py makemigrations --check`
3. All tests pass: `cd apps/api && python -m pytest apps/payments/tests/ -v`
4. Models can be imported: `python -c "from apps.payments.models import Payment, PaymentMethod, CashDrawerSession"`
</verification>

<success_criteria>
- Payment model has FSM status field with valid transitions
- PaymentMethod model stores provider configs per restaurant
- CashDrawerSession tracks drawer open/close with variance calculation
- PaymentProvider ABC defines the interface all providers implement
- Idempotency service can check and acquire locks using Redis + DB
- 10+ tests pass covering models and services
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments/04-01-SUMMARY.md`
</output>
