---
phase: 05-delivery
plan: 04
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - apps/pwa/src/app/[locale]/track/[id]/page.tsx
  - apps/pwa/src/components/delivery/TrackingMap.tsx
  - apps/pwa/src/components/delivery/DriverInfo.tsx
  - apps/pwa/src/components/delivery/DeliveryTimeline.tsx
  - apps/pwa/src/hooks/useDeliveryTracking.ts
  - apps/pwa/src/lib/delivery-api.ts
autonomous: false

must_haves:
  truths:
    - "Customer can open tracking link and see delivery status"
    - "Customer can see driver location in real-time on map"
    - "Customer can see driver info (name, vehicle, phone)"
    - "Customer can call or message driver from tracking page"
    - "Tracking page shows estimated delivery time"
  artifacts:
    - path: "apps/pwa/src/app/[locale]/track/[id]/page.tsx"
      provides: "Customer delivery tracking page"
      min_lines: 50
    - path: "apps/pwa/src/components/delivery/TrackingMap.tsx"
      provides: "Map component showing driver location"
      contains: "google.maps"
    - path: "apps/pwa/src/hooks/useDeliveryTracking.ts"
      provides: "WebSocket hook for real-time location updates"
      contains: "WebSocket"
  key_links:
    - from: "apps/pwa/src/hooks/useDeliveryTracking.ts"
      to: "/ws/delivery/{id}/track/"
      via: "WebSocket connection for location updates"
      pattern: "ws/delivery"
    - from: "apps/pwa/src/components/delivery/DriverInfo.tsx"
      to: "tel: and sms:"
      via: "Phone and SMS links for customer contact"
      pattern: "tel:|sms:"
---

<objective>
Create customer-facing delivery tracking page in the PWA

Purpose: Enable customers to track their delivery in real-time after placing an order. They receive a tracking link (via WhatsApp or SMS) and can see the driver's live location on a map.

Output:
- Tracking page at /track/[delivery_id]
- Real-time map showing driver location
- Driver info card with contact options
- Delivery status timeline
- Estimated time of arrival
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery/05-RESEARCH.md
@.planning/phases/05-delivery/05-02-SUMMARY.md
@.planning/phases/02-pos-core/02-04-SUMMARY.md

# Prior PWA patterns
@apps/pwa/src/app/[locale]/menu/[slug]/page.tsx
@apps/pwa/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delivery tracking hook with WebSocket</name>
  <files>
    apps/pwa/src/hooks/useDeliveryTracking.ts
    apps/pwa/src/lib/delivery-api.ts
  </files>
  <action>
Create apps/pwa/src/lib/delivery-api.ts:
```typescript
/**
 * Delivery API client for customer tracking.
 */
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

export interface DeliveryInfo {
  id: string;
  status: 'pending_assignment' | 'assigned' | 'picked_up' | 'en_route' | 'delivered' | 'cancelled';
  delivery_address: string;
  estimated_delivery_time: string | null;
  customer_name: string;
  customer_phone: string;
  delivery_fee: number;
  order_number: number;
  driver?: {
    name: string;
    phone: string;
    vehicle_type: string;
    lat?: number;
    lng?: number;
  };
  restaurant?: {
    name: string;
    phone: string;
    address: string;
    lat?: number;
    lng?: number;
  };
  delivery_lat: number;
  delivery_lng: number;
  created_at: string;
  assigned_at?: string;
  picked_up_at?: string;
  en_route_at?: string;
  delivered_at?: string;
}

export async function getDeliveryInfo(deliveryId: string): Promise<DeliveryInfo | null> {
  try {
    // Public endpoint - no auth required for tracking
    const response = await fetch(`${API_URL}/api/v1/delivery/track/${deliveryId}/`);

    if (!response.ok) {
      if (response.status === 404) {
        return null;
      }
      throw new Error('Failed to fetch delivery info');
    }

    return response.json();
  } catch (error) {
    console.error('Error fetching delivery:', error);
    return null;
  }
}
```

Create apps/pwa/src/hooks/useDeliveryTracking.ts:
```typescript
/**
 * Hook for real-time delivery tracking via WebSocket.
 */
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { getDeliveryInfo, DeliveryInfo } from '@/lib/delivery-api';

const WS_URL = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000';

interface DriverLocation {
  lat: number;
  lng: number;
  heading?: number;
  timestamp: string;
}

interface UseDeliveryTrackingResult {
  delivery: DeliveryInfo | null;
  driverLocation: DriverLocation | null;
  isLoading: boolean;
  isConnected: boolean;
  error: string | null;
  refresh: () => Promise<void>;
}

export function useDeliveryTracking(deliveryId: string): UseDeliveryTrackingResult {
  const [delivery, setDelivery] = useState<DeliveryInfo | null>(null);
  const [driverLocation, setDriverLocation] = useState<DriverLocation | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttempts = useRef(0);

  const fetchDelivery = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const data = await getDeliveryInfo(deliveryId);

      if (!data) {
        setError('Delivery not found');
        return;
      }

      setDelivery(data);

      // Set initial driver location if available
      if (data.driver?.lat && data.driver?.lng) {
        setDriverLocation({
          lat: data.driver.lat,
          lng: data.driver.lng,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (err: any) {
      setError(err.message || 'Failed to load delivery');
    } finally {
      setIsLoading(false);
    }
  }, [deliveryId]);

  const connectWebSocket = useCallback(() => {
    if (!deliveryId) return;

    // Customer tracking doesn't require auth token - delivery ID is the "auth"
    const wsUrl = `${WS_URL}/ws/delivery/${deliveryId}/track/`;

    const ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      setIsConnected(true);
      reconnectAttempts.current = 0;
      console.log('Tracking WebSocket connected');
    };

    ws.onclose = () => {
      setIsConnected(false);
      wsRef.current = null;

      // Reconnect with exponential backoff
      const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
      reconnectAttempts.current++;

      reconnectTimeoutRef.current = setTimeout(connectWebSocket, delay);
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.type === 'delivery_info') {
          // Initial delivery info from server
          setDelivery(data.delivery);
          if (data.delivery.driver?.lat && data.delivery.driver?.lng) {
            setDriverLocation({
              lat: data.delivery.driver.lat,
              lng: data.delivery.driver.lng,
              timestamp: new Date().toISOString(),
            });
          }
        } else if (data.type === 'driver_location') {
          // Real-time location update
          setDriverLocation({
            lat: data.lat,
            lng: data.lng,
            heading: data.heading,
            timestamp: data.timestamp,
          });
        } else if (data.type === 'status_update') {
          // Status change - refetch full delivery
          fetchDelivery();
        }
      } catch (err) {
        console.error('Failed to parse WebSocket message:', err);
      }
    };

    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
    };

    wsRef.current = ws;
  }, [deliveryId, fetchDelivery]);

  // Initial load and WebSocket connection
  useEffect(() => {
    fetchDelivery();
    connectWebSocket();

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [fetchDelivery, connectWebSocket]);

  return {
    delivery,
    driverLocation,
    isLoading,
    isConnected,
    error,
    refresh: fetchDelivery,
  };
}
```
  </action>
  <verify>
    - delivery-api.ts has getDeliveryInfo function
    - useDeliveryTracking hook connects to WebSocket
    - Hook handles location updates and status changes
    - Reconnection logic with exponential backoff implemented
  </verify>
  <done>Delivery tracking hook with WebSocket for real-time location updates created</done>
</task>

<task type="auto">
  <name>Task 2: Create tracking page components</name>
  <files>
    apps/pwa/src/components/delivery/TrackingMap.tsx
    apps/pwa/src/components/delivery/DriverInfo.tsx
    apps/pwa/src/components/delivery/DeliveryTimeline.tsx
    apps/pwa/src/components/delivery/DeliveryHeader.tsx
  </files>
  <action>
Create apps/pwa/src/components/delivery/TrackingMap.tsx:
```tsx
/**
 * Map component for delivery tracking.
 * Uses Google Maps API via script tag (lightweight alternative to @react-google-maps/api).
 */
'use client';

import { useEffect, useRef, useState } from 'react';

interface Location {
  lat: number;
  lng: number;
}

interface TrackingMapProps {
  driverLocation: Location | null;
  deliveryLocation: Location;
  restaurantLocation?: Location;
}

declare global {
  interface Window {
    google: typeof google;
    initMap: () => void;
  }
}

export default function TrackingMap({
  driverLocation,
  deliveryLocation,
  restaurantLocation,
}: TrackingMapProps) {
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstanceRef = useRef<google.maps.Map | null>(null);
  const driverMarkerRef = useRef<google.maps.Marker | null>(null);
  const [isLoaded, setIsLoaded] = useState(false);

  // Load Google Maps script
  useEffect(() => {
    if (window.google) {
      setIsLoaded(true);
      return;
    }

    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;
    if (!apiKey) {
      console.warn('Google Maps API key not configured');
      return;
    }

    window.initMap = () => setIsLoaded(true);

    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap`;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);

    return () => {
      delete window.initMap;
    };
  }, []);

  // Initialize map
  useEffect(() => {
    if (!isLoaded || !mapRef.current || mapInstanceRef.current) return;

    const center = driverLocation || deliveryLocation;

    const map = new google.maps.Map(mapRef.current, {
      center: { lat: center.lat, lng: center.lng },
      zoom: 15,
      disableDefaultUI: true,
      zoomControl: true,
      mapTypeControl: false,
      streetViewControl: false,
      fullscreenControl: false,
    });

    mapInstanceRef.current = map;

    // Add delivery location marker (red)
    new google.maps.Marker({
      position: deliveryLocation,
      map,
      icon: {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 10,
        fillColor: '#F44336',
        fillOpacity: 1,
        strokeColor: '#ffffff',
        strokeWeight: 2,
      },
      title: 'Delivery Location',
    });

    // Add restaurant marker (green) if available
    if (restaurantLocation) {
      new google.maps.Marker({
        position: restaurantLocation,
        map,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: '#4CAF50',
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 2,
        },
        title: 'Restaurant',
      });
    }

    // Create driver marker (will be updated)
    if (driverLocation) {
      driverMarkerRef.current = new google.maps.Marker({
        position: driverLocation,
        map,
        icon: {
          path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
          scale: 6,
          fillColor: '#2196F3',
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 2,
          rotation: 0,
        },
        title: 'Driver',
      });
    }
  }, [isLoaded, deliveryLocation, restaurantLocation]);

  // Update driver marker position
  useEffect(() => {
    if (!mapInstanceRef.current || !driverLocation) return;

    if (driverMarkerRef.current) {
      // Animate marker movement
      driverMarkerRef.current.setPosition(driverLocation);
    } else {
      // Create marker if not exists
      driverMarkerRef.current = new google.maps.Marker({
        position: driverLocation,
        map: mapInstanceRef.current,
        icon: {
          path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
          scale: 6,
          fillColor: '#2196F3',
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 2,
          rotation: 0,
        },
        title: 'Driver',
      });
    }

    // Pan map to keep driver in view
    mapInstanceRef.current.panTo(driverLocation);
  }, [driverLocation]);

  if (!isLoaded) {
    return (
      <div className="w-full h-64 bg-gray-100 rounded-lg flex items-center justify-center">
        <span className="text-gray-500">Loading map...</span>
      </div>
    );
  }

  return (
    <div ref={mapRef} className="w-full h-64 rounded-lg overflow-hidden shadow-md" />
  );
}
```

Create apps/pwa/src/components/delivery/DriverInfo.tsx:
```tsx
/**
 * Driver information card with contact options.
 */
'use client';

import { useTranslations } from 'next-intl';

interface DriverInfoProps {
  driver: {
    name: string;
    phone: string;
    vehicle_type: string;
  };
}

export default function DriverInfo({ driver }: DriverInfoProps) {
  const t = useTranslations('delivery');

  const vehicleLabels: Record<string, string> = {
    motorcycle: 'Motorcycle',
    bicycle: 'Bicycle',
    car: 'Car',
    foot: 'On Foot',
  };

  const handleCall = () => {
    window.location.href = `tel:${driver.phone}`;
  };

  const handleMessage = () => {
    // Use SMS on mobile, WhatsApp fallback
    const message = encodeURIComponent("Hi, I have a question about my delivery");
    window.location.href = `sms:${driver.phone}?body=${message}`;
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      <h3 className="text-sm font-medium text-gray-500 mb-3">
        {t('yourDriver', 'Your Driver')}
      </h3>

      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center">
            <span className="text-xl">
              {driver.vehicle_type === 'motorcycle' ? 'üèçÔ∏è' :
               driver.vehicle_type === 'bicycle' ? 'üö≤' :
               driver.vehicle_type === 'car' ? 'üöó' : 'üö∂'}
            </span>
          </div>
          <div>
            <p className="font-semibold">{driver.name}</p>
            <p className="text-sm text-gray-500">
              {vehicleLabels[driver.vehicle_type] || driver.vehicle_type}
            </p>
          </div>
        </div>

        <div className="flex space-x-2">
          <button
            onClick={handleCall}
            className="p-3 bg-green-500 text-white rounded-full hover:bg-green-600 transition-colors"
            aria-label={t('callDriver', 'Call driver')}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path d="M2 3a1 1 0 011-1h2.153a1 1 0 01.986.836l.74 4.435a1 1 0 01-.54 1.06l-1.548.773a11.037 11.037 0 006.105 6.105l.774-1.548a1 1 0 011.059-.54l4.435.74a1 1 0 01.836.986V17a1 1 0 01-1 1h-2C7.82 18 2 12.18 2 5V3z" />
            </svg>
          </button>
          <button
            onClick={handleMessage}
            className="p-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition-colors"
            aria-label={t('messageDriver', 'Message driver')}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clipRule="evenodd" />
            </svg>
          </button>
        </div>
      </div>
    </div>
  );
}
```

Create apps/pwa/src/components/delivery/DeliveryTimeline.tsx:
```tsx
/**
 * Delivery status timeline showing progress.
 */
'use client';

import { useTranslations } from 'next-intl';

interface DeliveryTimelineProps {
  status: string;
  assignedAt?: string;
  pickedUpAt?: string;
  enRouteAt?: string;
  deliveredAt?: string;
}

const STATUSES = ['assigned', 'picked_up', 'en_route', 'delivered'];

export default function DeliveryTimeline({
  status,
  assignedAt,
  pickedUpAt,
  enRouteAt,
  deliveredAt,
}: DeliveryTimelineProps) {
  const t = useTranslations('delivery');

  const statusLabels: Record<string, string> = {
    pending_assignment: t('statusPending', 'Finding driver...'),
    assigned: t('statusAssigned', 'Driver assigned'),
    picked_up: t('statusPickedUp', 'Order picked up'),
    en_route: t('statusEnRoute', 'On the way'),
    delivered: t('statusDelivered', 'Delivered'),
  };

  const timestamps: Record<string, string | undefined> = {
    assigned: assignedAt,
    picked_up: pickedUpAt,
    en_route: enRouteAt,
    delivered: deliveredAt,
  };

  const formatTime = (isoString?: string) => {
    if (!isoString) return '';
    return new Date(isoString).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const currentIndex = STATUSES.indexOf(status);

  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      <h3 className="text-sm font-medium text-gray-500 mb-4">
        {t('deliveryProgress', 'Delivery Progress')}
      </h3>

      <div className="space-y-4">
        {STATUSES.map((s, index) => {
          const isComplete = index < currentIndex || status === 'delivered';
          const isCurrent = s === status;

          return (
            <div key={s} className="flex items-start">
              {/* Status indicator */}
              <div className="flex flex-col items-center mr-4">
                <div
                  className={`w-6 h-6 rounded-full flex items-center justify-center ${
                    isComplete || isCurrent
                      ? 'bg-green-500 text-white'
                      : 'bg-gray-200 text-gray-400'
                  }`}
                >
                  {isComplete ? (
                    <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                      <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                  ) : (
                    <span className="text-xs">{index + 1}</span>
                  )}
                </div>
                {index < STATUSES.length - 1 && (
                  <div
                    className={`w-0.5 h-8 mt-1 ${
                      index < currentIndex ? 'bg-green-500' : 'bg-gray-200'
                    }`}
                  />
                )}
              </div>

              {/* Status text */}
              <div className="flex-1 pb-4">
                <p
                  className={`font-medium ${
                    isComplete || isCurrent ? 'text-gray-900' : 'text-gray-400'
                  }`}
                >
                  {statusLabels[s]}
                </p>
                {timestamps[s] && (
                  <p className="text-sm text-gray-500">{formatTime(timestamps[s])}</p>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

Create apps/pwa/src/components/delivery/DeliveryHeader.tsx:
```tsx
/**
 * Header component for delivery tracking page.
 */
'use client';

import { useTranslations } from 'next-intl';

interface DeliveryHeaderProps {
  orderNumber: number;
  estimatedTime?: string;
  status: string;
}

export default function DeliveryHeader({
  orderNumber,
  estimatedTime,
  status,
}: DeliveryHeaderProps) {
  const t = useTranslations('delivery');

  const formatEta = (isoString?: string) => {
    if (!isoString) return null;
    const date = new Date(isoString);
    return date.toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const eta = formatEta(estimatedTime);

  const statusMessages: Record<string, string> = {
    pending_assignment: t('findingDriver', 'Finding a driver for your order...'),
    assigned: t('driverAssigned', 'A driver has been assigned to your order'),
    picked_up: t('orderPickedUp', 'Your order has been picked up'),
    en_route: t('onTheWay', 'Your order is on the way!'),
    delivered: t('orderDelivered', 'Your order has been delivered'),
  };

  return (
    <div className="bg-green-500 text-white p-6 rounded-b-3xl shadow-lg">
      <div className="flex justify-between items-start mb-4">
        <div>
          <p className="text-green-100 text-sm">
            {t('order', 'Order')} #{orderNumber}
          </p>
          <h1 className="text-2xl font-bold">
            {statusMessages[status] || status}
          </h1>
        </div>
        {status === 'en_route' && eta && (
          <div className="text-right">
            <p className="text-green-100 text-sm">{t('eta', 'ETA')}</p>
            <p className="text-2xl font-bold">{eta}</p>
          </div>
        )}
      </div>

      {status === 'delivered' && (
        <div className="bg-green-600 rounded-lg p-3 text-center">
          <span className="text-lg">Thank you for your order!</span>
        </div>
      )}
    </div>
  );
}
```
  </action>
  <verify>
    - TrackingMap loads Google Maps and shows markers
    - DriverInfo has call and message buttons with proper links
    - DeliveryTimeline shows progress through statuses
    - DeliveryHeader shows order info and ETA
  </verify>
  <done>Tracking page components created: map, driver info, timeline, and header</done>
</task>

<task type="auto">
  <name>Task 3: Create tracking page and public API endpoint</name>
  <files>
    apps/pwa/src/app/[locale]/track/[id]/page.tsx
    apps/api/apps/delivery/views.py
    apps/api/apps/delivery/urls.py
  </files>
  <action>
Create apps/pwa/src/app/[locale]/track/[id]/page.tsx:
```tsx
/**
 * Customer delivery tracking page.
 *
 * URL: /track/{delivery_id}
 * No authentication required - delivery ID serves as the "key".
 */
'use client';

import { useParams } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { useDeliveryTracking } from '@/hooks/useDeliveryTracking';
import TrackingMap from '@/components/delivery/TrackingMap';
import DriverInfo from '@/components/delivery/DriverInfo';
import DeliveryTimeline from '@/components/delivery/DeliveryTimeline';
import DeliveryHeader from '@/components/delivery/DeliveryHeader';

export default function TrackingPage() {
  const params = useParams();
  const deliveryId = params.id as string;
  const t = useTranslations('delivery');

  const {
    delivery,
    driverLocation,
    isLoading,
    isConnected,
    error,
  } = useDeliveryTracking(deliveryId);

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-500 mx-auto mb-4" />
          <p className="text-gray-500">{t('loading', 'Loading...')}</p>
        </div>
      </div>
    );
  }

  if (error || !delivery) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
        <div className="text-center">
          <div className="text-6xl mb-4">üì¶</div>
          <h1 className="text-xl font-bold text-gray-800 mb-2">
            {t('notFound', 'Delivery not found')}
          </h1>
          <p className="text-gray-500">
            {t('notFoundDesc', 'This tracking link may have expired or the delivery does not exist.')}
          </p>
        </div>
      </div>
    );
  }

  const deliveryLocation = {
    lat: delivery.delivery_lat,
    lng: delivery.delivery_lng,
  };

  const restaurantLocation = delivery.restaurant?.lat && delivery.restaurant?.lng
    ? { lat: delivery.restaurant.lat, lng: delivery.restaurant.lng }
    : undefined;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <DeliveryHeader
        orderNumber={delivery.order_number}
        estimatedTime={delivery.estimated_delivery_time || undefined}
        status={delivery.status}
      />

      {/* Content */}
      <div className="p-4 space-y-4 -mt-4">
        {/* Connection status indicator */}
        {!isConnected && delivery.status !== 'delivered' && (
          <div className="bg-yellow-100 text-yellow-800 px-4 py-2 rounded-lg text-sm text-center">
            {t('reconnecting', 'Reconnecting for live updates...')}
          </div>
        )}

        {/* Map - only show for active deliveries with driver */}
        {delivery.driver && delivery.status !== 'delivered' && (
          <TrackingMap
            driverLocation={driverLocation}
            deliveryLocation={deliveryLocation}
            restaurantLocation={restaurantLocation}
          />
        )}

        {/* Driver info - show when driver is assigned */}
        {delivery.driver && (
          <DriverInfo driver={delivery.driver} />
        )}

        {/* Delivery address */}
        <div className="bg-white rounded-lg shadow-md p-4">
          <h3 className="text-sm font-medium text-gray-500 mb-2">
            {t('deliveryAddress', 'Delivery Address')}
          </h3>
          <p className="text-gray-900">{delivery.delivery_address}</p>
        </div>

        {/* Status timeline */}
        <DeliveryTimeline
          status={delivery.status}
          assignedAt={delivery.assigned_at}
          pickedUpAt={delivery.picked_up_at}
          enRouteAt={delivery.en_route_at}
          deliveredAt={delivery.delivered_at}
        />

        {/* Restaurant info */}
        {delivery.restaurant && (
          <div className="bg-white rounded-lg shadow-md p-4">
            <h3 className="text-sm font-medium text-gray-500 mb-2">
              {t('restaurant', 'Restaurant')}
            </h3>
            <p className="font-medium">{delivery.restaurant.name}</p>
            <p className="text-sm text-gray-500">{delivery.restaurant.address}</p>
          </div>
        )}
      </div>
    </div>
  );
}
```

Add public tracking endpoint to apps/api/apps/delivery/views.py:
```python
# Add to imports
from rest_framework.permissions import AllowAny
from rest_framework.views import APIView

# Add this view class
class DeliveryTrackingView(APIView):
    """
    Public endpoint for customer delivery tracking.

    GET /api/v1/delivery/track/{delivery_id}/

    No authentication required - delivery ID serves as access key.
    """

    permission_classes = [AllowAny]

    def get(self, request, delivery_id):
        try:
            delivery = Delivery.all_objects.select_related(
                'driver__user', 'zone', 'order__restaurant'
            ).get(id=delivery_id)
        except Delivery.DoesNotExist:
            return Response(
                {'error': 'Delivery not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        # Build response with necessary tracking info
        data = {
            'id': str(delivery.id),
            'status': delivery.status,
            'delivery_address': delivery.delivery_address,
            'delivery_lat': delivery.delivery_location.y if delivery.delivery_location else None,
            'delivery_lng': delivery.delivery_location.x if delivery.delivery_location else None,
            'estimated_delivery_time': (
                delivery.estimated_delivery_time.isoformat()
                if delivery.estimated_delivery_time else None
            ),
            'customer_name': delivery.customer_name,
            'customer_phone': delivery.customer_phone,
            'delivery_fee': delivery.delivery_fee,
            'order_number': delivery.order.order_number,
            'created_at': delivery.created_at.isoformat(),
            'assigned_at': delivery.assigned_at.isoformat() if delivery.assigned_at else None,
            'picked_up_at': delivery.picked_up_at.isoformat() if delivery.picked_up_at else None,
            'en_route_at': delivery.en_route_at.isoformat() if delivery.en_route_at else None,
            'delivered_at': delivery.delivered_at.isoformat() if delivery.delivered_at else None,
        }

        # Add driver info if assigned
        if delivery.driver:
            data['driver'] = {
                'name': delivery.driver.user.name,
                'phone': delivery.driver.phone,
                'vehicle_type': delivery.driver.vehicle_type,
            }
            if delivery.driver.current_location:
                data['driver']['lat'] = delivery.driver.current_location.y
                data['driver']['lng'] = delivery.driver.current_location.x

        # Add restaurant info
        restaurant = delivery.order.restaurant
        data['restaurant'] = {
            'name': restaurant.name,
            'phone': restaurant.phone,
            'address': restaurant.address,
        }
        if restaurant.latitude and restaurant.longitude:
            data['restaurant']['lat'] = float(restaurant.latitude)
            data['restaurant']['lng'] = float(restaurant.longitude)

        return Response(data)
```

Update apps/api/apps/delivery/urls.py:
```python
"""URL configuration for delivery API."""

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import DeliveryZoneViewSet, DriverViewSet, DeliveryViewSet, DeliveryTrackingView

router = DefaultRouter()
router.register('zones', DeliveryZoneViewSet, basename='deliveryzone')
router.register('drivers', DriverViewSet, basename='driver')
router.register('deliveries', DeliveryViewSet, basename='delivery')

urlpatterns = [
    path('track/<uuid:delivery_id>/', DeliveryTrackingView.as_view(), name='delivery-track'),
    path('', include(router.urls)),
]
```
  </action>
  <verify>
    - Tracking page loads delivery info via API
    - WebSocket connection established for real-time updates
    - Map shows driver, delivery, and restaurant locations
    - Driver contact buttons work
    - Public tracking API returns delivery info without auth
  </verify>
  <done>Tracking page and public API endpoint created</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Customer delivery tracking page in PWA with real-time map, driver info, status timeline, and contact options</what-built>
  <how-to-verify>
1. Start the API server: `docker compose up api`
2. Start the PWA: `cd apps/pwa && npm run dev`
3. Create a test delivery (via API or admin):
   - Create an order with order_type='delivery'
   - Create a delivery with customer address
   - Assign a driver to the delivery

4. Open tracking page in browser:
   - Navigate to http://localhost:3000/fr/track/{delivery_id}
   - Verify:
     - Header shows order number and status
     - Map loads with delivery location marker
     - If driver assigned: driver info card with call/message buttons
     - Timeline shows delivery progress
     - Restaurant info displayed

5. Test real-time updates:
   - Keep tracking page open
   - Update driver location via API or WebSocket
   - Verify map marker moves to new position

6. **Test contact links on mobile devices:**
   - Open tracking page on iOS device/simulator
   - Test tel: link - should open Phone app
   - Test sms: link - should open Messages app
   - Open tracking page on Android device/emulator
   - Test tel: link - should open dialer
   - Test sms: link - should open messaging app
   - Consider adding WhatsApp fallback if SMS unreliable:
     - `https://wa.me/{phone}?text={message}` as alternative

Note: Google Maps API key needed in .env.local for map to render:
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=your_key_here
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. PWA builds without errors: `cd apps/pwa && npm run build`
2. Tracking page renders at /track/{id}
3. WebSocket connects and receives location updates
4. Map shows correct markers and updates in real-time
5. Driver contact buttons link to tel: and sms:
6. Public API endpoint returns delivery info without auth
</verification>

<success_criteria>
- [ ] Delivery tracking hook with WebSocket created
- [ ] Map component with Google Maps integration
- [ ] Driver info card with contact buttons
- [ ] Status timeline showing delivery progress
- [ ] Tracking page assembles all components
- [ ] Public API endpoint for tracking data
- [ ] Human verification of tracking functionality
- [ ] Contact links tested on iOS and Android
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery/05-04-SUMMARY.md`
</output>
