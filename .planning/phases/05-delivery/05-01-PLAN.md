---
phase: 05-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/apps/delivery/__init__.py
  - apps/api/apps/delivery/apps.py
  - apps/api/apps/delivery/models.py
  - apps/api/apps/delivery/serializers.py
  - apps/api/apps/delivery/views.py
  - apps/api/apps/delivery/urls.py
  - apps/api/apps/delivery/admin.py
  - apps/api/apps/delivery/migrations/0001_initial.py
  - apps/api/apps/delivery/tests/__init__.py
  - apps/api/apps/delivery/tests/conftest.py
  - apps/api/apps/delivery/tests/factories.py
  - apps/api/apps/delivery/tests/test_zones.py
  - apps/api/apps/delivery/tests/test_drivers.py
  - apps/api/apps/authentication/models.py
  - apps/api/requirements/base.txt
  - apps/api/config/settings/base.py
  - apps/api/config/urls.py
autonomous: true

must_haves:
  truths:
    - "Manager can create delivery zones with polygon boundaries"
    - "Manager can set delivery fees and minimum order per zone"
    - "System can check if an address is within a delivery zone"
    - "Driver profile exists linked to user with driver role"
    - "Driver can toggle availability (online/offline)"
  artifacts:
    - path: "apps/api/apps/delivery/models.py"
      provides: "DeliveryZone, Driver models with GeoDjango fields"
      contains: "PolygonField"
    - path: "apps/api/apps/delivery/views.py"
      provides: "Zone and Driver API endpoints"
      exports: ["DeliveryZoneViewSet", "DriverViewSet"]
    - path: "apps/api/apps/delivery/serializers.py"
      provides: "GeoJSON serializers for zones"
      contains: "GeoFeatureModelSerializer"
  key_links:
    - from: "apps/api/apps/delivery/views.py"
      to: "apps/api/apps/delivery/models.py"
      via: "DeliveryZone.objects.filter(polygon__contains=point)"
      pattern: "polygon__contains"
    - from: "apps/api/apps/delivery/models.py"
      to: "apps/api/apps/authentication/models.py"
      via: "Driver.user FK"
      pattern: "ForeignKey.*User"
---

<objective>
Create delivery app foundation with GeoDjango models for delivery zones and drivers

Purpose: Enable restaurants to define delivery areas with polygon boundaries and manage driver availability. This is the foundation for the entire delivery system.

Output:
- DeliveryZone model with PostGIS PolygonField for boundary geometry
- Driver model with PointField for real-time location tracking
- REST API endpoints for zone CRUD and address checking
- REST API endpoints for driver management and availability toggle
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery/05-RESEARCH.md

# Prior patterns
@apps/api/apps/core/models.py
@apps/api/apps/core/views.py
@apps/api/apps/authentication/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install GeoDjango dependencies and create delivery app</name>
  <files>
    apps/api/requirements/base.txt
    apps/api/config/settings/base.py
    apps/api/apps/delivery/__init__.py
    apps/api/apps/delivery/apps.py
  </files>
  <action>
1. Add to requirements/base.txt:
   ```
   djangorestframework-gis>=1.1.0
   ```

2. Update config/settings/base.py:
   - Add 'django.contrib.gis' to INSTALLED_APPS (before other apps)
   - Add 'apps.delivery' to INSTALLED_APPS
   - Change DATABASES ENGINE from 'django.db.backends.postgresql' to 'django.contrib.gis.db.backends.postgis'

3. Create apps/delivery directory with:
   - __init__.py (empty)
   - apps.py with DeliveryConfig (name='apps.delivery')

4. Update Restaurant model in authentication/models.py to add location fields:
   ```python
   # Add these fields to Restaurant model
   latitude = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
   longitude = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
   ```

Note: PostGIS extension must be enabled on the database. For local dev, this is handled by the Docker PostgreSQL image. For Render, ensure PostGIS addon is enabled.
  </action>
  <verify>
    - requirements/base.txt contains djangorestframework-gis
    - settings/base.py has django.contrib.gis and apps.delivery in INSTALLED_APPS
    - settings/base.py uses postgis backend
    - apps/delivery/apps.py exists with DeliveryConfig
    - Run: `docker compose exec db psql -U postgres -c '\dx'` to confirm postgis extension is installed
  </verify>
  <done>GeoDjango configured with PostGIS backend, delivery app scaffolded, Restaurant has lat/lng fields</done>
</task>

<task type="auto">
  <name>Task 2: Create DeliveryZone and Driver models with GeoDjango fields</name>
  <files>
    apps/api/apps/delivery/models.py
    apps/api/apps/delivery/admin.py
    apps/api/apps/delivery/migrations/0001_initial.py
  </files>
  <action>
Create apps/delivery/models.py with:

```python
"""Delivery models for RESTO360."""

from django.contrib.gis.db import models as gis_models
from django.contrib.gis.geos import Point
from django.db import models
from django.utils import timezone

from apps.core.managers import TenantManager
from apps.core.models import TenantModel


class DeliveryZone(TenantModel):
    """
    Delivery zone with polygon boundary.

    Uses PostGIS geography type for automatic meter-based distance calculations.
    """

    name = models.CharField(max_length=100)
    # geography=True for lat/lng with distances in meters
    polygon = gis_models.PolygonField(geography=True, srid=4326)
    delivery_fee = models.PositiveIntegerField(
        help_text="Delivery fee in XOF"
    )
    minimum_order = models.PositiveIntegerField(
        default=0,
        help_text="Minimum order amount in XOF"
    )
    estimated_time_minutes = models.PositiveIntegerField(
        default=30,
        help_text="Base estimated delivery time in minutes"
    )
    is_active = models.BooleanField(default=True)

    all_objects = models.Manager()
    objects = TenantManager()

    class Meta:
        ordering = ['name']

    def __str__(self):
        return f"{self.name} ({self.restaurant.name})"

    def contains_point(self, lat: float, lng: float) -> bool:
        """Check if a point is within this zone."""
        # GIS uses (lng, lat) order!
        point = Point(lng, lat, srid=4326)
        return self.polygon.contains(point)

    @classmethod
    def find_zone_for_location(cls, restaurant, lat: float, lng: float):
        """Find the delivery zone containing a location."""
        point = Point(lng, lat, srid=4326)
        return cls.objects.filter(
            restaurant=restaurant,
            polygon__contains=point,
            is_active=True
        ).first()


class VehicleType(models.TextChoices):
    """Driver vehicle type enumeration."""
    MOTORCYCLE = "motorcycle", "Motorcycle"
    BICYCLE = "bicycle", "Bicycle"
    CAR = "car", "Car"
    FOOT = "foot", "On Foot"


class Driver(TenantModel):
    """
    Delivery driver with real-time location tracking.

    Linked to User model (role must be 'driver').
    """

    user = models.OneToOneField(
        'authentication.User',
        on_delete=models.CASCADE,
        related_name='driver_profile',
        limit_choices_to={'role': 'driver'}
    )
    phone = models.CharField(
        max_length=20,
        help_text="Driver contact phone (may differ from user phone)"
    )
    vehicle_type = models.CharField(
        max_length=20,
        choices=VehicleType.choices,
        default=VehicleType.MOTORCYCLE
    )
    vehicle_plate = models.CharField(
        max_length=20,
        blank=True,
        help_text="License plate number"
    )

    # Availability status
    is_available = models.BooleanField(default=False)
    went_online_at = models.DateTimeField(null=True, blank=True)

    # Current location (updated in real-time)
    current_location = gis_models.PointField(
        geography=True,
        srid=4326,
        null=True,
        blank=True
    )
    location_updated_at = models.DateTimeField(null=True, blank=True)

    # Stats
    total_deliveries = models.PositiveIntegerField(default=0)
    average_rating = models.DecimalField(
        max_digits=3,
        decimal_places=2,
        default=5.00
    )

    all_objects = models.Manager()
    objects = TenantManager()

    class Meta:
        ordering = ['user__name']

    def __str__(self):
        return f"{self.user.name} ({self.vehicle_type})"

    def update_location(self, lat: float, lng: float):
        """Update driver's current location."""
        # GIS uses (lng, lat) order!
        self.current_location = Point(lng, lat, srid=4326)
        self.location_updated_at = timezone.now()
        self.save(update_fields=['current_location', 'location_updated_at'])

    def go_online(self):
        """Mark driver as available for deliveries."""
        self.is_available = True
        self.went_online_at = timezone.now()
        self.save(update_fields=['is_available', 'went_online_at'])

    def go_offline(self):
        """Mark driver as unavailable."""
        self.is_available = False
        self.went_online_at = None
        self.save(update_fields=['is_available', 'went_online_at'])
```

Create apps/delivery/admin.py with:
```python
"""Admin configuration for delivery models."""

from django.contrib.gis import admin
from .models import DeliveryZone, Driver


@admin.register(DeliveryZone)
class DeliveryZoneAdmin(admin.GISModelAdmin):
    """Admin for delivery zones with map widget."""
    list_display = ['name', 'restaurant', 'delivery_fee', 'minimum_order', 'is_active']
    list_filter = ['restaurant', 'is_active']
    search_fields = ['name', 'restaurant__name']


@admin.register(Driver)
class DriverAdmin(admin.GISModelAdmin):
    """Admin for drivers with location map."""
    list_display = ['user', 'restaurant', 'vehicle_type', 'is_available', 'total_deliveries']
    list_filter = ['restaurant', 'is_available', 'vehicle_type']
    search_fields = ['user__name', 'user__phone']
    readonly_fields = ['total_deliveries', 'average_rating', 'location_updated_at']
```

Run: `python manage.py makemigrations delivery` to generate migration.
  </action>
  <verify>
    - models.py contains DeliveryZone with PolygonField(geography=True)
    - models.py contains Driver with PointField(geography=True)
    - admin.py uses GISModelAdmin
    - Migration file generated successfully
  </verify>
  <done>DeliveryZone and Driver models created with PostGIS geography fields, admin configured with map widgets</done>
</task>

<task type="auto">
  <name>Task 3: Create serializers and API endpoints</name>
  <files>
    apps/api/apps/delivery/serializers.py
    apps/api/apps/delivery/views.py
    apps/api/apps/delivery/urls.py
    apps/api/config/urls.py
  </files>
  <action>
Create apps/delivery/serializers.py:
```python
"""Serializers for delivery API."""

from django.contrib.gis.geos import Point
from rest_framework import serializers
from rest_framework_gis.serializers import GeoFeatureModelSerializer

from .models import DeliveryZone, Driver


class DeliveryZoneSerializer(GeoFeatureModelSerializer):
    """
    Serialize DeliveryZone as GeoJSON Feature.

    Output format:
    {
      "type": "Feature",
      "geometry": { "type": "Polygon", "coordinates": [...] },
      "properties": { "id": "...", "name": "Zone A", ... }
    }
    """

    class Meta:
        model = DeliveryZone
        geo_field = 'polygon'
        id_field = 'id'
        fields = [
            'id', 'name', 'delivery_fee', 'minimum_order',
            'estimated_time_minutes', 'is_active', 'created_at', 'updated_at'
        ]


class DeliveryZoneListSerializer(serializers.ModelSerializer):
    """Simple list serializer without geometry for performance."""

    class Meta:
        model = DeliveryZone
        fields = [
            'id', 'name', 'delivery_fee', 'minimum_order',
            'estimated_time_minutes', 'is_active'
        ]


class CheckAddressSerializer(serializers.Serializer):
    """Serializer for address check request."""
    lat = serializers.FloatField(min_value=-90, max_value=90)
    lng = serializers.FloatField(min_value=-180, max_value=180)


class CheckAddressResponseSerializer(serializers.Serializer):
    """Serializer for address check response."""
    deliverable = serializers.BooleanField()
    zone = DeliveryZoneListSerializer(required=False, allow_null=True)
    message = serializers.CharField(required=False)


class DriverSerializer(serializers.ModelSerializer):
    """Serializer for Driver model."""

    user_name = serializers.CharField(source='user.name', read_only=True)
    user_phone = serializers.CharField(source='user.phone', read_only=True)
    latitude = serializers.SerializerMethodField()
    longitude = serializers.SerializerMethodField()

    class Meta:
        model = Driver
        fields = [
            'id', 'user', 'user_name', 'user_phone', 'phone',
            'vehicle_type', 'vehicle_plate', 'is_available',
            'went_online_at', 'latitude', 'longitude',
            'location_updated_at', 'total_deliveries', 'average_rating',
            'created_at', 'updated_at'
        ]
        read_only_fields = [
            'is_available', 'went_online_at', 'location_updated_at',
            'total_deliveries', 'average_rating'
        ]

    def get_latitude(self, obj):
        if obj.current_location:
            return obj.current_location.y  # GIS Point: x=lng, y=lat
        return None

    def get_longitude(self, obj):
        if obj.current_location:
            return obj.current_location.x
        return None


class DriverCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating a driver profile."""

    class Meta:
        model = Driver
        fields = ['user', 'phone', 'vehicle_type', 'vehicle_plate']

    def validate_user(self, value):
        """Ensure user has driver role and belongs to same restaurant."""
        if value.role != 'driver':
            raise serializers.ValidationError("User must have 'driver' role")

        request = self.context.get('request')
        if request and hasattr(request, 'restaurant'):
            if value.restaurant_id != request.restaurant.id:
                raise serializers.ValidationError("User must belong to same restaurant")

        return value


class DriverLocationUpdateSerializer(serializers.Serializer):
    """Serializer for driver location update."""
    lat = serializers.FloatField(min_value=-90, max_value=90)
    lng = serializers.FloatField(min_value=-180, max_value=180)
```

Create apps/delivery/views.py:
```python
"""Views for delivery API."""

from django.contrib.gis.geos import Point
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response

from apps.core.views import TenantModelViewSet
from .models import DeliveryZone, Driver
from .serializers import (
    DeliveryZoneSerializer,
    DeliveryZoneListSerializer,
    CheckAddressSerializer,
    CheckAddressResponseSerializer,
    DriverSerializer,
    DriverCreateSerializer,
    DriverLocationUpdateSerializer,
)


class DeliveryZoneViewSet(TenantModelViewSet):
    """
    ViewSet for delivery zone management.

    list: Return all zones (simple list without geometry)
    retrieve: Return single zone with full GeoJSON geometry
    create/update/delete: Manage zones
    check_address: Check if coordinates are within any delivery zone
    """

    serializer_class = DeliveryZoneSerializer

    def get_queryset(self):
        return DeliveryZone.objects.filter(restaurant=self.request.restaurant)

    def get_serializer_class(self):
        if self.action == 'list':
            return DeliveryZoneListSerializer
        return DeliveryZoneSerializer

    @action(detail=False, methods=['post'])
    def check_address(self, request):
        """
        Check if an address (lat/lng) is within any delivery zone.

        POST /api/v1/delivery/zones/check_address/
        Body: {"lat": 5.3364, "lng": -3.9667}

        Returns:
        - deliverable: true/false
        - zone: zone details if deliverable
        - message: explanation if not deliverable
        """
        serializer = CheckAddressSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        lat = serializer.validated_data['lat']
        lng = serializer.validated_data['lng']

        zone = DeliveryZone.find_zone_for_location(
            restaurant=request.restaurant,
            lat=lat,
            lng=lng
        )

        if zone:
            response_data = {
                'deliverable': True,
                'zone': DeliveryZoneListSerializer(zone).data,
            }
        else:
            response_data = {
                'deliverable': False,
                'zone': None,
                'message': 'Address is outside delivery area'
            }

        return Response(response_data)


class DriverViewSet(TenantModelViewSet):
    """
    ViewSet for driver management.

    list: Return all drivers for restaurant
    retrieve: Return single driver
    create: Create driver profile (links to existing user with driver role)
    toggle_availability: Go online/offline
    update_location: Update driver's current GPS position
    """

    serializer_class = DriverSerializer

    def get_queryset(self):
        return Driver.objects.filter(restaurant=self.request.restaurant)

    def get_serializer_class(self):
        if self.action == 'create':
            return DriverCreateSerializer
        return DriverSerializer

    @action(detail=True, methods=['post'])
    def toggle_availability(self, request, pk=None):
        """
        Toggle driver online/offline status.

        POST /api/v1/delivery/drivers/{id}/toggle_availability/
        """
        driver = self.get_object()

        if driver.is_available:
            driver.go_offline()
        else:
            driver.go_online()

        return Response(DriverSerializer(driver).data)

    @action(detail=True, methods=['post'])
    def update_location(self, request, pk=None):
        """
        Update driver's current location.

        POST /api/v1/delivery/drivers/{id}/update_location/
        Body: {"lat": 5.3364, "lng": -3.9667}
        """
        driver = self.get_object()

        serializer = DriverLocationUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        driver.update_location(
            lat=serializer.validated_data['lat'],
            lng=serializer.validated_data['lng']
        )

        return Response(DriverSerializer(driver).data)

    @action(detail=False, methods=['get'])
    def me(self, request):
        """
        Get current user's driver profile.

        GET /api/v1/delivery/drivers/me/
        """
        try:
            driver = Driver.objects.get(
                restaurant=request.restaurant,
                user=request.user
            )
            return Response(DriverSerializer(driver).data)
        except Driver.DoesNotExist:
            return Response(
                {'error': 'No driver profile found'},
                status=status.HTTP_404_NOT_FOUND
            )
```

Create apps/delivery/urls.py:
```python
"""URL configuration for delivery API."""

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import DeliveryZoneViewSet, DriverViewSet

router = DefaultRouter()
router.register('zones', DeliveryZoneViewSet, basename='deliveryzone')
router.register('drivers', DriverViewSet, basename='driver')

urlpatterns = [
    path('', include(router.urls)),
]
```

Update config/urls.py to include delivery routes:
```python
# Add to urlpatterns:
path('api/v1/delivery/', include('apps.delivery.urls')),
```
  </action>
  <verify>
    - serializers.py has GeoFeatureModelSerializer for zones
    - views.py has DeliveryZoneViewSet with check_address action
    - views.py has DriverViewSet with toggle_availability and update_location actions
    - urls.py registers both viewsets
    - config/urls.py includes delivery routes
  </verify>
  <done>REST API endpoints created for zones (CRUD + check_address) and drivers (CRUD + toggle + location)</done>
</task>

<task type="auto">
  <name>Task 4: Create comprehensive tests</name>
  <files>
    apps/api/apps/delivery/tests/__init__.py
    apps/api/apps/delivery/tests/conftest.py
    apps/api/apps/delivery/tests/factories.py
    apps/api/apps/delivery/tests/test_zones.py
    apps/api/apps/delivery/tests/test_drivers.py
  </files>
  <action>
Create apps/delivery/tests/__init__.py (empty).

Create apps/delivery/tests/conftest.py:
```python
"""Pytest configuration for delivery tests."""

import pytest


@pytest.fixture
def polygon_abidjan():
    """Sample polygon covering central Abidjan (Plateau district)."""
    # Approximate coordinates for Plateau, Abidjan
    return {
        "type": "Polygon",
        "coordinates": [[
            [-4.0200, 5.3200],  # SW corner
            [-4.0200, 5.3400],  # NW corner
            [-4.0000, 5.3400],  # NE corner
            [-4.0000, 5.3200],  # SE corner
            [-4.0200, 5.3200],  # Close polygon
        ]]
    }


@pytest.fixture
def point_inside_abidjan():
    """Point inside the Abidjan polygon."""
    return {"lat": 5.3300, "lng": -4.0100}


@pytest.fixture
def point_outside_abidjan():
    """Point outside the Abidjan polygon."""
    return {"lat": 5.4000, "lng": -3.9000}
```

Create apps/delivery/tests/factories.py:
```python
"""Factories for delivery tests."""

import factory
from django.contrib.gis.geos import Polygon, Point

from apps.authentication.tests.factories import RestaurantFactory, UserFactory
from apps.delivery.models import DeliveryZone, Driver


class DeliveryZoneFactory(factory.django.DjangoModelFactory):
    """Factory for DeliveryZone model."""

    class Meta:
        model = DeliveryZone

    restaurant = factory.SubFactory(RestaurantFactory)
    name = factory.Sequence(lambda n: f"Zone {n}")
    polygon = factory.LazyFunction(lambda: Polygon([
        (-4.02, 5.32),
        (-4.02, 5.34),
        (-4.00, 5.34),
        (-4.00, 5.32),
        (-4.02, 5.32),
    ], srid=4326))
    delivery_fee = 1500
    minimum_order = 5000
    estimated_time_minutes = 30
    is_active = True


class DriverFactory(factory.django.DjangoModelFactory):
    """Factory for Driver model."""

    class Meta:
        model = Driver

    restaurant = factory.SubFactory(RestaurantFactory)
    user = factory.SubFactory(
        UserFactory,
        role='driver',
        restaurant=factory.SelfAttribute('..restaurant')
    )
    phone = factory.LazyAttribute(lambda obj: obj.user.phone)
    vehicle_type = 'motorcycle'
    vehicle_plate = factory.Sequence(lambda n: f"AB-{n:04d}-CI")
    is_available = False
    current_location = None
```

Create apps/delivery/tests/test_zones.py:
```python
"""Tests for delivery zone models and API."""

import pytest
from django.contrib.gis.geos import Polygon, Point
from rest_framework import status

from apps.delivery.models import DeliveryZone
from .factories import DeliveryZoneFactory


@pytest.mark.django_db
class TestDeliveryZoneModel:
    """Tests for DeliveryZone model."""

    def test_create_zone(self, restaurant):
        """Test creating a delivery zone."""
        polygon = Polygon([
            (-4.02, 5.32),
            (-4.02, 5.34),
            (-4.00, 5.34),
            (-4.00, 5.32),
            (-4.02, 5.32),
        ], srid=4326)

        zone = DeliveryZone.objects.create(
            restaurant=restaurant,
            name="Central Zone",
            polygon=polygon,
            delivery_fee=1500,
            minimum_order=5000,
        )

        assert zone.id is not None
        assert zone.name == "Central Zone"
        assert zone.delivery_fee == 1500

    def test_contains_point_inside(self, restaurant, point_inside_abidjan):
        """Test point inside zone returns True."""
        zone = DeliveryZoneFactory(restaurant=restaurant)

        result = zone.contains_point(
            lat=point_inside_abidjan['lat'],
            lng=point_inside_abidjan['lng']
        )

        assert result is True

    def test_contains_point_outside(self, restaurant, point_outside_abidjan):
        """Test point outside zone returns False."""
        zone = DeliveryZoneFactory(restaurant=restaurant)

        result = zone.contains_point(
            lat=point_outside_abidjan['lat'],
            lng=point_outside_abidjan['lng']
        )

        assert result is False

    def test_find_zone_for_location(self, restaurant, point_inside_abidjan):
        """Test finding zone for a location."""
        zone = DeliveryZoneFactory(restaurant=restaurant)

        found = DeliveryZone.find_zone_for_location(
            restaurant=restaurant,
            lat=point_inside_abidjan['lat'],
            lng=point_inside_abidjan['lng']
        )

        assert found == zone

    def test_find_zone_for_location_outside(self, restaurant, point_outside_abidjan):
        """Test no zone found for location outside all zones."""
        DeliveryZoneFactory(restaurant=restaurant)

        found = DeliveryZone.find_zone_for_location(
            restaurant=restaurant,
            lat=point_outside_abidjan['lat'],
            lng=point_outside_abidjan['lng']
        )

        assert found is None

    def test_inactive_zone_not_found(self, restaurant, point_inside_abidjan):
        """Test inactive zones are not returned."""
        DeliveryZoneFactory(restaurant=restaurant, is_active=False)

        found = DeliveryZone.find_zone_for_location(
            restaurant=restaurant,
            lat=point_inside_abidjan['lat'],
            lng=point_inside_abidjan['lng']
        )

        assert found is None


@pytest.mark.django_db
class TestDeliveryZoneAPI:
    """Tests for delivery zone API endpoints."""

    def test_list_zones(self, auth_client, restaurant):
        """Test listing delivery zones."""
        DeliveryZoneFactory(restaurant=restaurant)
        DeliveryZoneFactory(restaurant=restaurant)

        response = auth_client.get('/api/v1/delivery/zones/')

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 2

    def test_list_zones_tenant_isolation(self, auth_client, restaurant):
        """Test zones are filtered by restaurant."""
        DeliveryZoneFactory(restaurant=restaurant)
        DeliveryZoneFactory()  # Different restaurant

        response = auth_client.get('/api/v1/delivery/zones/')

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 1

    def test_create_zone(self, auth_client, restaurant, polygon_abidjan):
        """Test creating a delivery zone via API."""
        data = {
            'name': 'New Zone',
            'polygon': polygon_abidjan,
            'delivery_fee': 2000,
            'minimum_order': 10000,
            'estimated_time_minutes': 45,
        }

        response = auth_client.post(
            '/api/v1/delivery/zones/',
            data,
            format='json'
        )

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['properties']['name'] == 'New Zone'
        assert response.data['properties']['delivery_fee'] == 2000

    def test_retrieve_zone_geojson(self, auth_client, restaurant):
        """Test retrieving zone returns GeoJSON."""
        zone = DeliveryZoneFactory(restaurant=restaurant)

        response = auth_client.get(f'/api/v1/delivery/zones/{zone.id}/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data['type'] == 'Feature'
        assert response.data['geometry']['type'] == 'Polygon'
        assert 'coordinates' in response.data['geometry']

    def test_check_address_deliverable(
        self, auth_client, restaurant, point_inside_abidjan
    ):
        """Test check_address returns zone when deliverable."""
        zone = DeliveryZoneFactory(restaurant=restaurant)

        response = auth_client.post(
            '/api/v1/delivery/zones/check_address/',
            point_inside_abidjan,
            format='json'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['deliverable'] is True
        assert response.data['zone']['id'] == str(zone.id)
        assert response.data['zone']['delivery_fee'] == zone.delivery_fee

    def test_check_address_not_deliverable(
        self, auth_client, restaurant, point_outside_abidjan
    ):
        """Test check_address returns not deliverable for outside address."""
        DeliveryZoneFactory(restaurant=restaurant)

        response = auth_client.post(
            '/api/v1/delivery/zones/check_address/',
            point_outside_abidjan,
            format='json'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['deliverable'] is False
        assert response.data['zone'] is None
        assert 'outside' in response.data['message'].lower()

    def test_check_address_validation(self, auth_client, restaurant):
        """Test check_address validates coordinates."""
        response = auth_client.post(
            '/api/v1/delivery/zones/check_address/',
            {'lat': 'invalid', 'lng': -4.0},
            format='json'
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
```

Create apps/delivery/tests/test_drivers.py:
```python
"""Tests for driver models and API."""

import pytest
from django.contrib.gis.geos import Point
from django.utils import timezone
from rest_framework import status

from apps.authentication.tests.factories import UserFactory
from apps.delivery.models import Driver
from .factories import DriverFactory


@pytest.mark.django_db
class TestDriverModel:
    """Tests for Driver model."""

    def test_create_driver(self, restaurant):
        """Test creating a driver."""
        user = UserFactory(restaurant=restaurant, role='driver')

        driver = Driver.objects.create(
            restaurant=restaurant,
            user=user,
            phone=user.phone,
            vehicle_type='motorcycle',
        )

        assert driver.id is not None
        assert driver.is_available is False
        assert driver.current_location is None

    def test_go_online(self, restaurant):
        """Test driver going online."""
        driver = DriverFactory(restaurant=restaurant)

        driver.go_online()

        assert driver.is_available is True
        assert driver.went_online_at is not None

    def test_go_offline(self, restaurant):
        """Test driver going offline."""
        driver = DriverFactory(restaurant=restaurant, is_available=True)
        driver.went_online_at = timezone.now()
        driver.save()

        driver.go_offline()

        assert driver.is_available is False
        assert driver.went_online_at is None

    def test_update_location(self, restaurant):
        """Test updating driver location."""
        driver = DriverFactory(restaurant=restaurant)

        driver.update_location(lat=5.33, lng=-4.01)

        assert driver.current_location is not None
        assert driver.current_location.y == 5.33  # GIS: y=lat
        assert driver.current_location.x == -4.01  # GIS: x=lng
        assert driver.location_updated_at is not None


@pytest.mark.django_db
class TestDriverAPI:
    """Tests for driver API endpoints."""

    def test_list_drivers(self, auth_client, restaurant):
        """Test listing drivers."""
        DriverFactory(restaurant=restaurant)
        DriverFactory(restaurant=restaurant)

        response = auth_client.get('/api/v1/delivery/drivers/')

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 2

    def test_list_drivers_tenant_isolation(self, auth_client, restaurant):
        """Test drivers are filtered by restaurant."""
        DriverFactory(restaurant=restaurant)
        DriverFactory()  # Different restaurant

        response = auth_client.get('/api/v1/delivery/drivers/')

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 1

    def test_create_driver(self, auth_client, restaurant):
        """Test creating a driver profile."""
        user = UserFactory(restaurant=restaurant, role='driver')

        data = {
            'user': str(user.id),
            'phone': '+225 07 00 00 00',
            'vehicle_type': 'motorcycle',
            'vehicle_plate': 'AB-1234-CI',
        }

        response = auth_client.post(
            '/api/v1/delivery/drivers/',
            data,
            format='json'
        )

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['user'] == str(user.id)
        assert response.data['vehicle_type'] == 'motorcycle'

    def test_create_driver_wrong_role(self, auth_client, restaurant):
        """Test creating driver for non-driver user fails."""
        user = UserFactory(restaurant=restaurant, role='cashier')

        data = {
            'user': str(user.id),
            'phone': user.phone,
            'vehicle_type': 'motorcycle',
        }

        response = auth_client.post(
            '/api/v1/delivery/drivers/',
            data,
            format='json'
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert 'driver' in str(response.data).lower()

    def test_toggle_availability_online(self, auth_client, restaurant):
        """Test toggling driver to online."""
        driver = DriverFactory(restaurant=restaurant, is_available=False)

        response = auth_client.post(
            f'/api/v1/delivery/drivers/{driver.id}/toggle_availability/'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['is_available'] is True
        assert response.data['went_online_at'] is not None

    def test_toggle_availability_offline(self, auth_client, restaurant):
        """Test toggling driver to offline."""
        driver = DriverFactory(restaurant=restaurant, is_available=True)

        response = auth_client.post(
            f'/api/v1/delivery/drivers/{driver.id}/toggle_availability/'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['is_available'] is False

    def test_update_location(self, auth_client, restaurant):
        """Test updating driver location."""
        driver = DriverFactory(restaurant=restaurant)

        response = auth_client.post(
            f'/api/v1/delivery/drivers/{driver.id}/update_location/',
            {'lat': 5.33, 'lng': -4.01},
            format='json'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['latitude'] == 5.33
        assert response.data['longitude'] == -4.01
        assert response.data['location_updated_at'] is not None

    def test_update_location_validation(self, auth_client, restaurant):
        """Test location update validates coordinates."""
        driver = DriverFactory(restaurant=restaurant)

        response = auth_client.post(
            f'/api/v1/delivery/drivers/{driver.id}/update_location/',
            {'lat': 100, 'lng': -4.01},  # Invalid latitude
            format='json'
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    def test_get_current_driver_profile(self, auth_client, restaurant, user):
        """Test getting current user's driver profile."""
        # Create driver profile for authenticated user
        user.role = 'driver'
        user.save()
        driver = Driver.objects.create(
            restaurant=restaurant,
            user=user,
            phone=user.phone,
        )

        response = auth_client.get('/api/v1/delivery/drivers/me/')

        assert response.status_code == status.HTTP_200_OK
        assert response.data['id'] == str(driver.id)

    def test_get_current_driver_profile_not_found(self, auth_client, restaurant):
        """Test getting driver profile when none exists."""
        response = auth_client.get('/api/v1/delivery/drivers/me/')

        assert response.status_code == status.HTTP_404_NOT_FOUND
```
  </action>
  <verify>
    - Run: `docker compose exec api pytest apps/delivery/tests/ -v`
    - All zone tests pass (model + API)
    - All driver tests pass (model + API)
    - Test count: approximately 25-30 tests
  </verify>
  <done>Comprehensive tests for zones (6 model + 7 API) and drivers (4 model + 9 API) passing</done>
</task>

</tasks>

<verification>
1. Run migrations: `docker compose exec api python manage.py migrate`
2. Run all delivery tests: `docker compose exec api pytest apps/delivery/tests/ -v`
3. Verify API endpoints manually:
   - GET /api/v1/delivery/zones/ returns empty list
   - POST /api/v1/delivery/zones/ creates zone
   - POST /api/v1/delivery/zones/check_address/ validates address
   - GET /api/v1/delivery/drivers/ returns empty list
   - POST /api/v1/delivery/drivers/{id}/toggle_availability/ works
</verification>

<success_criteria>
- [ ] GeoDjango configured with PostGIS backend
- [ ] DeliveryZone model with PolygonField(geography=True) created
- [ ] Driver model with PointField(geography=True) created
- [ ] Zone API endpoints working (CRUD + check_address)
- [ ] Driver API endpoints working (CRUD + toggle + location)
- [ ] All tests passing
- [ ] Restaurant model has latitude/longitude fields
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery/05-01-SUMMARY.md`
</output>
