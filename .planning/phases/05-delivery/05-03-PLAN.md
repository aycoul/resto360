---
phase: 05-delivery
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - apps/mobile/apps/driver/app.json
  - apps/mobile/apps/driver/package.json
  - apps/mobile/apps/driver/tsconfig.json
  - apps/mobile/apps/driver/stores/auth.ts
  - apps/mobile/apps/driver/services/api.ts
  - apps/mobile/apps/driver/services/location.ts
  - apps/mobile/apps/driver/hooks/useWebSocket.ts
  - apps/mobile/apps/driver/hooks/useDeliveries.ts
  - apps/mobile/apps/driver/app/_layout.tsx
  - apps/mobile/apps/driver/app/(auth)/login.tsx
  - apps/mobile/apps/driver/app/(main)/_layout.tsx
  - apps/mobile/apps/driver/app/(main)/index.tsx
  - apps/mobile/apps/driver/components/AvailabilityToggle.tsx
  - apps/mobile/apps/driver/components/DeliveryCard.tsx
autonomous: true

must_haves:
  truths:
    - "Driver can log in with phone and password"
    - "Driver can toggle online/offline availability"
    - "Driver can see list of assigned deliveries"
    - "Driver location is tracked and sent to server while online"
  artifacts:
    - path: "apps/mobile/apps/driver/app/(main)/index.tsx"
      provides: "Driver dashboard with stats and availability toggle"
      min_lines: 50
    - path: "apps/mobile/apps/driver/services/location.ts"
      provides: "Background location tracking service"
      contains: "TaskManager.defineTask"
    - path: "apps/mobile/apps/driver/stores/auth.ts"
      provides: "Auth state management with Zustand"
      contains: "useAuthStore"
  key_links:
    - from: "apps/mobile/apps/driver/services/location.ts"
      to: "WebSocket API"
      via: "Location updates sent via WebSocket"
      pattern: "location_update"
    - from: "apps/mobile/apps/driver/hooks/useDeliveries.ts"
      to: "/api/v1/delivery/deliveries/active/"
      via: "Fetch active deliveries"
      pattern: "deliveries/active"
---

<objective>
Create React Native driver mobile app foundation with Expo - project setup, services, and basic screens

Purpose: Set up the Expo project with all dependencies, create core services (auth, API, location tracking), and build the basic screens (login, dashboard, delivery list). This establishes the foundation for the driver mobile experience.

Output:
- Expo-based React Native app with proper configuration
- Auth store with secure token storage
- Background location tracking with expo-location and expo-task-manager
- Login screen, dashboard with availability toggle, and basic delivery list
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery/05-RESEARCH.md
@.planning/phases/05-delivery/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Expo project and install dependencies</name>
  <files>
    apps/mobile/apps/driver/app.json
    apps/mobile/apps/driver/package.json
    apps/mobile/apps/driver/tsconfig.json
  </files>
  <action>
Create the driver app directory structure:
```bash
mkdir -p apps/mobile/apps/driver
cd apps/mobile/apps/driver
```

Initialize Expo project:
```bash
npx create-expo-app@latest . --template blank-typescript
```

Install required dependencies:
```bash
npx expo install expo-location expo-task-manager react-native-maps expo-image-picker expo-linking react-native-signature-canvas react-native-webview @react-navigation/native @react-navigation/bottom-tabs expo-router expo-secure-store zustand
```

Update app.json:
```json
{
  "expo": {
    "name": "RESTO360 Driver",
    "slug": "resto360-driver",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "scheme": "resto360driver",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": false,
      "bundleIdentifier": "com.resto360.driver",
      "infoPlist": {
        "NSLocationAlwaysAndWhenInUseUsageDescription": "We need your location to track deliveries and assign you to nearby orders.",
        "NSLocationWhenInUseUsageDescription": "We need your location to show you on the map.",
        "NSLocationAlwaysUsageDescription": "We need your location to track deliveries even when the app is in the background.",
        "UIBackgroundModes": ["location", "fetch"]
      },
      "config": {
        "googleMapsApiKey": "YOUR_IOS_GOOGLE_MAPS_API_KEY"
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.resto360.driver",
      "permissions": [
        "ACCESS_COARSE_LOCATION",
        "ACCESS_FINE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "FOREGROUND_SERVICE",
        "FOREGROUND_SERVICE_LOCATION",
        "CAMERA"
      ],
      "config": {
        "googleMaps": {
          "apiKey": "YOUR_ANDROID_GOOGLE_MAPS_API_KEY"
        }
      }
    },
    "plugins": [
      [
        "expo-location",
        {
          "locationAlwaysAndWhenInUsePermission": "Allow RESTO360 Driver to use your location for delivery tracking.",
          "isAndroidBackgroundLocationEnabled": true,
          "isAndroidForegroundServiceEnabled": true
        }
      ],
      [
        "expo-image-picker",
        {
          "cameraPermission": "Allow RESTO360 Driver to take photos for delivery confirmation."
        }
      ],
      "expo-router"
    ],
    "extra": {
      "apiUrl": "https://api.resto360.com",
      "wsUrl": "wss://api.resto360.com"
    }
  }
}
```

Note: Google Maps API keys need to be configured. For development, use development builds instead of Expo Go.
  </action>
  <verify>
    - package.json contains all required dependencies
    - app.json has location permissions configured
    - app.json has Google Maps placeholder keys
  </verify>
  <done>Expo project created with all required dependencies for driver app</done>
</task>

<task type="auto">
  <name>Task 2: Create auth store, API service, and location service</name>
  <files>
    apps/mobile/apps/driver/stores/auth.ts
    apps/mobile/apps/driver/services/api.ts
    apps/mobile/apps/driver/services/location.ts
    apps/mobile/apps/driver/hooks/useWebSocket.ts
  </files>
  <action>
Create apps/mobile/apps/driver/stores/auth.ts:
```typescript
/**
 * Auth store using Zustand for state management.
 */
import { create } from 'zustand';
import * as SecureStore from 'expo-secure-store';

interface User {
  id: string;
  name: string;
  phone: string;
  role: string;
  restaurant_id: string;
}

interface Driver {
  id: string;
  phone: string;
  vehicle_type: string;
  is_available: boolean;
  total_deliveries: number;
  average_rating: number;
}

interface AuthState {
  user: User | null;
  driver: Driver | null;
  accessToken: string | null;
  refreshToken: string | null;
  isLoading: boolean;
  isAuthenticated: boolean;

  // Actions
  login: (phone: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  loadStoredAuth: () => Promise<void>;
  refreshAccessToken: () => Promise<void>;
  updateDriver: (driver: Partial<Driver>) => void;
}

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:8000';

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  driver: null,
  accessToken: null,
  refreshToken: null,
  isLoading: true,
  isAuthenticated: false,

  login: async (phone: string, password: string) => {
    set({ isLoading: true });

    try {
      // Get tokens
      const tokenResponse = await fetch(`${API_URL}/api/v1/auth/token/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phone, password }),
      });

      if (!tokenResponse.ok) {
        throw new Error('Invalid credentials');
      }

      const { access, refresh } = await tokenResponse.json();

      // Get user profile
      const userResponse = await fetch(`${API_URL}/api/v1/auth/me/`, {
        headers: { Authorization: `Bearer ${access}` },
      });

      if (!userResponse.ok) {
        throw new Error('Failed to get user profile');
      }

      const user = await userResponse.json();

      if (user.role !== 'driver') {
        throw new Error('This app is for drivers only');
      }

      // Get driver profile
      const driverResponse = await fetch(`${API_URL}/api/v1/delivery/drivers/me/`, {
        headers: { Authorization: `Bearer ${access}` },
      });

      let driver = null;
      if (driverResponse.ok) {
        driver = await driverResponse.json();
      }

      // Store tokens securely
      await SecureStore.setItemAsync('accessToken', access);
      await SecureStore.setItemAsync('refreshToken', refresh);
      await SecureStore.setItemAsync('user', JSON.stringify(user));
      if (driver) {
        await SecureStore.setItemAsync('driver', JSON.stringify(driver));
      }

      set({
        user,
        driver,
        accessToken: access,
        refreshToken: refresh,
        isAuthenticated: true,
        isLoading: false,
      });
    } catch (error) {
      set({ isLoading: false });
      throw error;
    }
  },

  logout: async () => {
    await SecureStore.deleteItemAsync('accessToken');
    await SecureStore.deleteItemAsync('refreshToken');
    await SecureStore.deleteItemAsync('user');
    await SecureStore.deleteItemAsync('driver');

    set({
      user: null,
      driver: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,
    });
  },

  loadStoredAuth: async () => {
    try {
      const accessToken = await SecureStore.getItemAsync('accessToken');
      const refreshToken = await SecureStore.getItemAsync('refreshToken');
      const userStr = await SecureStore.getItemAsync('user');
      const driverStr = await SecureStore.getItemAsync('driver');

      if (accessToken && userStr) {
        const user = JSON.parse(userStr);
        const driver = driverStr ? JSON.parse(driverStr) : null;

        set({
          accessToken,
          refreshToken,
          user,
          driver,
          isAuthenticated: true,
          isLoading: false,
        });
      } else {
        set({ isLoading: false });
      }
    } catch {
      set({ isLoading: false });
    }
  },

  refreshAccessToken: async () => {
    const { refreshToken } = get();
    if (!refreshToken) return;

    try {
      const response = await fetch(`${API_URL}/api/v1/auth/token/refresh/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refresh: refreshToken }),
      });

      if (response.ok) {
        const { access } = await response.json();
        await SecureStore.setItemAsync('accessToken', access);
        set({ accessToken: access });
      } else {
        // Refresh token invalid, logout
        await get().logout();
      }
    } catch {
      await get().logout();
    }
  },

  updateDriver: (updates: Partial<Driver>) => {
    const { driver } = get();
    if (driver) {
      const updated = { ...driver, ...updates };
      set({ driver: updated });
      SecureStore.setItemAsync('driver', JSON.stringify(updated));
    }
  },
}));
```

Create apps/mobile/apps/driver/services/api.ts:
```typescript
/**
 * API service for driver app.
 */
import { useAuthStore } from '../stores/auth';

const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:8000';

class ApiService {
  private getHeaders(): HeadersInit {
    const { accessToken } = useAuthStore.getState();
    return {
      'Content-Type': 'application/json',
      ...(accessToken && { Authorization: `Bearer ${accessToken}` }),
    };
  }

  private async handleResponse<T>(response: Response): Promise<T> {
    if (response.status === 401) {
      // Try to refresh token
      await useAuthStore.getState().refreshAccessToken();
      throw new Error('Unauthorized - please try again');
    }

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.detail || error.error || 'Request failed');
    }

    return response.json();
  }

  // Driver endpoints
  async toggleAvailability(driverId: string) {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/drivers/${driverId}/toggle_availability/`,
      {
        method: 'POST',
        headers: this.getHeaders(),
      }
    );
    return this.handleResponse(response);
  }

  async updateLocation(driverId: string, lat: number, lng: number) {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/drivers/${driverId}/update_location/`,
      {
        method: 'POST',
        headers: this.getHeaders(),
        body: JSON.stringify({ lat, lng }),
      }
    );
    return this.handleResponse(response);
  }

  async getDriverProfile() {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/drivers/me/`,
      { headers: this.getHeaders() }
    );
    return this.handleResponse(response);
  }

  // Delivery endpoints
  async getActiveDeliveries() {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/deliveries/active/`,
      { headers: this.getHeaders() }
    );
    return this.handleResponse(response);
  }

  async getDelivery(deliveryId: string) {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/deliveries/${deliveryId}/`,
      { headers: this.getHeaders() }
    );
    return this.handleResponse(response);
  }

  async updateDeliveryStatus(deliveryId: string, status: string, data?: Record<string, any>) {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/deliveries/${deliveryId}/update_status/`,
      {
        method: 'POST',
        headers: this.getHeaders(),
        body: JSON.stringify({ status, ...data }),
      }
    );
    return this.handleResponse(response);
  }

  async confirmDelivery(
    deliveryId: string,
    proofType: 'photo' | 'signature',
    proofData: string,
    recipientName?: string
  ) {
    const response = await fetch(
      `${API_URL}/api/v1/delivery/deliveries/${deliveryId}/confirm/`,
      {
        method: 'POST',
        headers: this.getHeaders(),
        body: JSON.stringify({
          proof_type: proofType,
          proof_data: proofData,
          recipient_name: recipientName,
        }),
      }
    );
    return this.handleResponse(response);
  }
}

export const api = new ApiService();
```

Create apps/mobile/apps/driver/services/location.ts:
```typescript
/**
 * Background location tracking service.
 */
import * as Location from 'expo-location';
import * as TaskManager from 'expo-task-manager';
import { useAuthStore } from '../stores/auth';

const LOCATION_TASK_NAME = 'driver-background-location';
const WS_URL = process.env.EXPO_PUBLIC_WS_URL || 'ws://localhost:8000';

let wsConnection: WebSocket | null = null;

// Define background task
TaskManager.defineTask(LOCATION_TASK_NAME, async ({ data, error }) => {
  if (error) {
    console.error('Location task error:', error);
    return;
  }

  if (data) {
    const { locations } = data as { locations: Location.LocationObject[] };
    const location = locations[0];

    if (location) {
      await sendLocationUpdate({
        lat: location.coords.latitude,
        lng: location.coords.longitude,
        accuracy: location.coords.accuracy,
        heading: location.coords.heading,
        speed: location.coords.speed,
        timestamp: location.timestamp,
      });
    }
  }
});

async function sendLocationUpdate(location: {
  lat: number;
  lng: number;
  accuracy: number | null;
  heading: number | null;
  speed: number | null;
  timestamp: number;
}) {
  // Send via WebSocket if connected
  if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
    wsConnection.send(JSON.stringify({
      type: 'location_update',
      ...location,
    }));
  }
}

export async function requestLocationPermissions(): Promise<boolean> {
  // Request foreground permission first
  const { status: foregroundStatus } = await Location.requestForegroundPermissionsAsync();
  if (foregroundStatus !== 'granted') {
    return false;
  }

  // Then request background permission
  const { status: backgroundStatus } = await Location.requestBackgroundPermissionsAsync();
  return backgroundStatus === 'granted';
}

export async function startLocationTracking(driverId: string): Promise<void> {
  const hasPermission = await requestLocationPermissions();
  if (!hasPermission) {
    throw new Error('Location permission not granted');
  }

  // Connect WebSocket for location updates
  const { accessToken } = useAuthStore.getState();
  const wsUrl = `${WS_URL}/ws/driver/${driverId}/location/?token=${accessToken}`;

  wsConnection = new WebSocket(wsUrl);

  wsConnection.onopen = () => {
    console.log('Location WebSocket connected');
  };

  wsConnection.onclose = () => {
    console.log('Location WebSocket closed');
  };

  wsConnection.onerror = (error) => {
    console.error('Location WebSocket error:', error);
  };

  // Start background location updates
  await Location.startLocationUpdatesAsync(LOCATION_TASK_NAME, {
    accuracy: Location.Accuracy.High,
    timeInterval: 5000,      // Every 5 seconds
    distanceInterval: 10,    // Or every 10 meters
    deferredUpdatesInterval: 5000,
    deferredUpdatesDistance: 10,
    foregroundService: {
      notificationTitle: 'Driver Active',
      notificationBody: 'Tracking your location for deliveries',
      notificationColor: '#4CAF50',
    },
    pausesUpdatesAutomatically: false,
    showsBackgroundLocationIndicator: true,
  });
}

export async function stopLocationTracking(): Promise<void> {
  // Stop background updates
  const isTracking = await TaskManager.isTaskRegisteredAsync(LOCATION_TASK_NAME);
  if (isTracking) {
    await Location.stopLocationUpdatesAsync(LOCATION_TASK_NAME);
  }

  // Close WebSocket
  if (wsConnection) {
    wsConnection.close();
    wsConnection = null;
  }
}

export async function getCurrentLocation(): Promise<Location.LocationObject> {
  const hasPermission = await requestLocationPermissions();
  if (!hasPermission) {
    throw new Error('Location permission not granted');
  }

  return Location.getCurrentPositionAsync({
    accuracy: Location.Accuracy.High,
  });
}

export function getWebSocketConnection(): WebSocket | null {
  return wsConnection;
}
```

Create apps/mobile/apps/driver/hooks/useWebSocket.ts:
```typescript
/**
 * Hook for WebSocket connections.
 */
import { useEffect, useState, useCallback, useRef } from 'react';
import { useAuthStore } from '../stores/auth';

const WS_URL = process.env.EXPO_PUBLIC_WS_URL || 'ws://localhost:8000';

interface UseWebSocketOptions {
  url: string;
  onMessage?: (data: any) => void;
  autoReconnect?: boolean;
}

export function useWebSocket({ url, onMessage, autoReconnect = true }: UseWebSocketOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttempts = useRef(0);

  const { accessToken } = useAuthStore();

  const connect = useCallback(() => {
    if (!accessToken) return;

    const fullUrl = `${WS_URL}${url}?token=${accessToken}`;
    const ws = new WebSocket(fullUrl);

    ws.onopen = () => {
      setIsConnected(true);
      reconnectAttempts.current = 0;
    };

    ws.onclose = () => {
      setIsConnected(false);
      wsRef.current = null;

      if (autoReconnect) {
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
        reconnectAttempts.current++;

        reconnectTimeoutRef.current = setTimeout(connect, delay);
      }
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        setLastMessage(data);
        onMessage?.(data);
      } catch {
        console.error('Failed to parse WebSocket message');
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    wsRef.current = ws;
  }, [url, accessToken, onMessage, autoReconnect]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    wsRef.current?.close();
    wsRef.current = null;
  }, []);

  const send = useCallback((data: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
    }
  }, []);

  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  return {
    isConnected,
    lastMessage,
    send,
    disconnect,
    reconnect: connect,
  };
}
```
  </action>
  <verify>
    - stores/auth.ts has login, logout, and token refresh
    - services/api.ts has all delivery endpoints
    - services/location.ts has background location with TaskManager
    - hooks/useWebSocket.ts has reconnection logic
  </verify>
  <done>Core services created: auth store, API client, location tracking, and WebSocket hook</done>
</task>

<task type="auto">
  <name>Task 3: Create app layout and basic screens</name>
  <files>
    apps/mobile/apps/driver/app/_layout.tsx
    apps/mobile/apps/driver/app/(auth)/login.tsx
    apps/mobile/apps/driver/app/(main)/_layout.tsx
    apps/mobile/apps/driver/app/(main)/index.tsx
    apps/mobile/apps/driver/hooks/useDeliveries.ts
    apps/mobile/apps/driver/components/DeliveryCard.tsx
    apps/mobile/apps/driver/components/AvailabilityToggle.tsx
  </files>
  <action>
Create apps/mobile/apps/driver/app/_layout.tsx:
```tsx
/**
 * Root layout with auth state handling.
 */
import { useEffect } from 'react';
import { Stack } from 'expo-router';
import { useAuthStore } from '../stores/auth';

export default function RootLayout() {
  const { isLoading, isAuthenticated, loadStoredAuth } = useAuthStore();

  useEffect(() => {
    loadStoredAuth();
  }, []);

  if (isLoading) {
    return null; // Or a splash screen
  }

  return (
    <Stack screenOptions={{ headerShown: false }}>
      {isAuthenticated ? (
        <Stack.Screen name="(main)" />
      ) : (
        <Stack.Screen name="(auth)/login" />
      )}
      <Stack.Screen name="delivery/[id]/navigate" options={{ headerShown: true, title: 'Navigation' }} />
      <Stack.Screen name="delivery/[id]/confirm" options={{ headerShown: true, title: 'Confirm Delivery' }} />
    </Stack>
  );
}
```

Create apps/mobile/apps/driver/app/(auth)/login.tsx:
```tsx
/**
 * Driver login screen.
 */
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, StyleSheet, Alert, ActivityIndicator } from 'react-native';
import { useAuthStore } from '../../stores/auth';

export default function LoginScreen() {
  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const { login } = useAuthStore();

  const handleLogin = async () => {
    if (!phone || !password) {
      Alert.alert('Error', 'Please enter phone and password');
      return;
    }

    setLoading(true);
    try {
      await login(phone, password);
    } catch (error: any) {
      Alert.alert('Login Failed', error.message || 'Please check your credentials');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>RESTO360</Text>
        <Text style={styles.subtitle}>Driver App</Text>
      </View>

      <View style={styles.form}>
        <TextInput
          style={styles.input}
          placeholder="Phone number"
          value={phone}
          onChangeText={setPhone}
          keyboardType="phone-pad"
          autoCapitalize="none"
        />

        <TextInput
          style={styles.input}
          placeholder="Password"
          value={password}
          onChangeText={setPassword}
          secureTextEntry
        />

        <TouchableOpacity
          style={[styles.button, loading && styles.buttonDisabled]}
          onPress={handleLogin}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator color="white" />
          ) : (
            <Text style={styles.buttonText}>Sign In</Text>
          )}
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 20,
    justifyContent: 'center',
  },
  header: {
    alignItems: 'center',
    marginBottom: 40,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#4CAF50',
  },
  subtitle: {
    fontSize: 18,
    color: '#666',
    marginTop: 8,
  },
  form: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 15,
    fontSize: 16,
    marginBottom: 15,
  },
  button: {
    backgroundColor: '#4CAF50',
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
  },
  buttonDisabled: {
    opacity: 0.7,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
```

Create apps/mobile/apps/driver/app/(main)/_layout.tsx:
```tsx
/**
 * Main app layout with bottom tabs.
 */
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';

export default function MainLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: '#4CAF50',
        tabBarInactiveTintColor: '#999',
        headerShown: true,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Dashboard',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="deliveries"
        options={{
          title: 'Deliveries',
          headerShown: false,
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="bicycle" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: 'Profile',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="person" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
```

Create apps/mobile/apps/driver/app/(main)/index.tsx:
```tsx
/**
 * Driver dashboard with availability toggle and stats.
 */
import { View, Text, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { useState, useEffect, useCallback } from 'react';
import { useAuthStore } from '../../stores/auth';
import { api } from '../../services/api';
import { startLocationTracking, stopLocationTracking } from '../../services/location';
import AvailabilityToggle from '../../components/AvailabilityToggle';

export default function DashboardScreen() {
  const { driver, updateDriver } = useAuthStore();
  const [refreshing, setRefreshing] = useState(false);
  const [todayStats, setTodayStats] = useState({ deliveries: 0, earnings: 0 });

  const loadData = useCallback(async () => {
    try {
      const profile = await api.getDriverProfile();
      updateDriver(profile);
    } catch (error) {
      console.error('Failed to load profile:', error);
    }
  }, [updateDriver]);

  const handleToggleAvailability = async () => {
    if (!driver) return;

    try {
      const updated = await api.toggleAvailability(driver.id);
      updateDriver(updated);

      // Start/stop location tracking based on availability
      if (updated.is_available) {
        await startLocationTracking(driver.id);
      } else {
        await stopLocationTracking();
      }
    } catch (error) {
      console.error('Failed to toggle availability:', error);
    }
  };

  const onRefresh = async () => {
    setRefreshing(true);
    await loadData();
    setRefreshing(false);
  };

  useEffect(() => {
    loadData();
  }, [loadData]);

  if (!driver) {
    return (
      <View style={styles.container}>
        <Text>Loading...</Text>
      </View>
    );
  }

  return (
    <ScrollView
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
    >
      <View style={styles.header}>
        <Text style={styles.greeting}>Hello, {driver.user_name || 'Driver'}!</Text>
        <AvailabilityToggle
          isAvailable={driver.is_available}
          onToggle={handleToggleAvailability}
        />
      </View>

      <View style={styles.statsContainer}>
        <Text style={styles.sectionTitle}>Today's Stats</Text>
        <View style={styles.statsRow}>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{todayStats.deliveries}</Text>
            <Text style={styles.statLabel}>Deliveries</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{todayStats.earnings.toLocaleString()} XOF</Text>
            <Text style={styles.statLabel}>Earnings</Text>
          </View>
        </View>
      </View>

      <View style={styles.statsContainer}>
        <Text style={styles.sectionTitle}>All Time</Text>
        <View style={styles.statsRow}>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{driver.total_deliveries}</Text>
            <Text style={styles.statLabel}>Total Deliveries</Text>
          </View>
          <View style={styles.statCard}>
            <Text style={styles.statValue}>{driver.average_rating.toFixed(1)}</Text>
            <Text style={styles.statLabel}>Rating</Text>
          </View>
        </View>
      </View>

      <View style={styles.vehicleInfo}>
        <Text style={styles.sectionTitle}>Vehicle</Text>
        <Text style={styles.vehicleText}>
          {driver.vehicle_type.charAt(0).toUpperCase() + driver.vehicle_type.slice(1)}
          {driver.vehicle_plate ? ` - ${driver.vehicle_plate}` : ''}
        </Text>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: 'white',
    padding: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  greeting: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  statsContainer: {
    backgroundColor: 'white',
    margin: 15,
    marginBottom: 0,
    padding: 15,
    borderRadius: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 15,
    color: '#666',
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  statCard: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4CAF50',
  },
  statLabel: {
    fontSize: 14,
    color: '#999',
    marginTop: 4,
  },
  vehicleInfo: {
    backgroundColor: 'white',
    margin: 15,
    padding: 15,
    borderRadius: 12,
  },
  vehicleText: {
    fontSize: 16,
  },
});
```

Create apps/mobile/apps/driver/hooks/useDeliveries.ts:
```typescript
/**
 * Hook for fetching and managing deliveries.
 */
import { useState, useEffect, useCallback } from 'react';
import { api } from '../services/api';

export interface Delivery {
  id: string;
  order_number: number;
  status: string;
  pickup_address: string;
  delivery_address: string;
  delivery_lat: number;
  delivery_lng: number;
  delivery_notes: string;
  delivery_fee: number;
  customer_name: string;
  customer_phone: string;
  estimated_delivery_time: string | null;
  created_at: string;
}

export function useDeliveries() {
  const [deliveries, setDeliveries] = useState<Delivery[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchDeliveries = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await api.getActiveDeliveries();
      setDeliveries(data);
    } catch (err: any) {
      setError(err.message || 'Failed to fetch deliveries');
    } finally {
      setLoading(false);
    }
  }, []);

  const refreshDeliveries = async () => {
    await fetchDeliveries();
  };

  useEffect(() => {
    fetchDeliveries();
  }, [fetchDeliveries]);

  return {
    deliveries,
    loading,
    error,
    refresh: refreshDeliveries,
  };
}
```

Create apps/mobile/apps/driver/components/DeliveryCard.tsx:
```tsx
/**
 * Card component for displaying a delivery.
 */
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { Delivery } from '../hooks/useDeliveries';

interface DeliveryCardProps {
  delivery: Delivery;
}

const STATUS_COLORS: Record<string, string> = {
  assigned: '#2196F3',
  picked_up: '#FF9800',
  en_route: '#4CAF50',
};

const STATUS_LABELS: Record<string, string> = {
  assigned: 'Assigned',
  picked_up: 'Picked Up',
  en_route: 'En Route',
};

export default function DeliveryCard({ delivery }: DeliveryCardProps) {
  const statusColor = STATUS_COLORS[delivery.status] || '#999';

  return (
    <TouchableOpacity
      style={styles.card}
      onPress={() => router.push(`/deliveries/${delivery.id}`)}
    >
      <View style={styles.header}>
        <Text style={styles.orderNumber}>Order #{delivery.order_number}</Text>
        <View style={[styles.statusBadge, { backgroundColor: statusColor }]}>
          <Text style={styles.statusText}>{STATUS_LABELS[delivery.status]}</Text>
        </View>
      </View>

      <View style={styles.addressSection}>
        <View style={styles.addressRow}>
          <Ionicons name="restaurant" size={16} color="#4CAF50" />
          <Text style={styles.addressText} numberOfLines={1}>
            {delivery.pickup_address}
          </Text>
        </View>
        <View style={styles.addressRow}>
          <Ionicons name="location" size={16} color="#F44336" />
          <Text style={styles.addressText} numberOfLines={1}>
            {delivery.delivery_address}
          </Text>
        </View>
      </View>

      <View style={styles.footer}>
        <Text style={styles.customer}>
          {delivery.customer_name} - {delivery.customer_phone}
        </Text>
        <Text style={styles.fee}>{delivery.delivery_fee.toLocaleString()} XOF</Text>
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 15,
    marginHorizontal: 15,
    marginVertical: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  orderNumber: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '600',
  },
  addressSection: {
    marginBottom: 12,
  },
  addressRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  addressText: {
    marginLeft: 8,
    flex: 1,
    color: '#666',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 12,
  },
  customer: {
    color: '#666',
    fontSize: 14,
  },
  fee: {
    fontWeight: 'bold',
    color: '#4CAF50',
  },
});
```

Create apps/mobile/apps/driver/components/AvailabilityToggle.tsx:
```tsx
/**
 * Toggle switch for driver availability.
 */
import { View, Text, Switch, StyleSheet } from 'react-native';

interface AvailabilityToggleProps {
  isAvailable: boolean;
  onToggle: () => void;
}

export default function AvailabilityToggle({ isAvailable, onToggle }: AvailabilityToggleProps) {
  return (
    <View style={styles.container}>
      <Text style={[styles.status, isAvailable ? styles.online : styles.offline]}>
        {isAvailable ? 'Online' : 'Offline'}
      </Text>
      <Switch
        value={isAvailable}
        onValueChange={onToggle}
        trackColor={{ false: '#ccc', true: '#81C784' }}
        thumbColor={isAvailable ? '#4CAF50' : '#f4f3f4'}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  status: {
    marginRight: 10,
    fontWeight: '600',
    fontSize: 14,
  },
  online: {
    color: '#4CAF50',
  },
  offline: {
    color: '#999',
  },
});
```
  </action>
  <verify>
    - App layout correctly routes to auth or main based on auth state
    - Login screen has phone/password inputs and calls login
    - Dashboard shows availability toggle and stats
    - DeliveryCard component renders properly
  </verify>
  <done>App layout, auth, dashboard, and delivery list foundation created</done>
</task>

</tasks>

<verification>
1. Project structure: `ls -la apps/mobile/apps/driver/`
2. TypeScript compiles: `cd apps/mobile/apps/driver && npx tsc --noEmit`
3. Dependencies installed: Check package.json has all required deps
4. Services export correctly: Verify imports work
</verification>

<success_criteria>
- [ ] Expo project created with all dependencies
- [ ] Auth flow with secure token storage
- [ ] Background location tracking configured
- [ ] Basic screens (login, dashboard) created
- [ ] Services (API, location, WebSocket) implemented
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery/05-03-SUMMARY.md`
</output>
