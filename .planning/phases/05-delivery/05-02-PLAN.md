---
phase: 05-delivery
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/apps/delivery/models.py
  - apps/api/apps/delivery/serializers.py
  - apps/api/apps/delivery/views.py
  - apps/api/apps/delivery/urls.py
  - apps/api/apps/delivery/services/__init__.py
  - apps/api/apps/delivery/services/assignment.py
  - apps/api/apps/delivery/consumers.py
  - apps/api/apps/delivery/routing.py
  - apps/api/apps/delivery/tasks.py
  - apps/api/apps/delivery/tests/factories.py
  - apps/api/apps/delivery/tests/test_delivery.py
  - apps/api/apps/delivery/tests/test_assignment.py
  - apps/api/apps/delivery/tests/test_consumers.py
  - apps/api/config/asgi.py
autonomous: true

must_haves:
  truths:
    - "Delivery record is created when order marked for delivery"
    - "System assigns nearest available driver automatically"
    - "Driver status flows through pending_assignment -> assigned -> picked_up -> en_route -> delivered"
    - "Customer can track delivery location in real-time"
    - "Delivery can be confirmed with photo or signature proof"
  artifacts:
    - path: "apps/api/apps/delivery/models.py"
      provides: "Delivery model with FSM status and proof fields"
      contains: "FSMField"
    - path: "apps/api/apps/delivery/services/assignment.py"
      provides: "Nearest driver assignment algorithm"
      contains: "ST_DWithin"
    - path: "apps/api/apps/delivery/consumers.py"
      provides: "WebSocket consumers for location tracking"
      exports: ["DriverLocationConsumer", "DeliveryTrackingConsumer"]
  key_links:
    - from: "apps/api/apps/delivery/services/assignment.py"
      to: "apps/api/apps/delivery/models.py"
      via: "select_for_update() for race-safe assignment"
      pattern: "select_for_update"
    - from: "apps/api/apps/delivery/consumers.py"
      to: "channel_layer.group_send"
      via: "Real-time location broadcasting"
      pattern: "group_send"
    - from: "apps/api/apps/delivery/views.py"
      to: "apps/api/apps/delivery/services/assignment.py"
      via: "DeliveryViewSet.assign action triggers assign_driver_to_delivery"
      pattern: "Manual driver assignment override (DEL-05)"
---

<objective>
Create Delivery model with assignment algorithm and real-time tracking WebSocket

Purpose: Enable automatic driver assignment to delivery orders with real-time location tracking for customers. This is the core delivery workflow.

Output:
- Delivery model with FSM status transitions
- Nearest driver assignment algorithm using PostGIS spatial queries
- WebSocket consumers for driver location streaming and customer tracking
- API endpoints for delivery management and confirmation
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-delivery/05-RESEARCH.md
@.planning/phases/05-delivery/05-01-SUMMARY.md

# Prior patterns
@apps/api/apps/orders/consumers.py
@apps/api/apps/orders/middleware.py
@apps/api/apps/payments/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Delivery model with FSM status transitions</name>
  <files>
    apps/api/apps/delivery/models.py
  </files>
  <action>
Add to apps/delivery/models.py (after Driver model):

```python
from django_fsm import FSMField, transition
from django.contrib.gis.db import models as gis_models


class DeliveryStatus(models.TextChoices):
    """Delivery status enumeration."""
    PENDING_ASSIGNMENT = "pending_assignment", "Pending Assignment"
    ASSIGNED = "assigned", "Assigned"
    PICKED_UP = "picked_up", "Picked Up"
    EN_ROUTE = "en_route", "En Route"
    DELIVERED = "delivered", "Delivered"
    CANCELLED = "cancelled", "Cancelled"


class ProofType(models.TextChoices):
    """Proof of delivery type."""
    PHOTO = "photo", "Photo"
    SIGNATURE = "signature", "Signature"
    NONE = "none", "None"


class Delivery(TenantModel):
    """
    Delivery record linking order to driver.

    Status flow:
    pending_assignment -> assigned -> picked_up -> en_route -> delivered
                      \-> cancelled (from any state)
    """

    order = models.OneToOneField(
        'orders.Order',
        on_delete=models.CASCADE,
        related_name='delivery'
    )
    driver = models.ForeignKey(
        Driver,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='deliveries'
    )
    zone = models.ForeignKey(
        DeliveryZone,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='deliveries'
    )

    # Status with FSM
    status = FSMField(
        default=DeliveryStatus.PENDING_ASSIGNMENT,
        choices=DeliveryStatus.choices,
        protected=True
    )

    # Addresses
    pickup_address = models.TextField(
        help_text="Restaurant address (copied at creation)"
    )
    pickup_location = gis_models.PointField(
        geography=True,
        srid=4326,
        null=True,
        blank=True
    )
    delivery_address = models.TextField(
        help_text="Customer delivery address"
    )
    delivery_location = gis_models.PointField(
        geography=True,
        srid=4326,
        help_text="Customer delivery coordinates"
    )
    delivery_notes = models.TextField(
        blank=True,
        help_text="Delivery instructions from customer"
    )

    # Fees
    delivery_fee = models.PositiveIntegerField(
        help_text="Delivery fee charged in XOF"
    )

    # Timestamps
    assigned_at = models.DateTimeField(null=True, blank=True)
    picked_up_at = models.DateTimeField(null=True, blank=True)
    en_route_at = models.DateTimeField(null=True, blank=True)
    delivered_at = models.DateTimeField(null=True, blank=True)
    cancelled_at = models.DateTimeField(null=True, blank=True)
    cancelled_reason = models.TextField(blank=True)

    # Estimated time
    estimated_delivery_time = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Estimated time of delivery"
    )

    # Proof of delivery
    proof_type = models.CharField(
        max_length=20,
        choices=ProofType.choices,
        default=ProofType.NONE
    )
    proof_photo = models.ImageField(
        upload_to='delivery_proofs/',
        null=True,
        blank=True
    )
    proof_signature = models.TextField(
        blank=True,
        help_text="Base64-encoded signature image"
    )
    recipient_name = models.CharField(
        max_length=100,
        blank=True,
        help_text="Name of person who received delivery"
    )

    # Customer info (copied from order for quick access)
    customer_name = models.CharField(max_length=100, blank=True)
    customer_phone = models.CharField(max_length=20, blank=True)

    all_objects = models.Manager()
    objects = TenantManager()

    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = 'deliveries'

    def __str__(self):
        return f"Delivery #{self.order.order_number}"

    # FSM Transitions

    @transition(
        field=status,
        source=DeliveryStatus.PENDING_ASSIGNMENT,
        target=DeliveryStatus.ASSIGNED
    )
    def assign(self, driver: 'Driver'):
        """Assign a driver to this delivery."""
        from django.utils import timezone
        self.driver = driver
        self.assigned_at = timezone.now()

    @transition(
        field=status,
        source=DeliveryStatus.ASSIGNED,
        target=DeliveryStatus.PICKED_UP
    )
    def mark_picked_up(self):
        """Driver has picked up the order from restaurant."""
        from django.utils import timezone
        self.picked_up_at = timezone.now()

    @transition(
        field=status,
        source=DeliveryStatus.PICKED_UP,
        target=DeliveryStatus.EN_ROUTE
    )
    def mark_en_route(self):
        """Driver is on the way to customer."""
        from django.utils import timezone
        self.en_route_at = timezone.now()

    @transition(
        field=status,
        source=DeliveryStatus.EN_ROUTE,
        target=DeliveryStatus.DELIVERED
    )
    def mark_delivered(self, proof_type: str, proof_data: str = '', recipient_name: str = ''):
        """
        Mark delivery as complete with proof.

        Args:
            proof_type: 'photo' or 'signature'
            proof_data: Base64 image data (for signature) or will be set separately (for photo)
            recipient_name: Name of person who received
        """
        from django.utils import timezone
        self.delivered_at = timezone.now()
        self.proof_type = proof_type
        self.recipient_name = recipient_name
        if proof_type == ProofType.SIGNATURE:
            self.proof_signature = proof_data

    @transition(
        field=status,
        source=[
            DeliveryStatus.PENDING_ASSIGNMENT,
            DeliveryStatus.ASSIGNED,
            DeliveryStatus.PICKED_UP,
            DeliveryStatus.EN_ROUTE,
        ],
        target=DeliveryStatus.CANCELLED
    )
    def cancel(self, reason: str = ''):
        """Cancel this delivery."""
        from django.utils import timezone
        self.cancelled_at = timezone.now()
        self.cancelled_reason = reason
        # Make driver available again if was assigned
        if self.driver and not self.driver.is_available:
            self.driver.go_online()
```

Run: `python manage.py makemigrations delivery`
  </action>
  <verify>
    - Delivery model has FSMField for status
    - All transitions defined with proper source/target states
    - Migration generated successfully
  </verify>
  <done>Delivery model with FSM status transitions and proof of delivery fields created</done>
</task>

<task type="auto">
  <name>Task 2: Create nearest driver assignment service</name>
  <files>
    apps/api/apps/delivery/services/__init__.py
    apps/api/apps/delivery/services/assignment.py
  </files>
  <action>
Create apps/delivery/services/__init__.py:
```python
"""Delivery services."""

from .assignment import (
    find_nearest_available_driver,
    assign_driver_to_delivery,
    create_delivery_for_order,
)

__all__ = [
    'find_nearest_available_driver',
    'assign_driver_to_delivery',
    'create_delivery_for_order',
]
```

Create apps/delivery/services/assignment.py:
```python
"""Driver assignment algorithm using PostGIS spatial queries."""

from datetime import timedelta
from typing import Optional

from django.contrib.gis.db.models.functions import Distance
from django.contrib.gis.geos import Point
from django.db import transaction
from django.utils import timezone

from apps.delivery.models import Delivery, DeliveryStatus, DeliveryZone, Driver
from apps.orders.models import Order


def find_nearest_available_driver(
    restaurant,
    pickup_location: Point,
    max_distance_km: float = 10.0,
    max_stale_minutes: int = 5
) -> Optional[Driver]:
    """
    Find the nearest available driver within range.

    Uses PostGIS ST_DWithin for efficient spatial index usage,
    then orders by distance using the <-> operator.

    Args:
        restaurant: The restaurant (for tenant filtering)
        pickup_location: Point where driver needs to pick up order
        max_distance_km: Maximum distance in kilometers (default 10km)
        max_stale_minutes: Reject drivers with location older than this (default 5min)

    Returns:
        The nearest available Driver, or None if none available
    """
    # Only consider drivers with recent location updates
    stale_threshold = timezone.now() - timedelta(minutes=max_stale_minutes)

    # Convert km to meters (PostGIS geography uses meters)
    max_distance_meters = max_distance_km * 1000

    # Find available drivers ordered by distance
    # Using ST_DWithin first for index usage, then ordering by actual distance
    drivers = Driver.objects.filter(
        restaurant=restaurant,
        is_available=True,
        current_location__isnull=False,
        location_updated_at__gte=stale_threshold
    ).filter(
        # ST_DWithin for efficient spatial index filtering
        current_location__dwithin=(pickup_location, max_distance_meters)
    ).annotate(
        distance=Distance('current_location', pickup_location)
    ).order_by('distance')

    # Return first (nearest) driver, or None
    return drivers.first()


@transaction.atomic
def assign_driver_to_delivery(delivery_id, max_distance_km: float = 10.0) -> Optional[Delivery]:
    """
    Assign the nearest available driver to a delivery.

    Uses select_for_update to prevent race conditions when
    multiple deliveries are assigned simultaneously.

    Args:
        delivery_id: UUID of the delivery to assign
        max_distance_km: Maximum distance for driver search

    Returns:
        The updated Delivery with driver assigned, or None if no driver available
    """
    # Lock the delivery row to prevent concurrent assignment attempts
    delivery = Delivery.all_objects.select_for_update().get(id=delivery_id)

    if delivery.driver is not None:
        return delivery  # Already assigned

    if delivery.status != DeliveryStatus.PENDING_ASSIGNMENT:
        return None  # Wrong status for assignment

    # Get pickup location from delivery (restaurant location)
    if not delivery.pickup_location:
        return None  # No pickup location set

    pickup_location = delivery.pickup_location

    driver = find_nearest_available_driver(
        restaurant=delivery.restaurant,
        pickup_location=pickup_location,
        max_distance_km=max_distance_km
    )

    if driver is None:
        return None  # No driver available

    # Lock the driver row to prevent double-assignment
    driver = Driver.all_objects.select_for_update().get(id=driver.id)

    # Double-check driver is still available (may have been assigned while we were checking)
    if not driver.is_available:
        return None

    # Perform assignment using FSM transition
    delivery.assign(driver)
    delivery.save()

    # Mark driver as busy (not available for other deliveries)
    driver.is_available = False
    driver.save(update_fields=['is_available'])

    return delivery


def create_delivery_for_order(
    order: Order,
    delivery_address: str,
    delivery_lat: float,
    delivery_lng: float,
    delivery_notes: str = ''
) -> Delivery:
    """
    Create a Delivery record for an order.

    Args:
        order: The Order to create delivery for
        delivery_address: Customer's delivery address
        delivery_lat: Delivery latitude
        delivery_lng: Delivery longitude
        delivery_notes: Optional delivery instructions

    Returns:
        Created Delivery object
    """
    restaurant = order.restaurant
    delivery_point = Point(delivery_lng, delivery_lat, srid=4326)  # GIS: lng, lat

    # Find zone for delivery address
    zone = DeliveryZone.find_zone_for_location(
        restaurant=restaurant,
        lat=delivery_lat,
        lng=delivery_lng
    )

    if not zone:
        raise ValueError("Delivery address is outside all delivery zones")

    # Get restaurant location for pickup
    pickup_location = None
    if restaurant.latitude and restaurant.longitude:
        pickup_location = Point(
            float(restaurant.longitude),
            float(restaurant.latitude),
            srid=4326
        )

    # Calculate estimated delivery time
    estimated_minutes = zone.estimated_time_minutes
    estimated_delivery = timezone.now() + timedelta(minutes=estimated_minutes)

    delivery = Delivery.objects.create(
        restaurant=restaurant,
        order=order,
        zone=zone,
        pickup_address=restaurant.address or '',
        pickup_location=pickup_location,
        delivery_address=delivery_address,
        delivery_location=delivery_point,
        delivery_notes=delivery_notes,
        delivery_fee=zone.delivery_fee,
        estimated_delivery_time=estimated_delivery,
        customer_name=order.customer_name,
        customer_phone=order.customer_phone,
    )

    return delivery
```
  </action>
  <verify>
    - find_nearest_available_driver uses ST_DWithin and Distance
    - assign_driver_to_delivery uses select_for_update for race safety
    - create_delivery_for_order validates zone and creates delivery
  </verify>
  <done>Assignment service with race-safe nearest driver algorithm created</done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket consumers for real-time tracking</name>
  <files>
    apps/api/apps/delivery/consumers.py
    apps/api/apps/delivery/routing.py
    apps/api/config/asgi.py
  </files>
  <action>
Create apps/delivery/consumers.py:
```python
"""WebSocket consumers for delivery tracking."""

import json
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.db import database_sync_to_async
from django.utils import timezone


class DriverLocationConsumer(AsyncJsonWebsocketConsumer):
    """
    WebSocket for driver location updates.

    Driver connects and sends location updates.
    System broadcasts to all subscribers (kitchen, customer tracking).

    URL: /ws/driver/{driver_id}/location/?token={jwt}
    """

    async def connect(self):
        """Handle WebSocket connection."""
        # Get user from JWT middleware
        self.user = self.scope.get('user')
        if not self.user or not self.user.is_authenticated:
            await self.close(code=4001)  # Not authenticated
            return

        self.driver_id = self.scope['url_route']['kwargs']['driver_id']

        # Verify user is this driver
        is_valid = await self.verify_driver_ownership()
        if not is_valid:
            await self.close(code=4003)  # Not authorized
            return

        # Join driver location group
        self.group_name = f'driver_location_{self.driver_id}'
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        await self.accept()

    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        if hasattr(self, 'group_name'):
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )

    async def receive_json(self, content):
        """Handle incoming messages from driver."""
        msg_type = content.get('type')

        if msg_type == 'location_update':
            lat = content.get('lat')
            lng = content.get('lng')
            accuracy = content.get('accuracy')
            heading = content.get('heading')
            speed = content.get('speed')

            if lat is not None and lng is not None:
                # Save to database
                await self.save_driver_location(lat, lng)

                # Broadcast to all subscribers
                await self.channel_layer.group_send(
                    self.group_name,
                    {
                        'type': 'driver_location',
                        'driver_id': self.driver_id,
                        'lat': lat,
                        'lng': lng,
                        'accuracy': accuracy,
                        'heading': heading,
                        'speed': speed,
                        'timestamp': timezone.now().isoformat()
                    }
                )

    async def driver_location(self, event):
        """Send location update to subscriber."""
        await self.send_json({
            'type': 'location',
            'driver_id': event['driver_id'],
            'lat': event['lat'],
            'lng': event['lng'],
            'accuracy': event.get('accuracy'),
            'heading': event.get('heading'),
            'speed': event.get('speed'),
            'timestamp': event['timestamp']
        })

    @database_sync_to_async
    def verify_driver_ownership(self) -> bool:
        """Verify user owns this driver profile."""
        from apps.delivery.models import Driver
        try:
            driver = Driver.all_objects.get(id=self.driver_id)
            return str(driver.user_id) == str(self.user.id)
        except Driver.DoesNotExist:
            return False

    @database_sync_to_async
    def save_driver_location(self, lat: float, lng: float):
        """Save driver location to database."""
        from apps.delivery.models import Driver
        try:
            driver = Driver.all_objects.get(id=self.driver_id)
            driver.update_location(lat, lng)
        except Driver.DoesNotExist:
            pass


class DeliveryTrackingConsumer(AsyncJsonWebsocketConsumer):
    """
    WebSocket for customers tracking their delivery.

    Subscribes to driver location for a specific delivery.

    URL: /ws/delivery/{delivery_id}/track/?token={jwt}
    """

    async def connect(self):
        """Handle WebSocket connection."""
        self.delivery_id = self.scope['url_route']['kwargs']['delivery_id']

        # For customer tracking, we allow anonymous access with delivery ID
        # In production, you may want to add phone number verification
        delivery_info = await self.get_delivery_info()
        if not delivery_info:
            await self.close(code=4004)  # Delivery not found
            return

        self.driver_id = delivery_info.get('driver_id')

        await self.accept()

        # Send initial delivery state
        await self.send_json({
            'type': 'delivery_info',
            'delivery': delivery_info
        })

        # Subscribe to driver location if driver is assigned
        if self.driver_id:
            self.group_name = f'driver_location_{self.driver_id}'
            await self.channel_layer.group_add(
                self.group_name,
                self.channel_name
            )

    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        if hasattr(self, 'group_name'):
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )

    async def driver_location(self, event):
        """Forward driver location to customer."""
        await self.send_json({
            'type': 'driver_location',
            'lat': event['lat'],
            'lng': event['lng'],
            'heading': event.get('heading'),
            'timestamp': event['timestamp']
        })

    async def delivery_status_update(self, event):
        """Send delivery status update to customer."""
        await self.send_json({
            'type': 'status_update',
            'status': event['status'],
            'timestamp': event['timestamp']
        })

    @database_sync_to_async
    def get_delivery_info(self) -> dict:
        """Get delivery information."""
        from apps.delivery.models import Delivery
        try:
            delivery = Delivery.all_objects.select_related(
                'driver', 'driver__user'
            ).get(id=self.delivery_id)

            info = {
                'id': str(delivery.id),
                'status': delivery.status,
                'delivery_address': delivery.delivery_address,
                'estimated_delivery_time': (
                    delivery.estimated_delivery_time.isoformat()
                    if delivery.estimated_delivery_time else None
                ),
                'driver_id': str(delivery.driver_id) if delivery.driver_id else None,
            }

            if delivery.driver:
                info['driver'] = {
                    'name': delivery.driver.user.name,
                    'phone': delivery.driver.phone,
                    'vehicle_type': delivery.driver.vehicle_type,
                }
                if delivery.driver.current_location:
                    info['driver']['lat'] = delivery.driver.current_location.y
                    info['driver']['lng'] = delivery.driver.current_location.x

            return info
        except Delivery.DoesNotExist:
            return None


# Signal functions for broadcasting status updates
async def broadcast_delivery_status(delivery_id: str, status: str):
    """Broadcast delivery status update to tracking subscribers."""
    from channels.layers import get_channel_layer

    channel_layer = get_channel_layer()

    # Get driver ID for this delivery to find the right group
    from apps.delivery.models import Delivery
    try:
        delivery = Delivery.all_objects.get(id=delivery_id)
        if delivery.driver_id:
            group_name = f'driver_location_{delivery.driver_id}'
            await channel_layer.group_send(
                group_name,
                {
                    'type': 'delivery_status_update',
                    'status': status,
                    'timestamp': timezone.now().isoformat()
                }
            )
    except Delivery.DoesNotExist:
        pass
```

Create apps/delivery/routing.py:
```python
"""WebSocket URL routing for delivery."""

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(
        r'ws/driver/(?P<driver_id>[0-9a-f-]+)/location/$',
        consumers.DriverLocationConsumer.as_asgi()
    ),
    re_path(
        r'ws/delivery/(?P<delivery_id>[0-9a-f-]+)/track/$',
        consumers.DeliveryTrackingConsumer.as_asgi()
    ),
]
```

Update apps/api/config/asgi.py to include delivery WebSocket routes:
```python
"""ASGI config for RESTO360 project."""

import os

from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.security.websocket import AllowedHostsOriginValidator
from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.development")

# Initialize Django ASGI application early to populate AppRegistry
django_asgi_app = get_asgi_application()

# Import after Django setup
from apps.orders.middleware import JWTAuthMiddleware
from apps.orders import routing as orders_routing
from apps.delivery import routing as delivery_routing

application = ProtocolTypeRouter(
    {
        "http": django_asgi_app,
        "websocket": AllowedHostsOriginValidator(
            JWTAuthMiddleware(
                URLRouter(
                    orders_routing.websocket_urlpatterns +
                    delivery_routing.websocket_urlpatterns
                )
            )
        ),
    }
)
```
  </action>
  <verify>
    - DriverLocationConsumer receives and broadcasts location updates
    - DeliveryTrackingConsumer subscribes to driver location for a delivery
    - routing.py has both WebSocket URL patterns
    - asgi.py includes delivery routing
  </verify>
  <done>WebSocket consumers for driver location and customer tracking created</done>
</task>

<task type="auto">
  <name>Task 4: Create delivery API endpoints and tests</name>
  <files>
    apps/api/apps/delivery/serializers.py
    apps/api/apps/delivery/views.py
    apps/api/apps/delivery/urls.py
    apps/api/apps/delivery/tests/factories.py
    apps/api/apps/delivery/tests/test_delivery.py
    apps/api/apps/delivery/tests/test_assignment.py
  </files>
  <action>
Add to apps/delivery/serializers.py:
```python
# Add these serializers after existing ones

class DeliverySerializer(serializers.ModelSerializer):
    """Serializer for Delivery model."""

    order_number = serializers.IntegerField(source='order.order_number', read_only=True)
    driver_name = serializers.CharField(source='driver.user.name', read_only=True, allow_null=True)
    zone_name = serializers.CharField(source='zone.name', read_only=True, allow_null=True)
    delivery_lat = serializers.SerializerMethodField()
    delivery_lng = serializers.SerializerMethodField()

    class Meta:
        model = Delivery
        fields = [
            'id', 'order', 'order_number', 'driver', 'driver_name',
            'zone', 'zone_name', 'status',
            'pickup_address', 'delivery_address', 'delivery_lat', 'delivery_lng',
            'delivery_notes', 'delivery_fee',
            'assigned_at', 'picked_up_at', 'en_route_at', 'delivered_at',
            'estimated_delivery_time',
            'customer_name', 'customer_phone',
            'proof_type', 'recipient_name',
            'created_at', 'updated_at'
        ]
        read_only_fields = [
            'status', 'assigned_at', 'picked_up_at', 'en_route_at', 'delivered_at',
            'proof_type', 'recipient_name'
        ]

    def get_delivery_lat(self, obj):
        if obj.delivery_location:
            return obj.delivery_location.y
        return None

    def get_delivery_lng(self, obj):
        if obj.delivery_location:
            return obj.delivery_location.x
        return None


class DeliveryCreateSerializer(serializers.Serializer):
    """Serializer for creating a delivery."""
    order_id = serializers.UUIDField()
    delivery_address = serializers.CharField(max_length=500)
    delivery_lat = serializers.FloatField(min_value=-90, max_value=90)
    delivery_lng = serializers.FloatField(min_value=-180, max_value=180)
    delivery_notes = serializers.CharField(max_length=500, required=False, allow_blank=True)


class DeliveryStatusUpdateSerializer(serializers.Serializer):
    """Serializer for updating delivery status."""
    status = serializers.ChoiceField(choices=[
        'picked_up', 'en_route', 'delivered', 'cancelled'
    ])
    # For delivered status
    proof_type = serializers.ChoiceField(
        choices=[('photo', 'Photo'), ('signature', 'Signature')],
        required=False
    )
    proof_data = serializers.CharField(required=False, allow_blank=True)
    recipient_name = serializers.CharField(max_length=100, required=False, allow_blank=True)
    # For cancelled status
    cancel_reason = serializers.CharField(max_length=500, required=False, allow_blank=True)


class DeliveryConfirmSerializer(serializers.Serializer):
    """Serializer for confirming delivery with proof."""
    proof_type = serializers.ChoiceField(choices=[('photo', 'Photo'), ('signature', 'Signature')])
    proof_data = serializers.CharField(required=False, help_text="Base64 signature data")
    recipient_name = serializers.CharField(max_length=100, required=False, allow_blank=True)


# Import Delivery model at top of file
from .models import DeliveryZone, Driver, Delivery
```

Add to apps/delivery/views.py:
```python
# Add these imports
from .models import Delivery, DeliveryStatus
from .serializers import (
    # ... existing imports ...
    DeliverySerializer,
    DeliveryCreateSerializer,
    DeliveryStatusUpdateSerializer,
    DeliveryConfirmSerializer,
)
from .services import create_delivery_for_order, assign_driver_to_delivery


class DeliveryViewSet(TenantModelViewSet):
    """
    ViewSet for delivery management.

    list: Return all deliveries
    retrieve: Return single delivery
    create: Create delivery for an order
    active: Return driver's active deliveries
    update_status: Transition delivery status
    confirm: Confirm delivery with proof
    assign: Manually trigger driver assignment
    """

    serializer_class = DeliverySerializer

    def get_queryset(self):
        return Delivery.objects.filter(
            restaurant=self.request.restaurant
        ).select_related('order', 'driver__user', 'zone')

    def get_serializer_class(self):
        if self.action == 'create':
            return DeliveryCreateSerializer
        if self.action == 'update_status':
            return DeliveryStatusUpdateSerializer
        if self.action == 'confirm':
            return DeliveryConfirmSerializer
        return DeliverySerializer

    def create(self, request):
        """Create a delivery for an order."""
        serializer = DeliveryCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        from apps.orders.models import Order
        try:
            order = Order.objects.get(
                id=serializer.validated_data['order_id'],
                restaurant=request.restaurant
            )
        except Order.DoesNotExist:
            return Response(
                {'error': 'Order not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        try:
            delivery = create_delivery_for_order(
                order=order,
                delivery_address=serializer.validated_data['delivery_address'],
                delivery_lat=serializer.validated_data['delivery_lat'],
                delivery_lng=serializer.validated_data['delivery_lng'],
                delivery_notes=serializer.validated_data.get('delivery_notes', '')
            )
        except ValueError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

        return Response(
            DeliverySerializer(delivery).data,
            status=status.HTTP_201_CREATED
        )

    @action(detail=False, methods=['get'])
    def active(self, request):
        """
        Get active deliveries for current driver.

        GET /api/v1/delivery/deliveries/active/
        """
        try:
            driver = Driver.objects.get(
                restaurant=request.restaurant,
                user=request.user
            )
        except Driver.DoesNotExist:
            return Response(
                {'error': 'No driver profile found'},
                status=status.HTTP_404_NOT_FOUND
            )

        deliveries = Delivery.objects.filter(
            restaurant=request.restaurant,
            driver=driver,
            status__in=[
                DeliveryStatus.ASSIGNED,
                DeliveryStatus.PICKED_UP,
                DeliveryStatus.EN_ROUTE,
            ]
        ).select_related('order', 'zone')

        return Response(DeliverySerializer(deliveries, many=True).data)

    @action(detail=True, methods=['post'])
    def update_status(self, request, pk=None):
        """
        Update delivery status.

        POST /api/v1/delivery/deliveries/{id}/update_status/
        Body: {"status": "picked_up"}
        """
        delivery = self.get_object()
        serializer = DeliveryStatusUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        new_status = serializer.validated_data['status']

        try:
            if new_status == 'picked_up':
                delivery.mark_picked_up()
            elif new_status == 'en_route':
                delivery.mark_en_route()
            elif new_status == 'delivered':
                delivery.mark_delivered(
                    proof_type=serializer.validated_data.get('proof_type', 'none'),
                    proof_data=serializer.validated_data.get('proof_data', ''),
                    recipient_name=serializer.validated_data.get('recipient_name', '')
                )
            elif new_status == 'cancelled':
                delivery.cancel(
                    reason=serializer.validated_data.get('cancel_reason', '')
                )

            delivery.save()

            # Broadcast status update via WebSocket
            from asgiref.sync import async_to_sync
            from channels.layers import get_channel_layer
            from django.utils import timezone

            if delivery.driver_id:
                channel_layer = get_channel_layer()
                async_to_sync(channel_layer.group_send)(
                    f'driver_location_{delivery.driver_id}',
                    {
                        'type': 'delivery_status_update',
                        'status': delivery.status,
                        'timestamp': timezone.now().isoformat()
                    }
                )

            return Response(DeliverySerializer(delivery).data)

        except Exception as e:
            return Response(
                {'error': f'Invalid status transition: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(detail=True, methods=['post'])
    def confirm(self, request, pk=None):
        """
        Confirm delivery with proof (photo or signature).

        POST /api/v1/delivery/deliveries/{id}/confirm/
        Body: {"proof_type": "signature", "proof_data": "base64...", "recipient_name": "John"}
        """
        delivery = self.get_object()
        serializer = DeliveryConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        if delivery.status != DeliveryStatus.EN_ROUTE:
            return Response(
                {'error': 'Delivery must be en_route to confirm'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            delivery.mark_delivered(
                proof_type=serializer.validated_data['proof_type'],
                proof_data=serializer.validated_data.get('proof_data', ''),
                recipient_name=serializer.validated_data.get('recipient_name', '')
            )

            # Handle photo upload if provided
            if 'proof_photo' in request.FILES:
                delivery.proof_photo = request.FILES['proof_photo']

            delivery.save()

            # Update driver stats and make available
            if delivery.driver:
                delivery.driver.total_deliveries += 1
                delivery.driver.is_available = True
                delivery.driver.save(update_fields=['total_deliveries', 'is_available'])

            return Response(DeliverySerializer(delivery).data)

        except Exception as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(detail=True, methods=['post'])
    def assign(self, request, pk=None):
        """
        Manually trigger driver assignment.

        POST /api/v1/delivery/deliveries/{id}/assign/

        This endpoint allows managers to manually trigger auto-assignment
        or can be extended to accept a specific driver_id for manual override.
        """
        delivery = self.get_object()

        if delivery.status != DeliveryStatus.PENDING_ASSIGNMENT:
            return Response(
                {'error': 'Delivery already assigned or not pending'},
                status=status.HTTP_400_BAD_REQUEST
            )

        result = assign_driver_to_delivery(delivery.id)

        if result is None:
            return Response(
                {'error': 'No available drivers found'},
                status=status.HTTP_404_NOT_FOUND
            )

        return Response(DeliverySerializer(result).data)
```

Update apps/delivery/urls.py to add delivery routes:
```python
"""URL configuration for delivery API."""

from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import DeliveryZoneViewSet, DriverViewSet, DeliveryViewSet

router = DefaultRouter()
router.register('zones', DeliveryZoneViewSet, basename='deliveryzone')
router.register('drivers', DriverViewSet, basename='driver')
router.register('deliveries', DeliveryViewSet, basename='delivery')

urlpatterns = [
    path('', include(router.urls)),
]
```

Update apps/delivery/tests/factories.py:
```python
# Add DeliveryFactory after existing factories

from apps.orders.tests.factories import OrderFactory


class DeliveryFactory(factory.django.DjangoModelFactory):
    """Factory for Delivery model."""

    class Meta:
        model = 'delivery.Delivery'

    restaurant = factory.SubFactory(RestaurantFactory)
    order = factory.SubFactory(
        OrderFactory,
        restaurant=factory.SelfAttribute('..restaurant'),
        order_type='delivery'
    )
    zone = factory.SubFactory(
        DeliveryZoneFactory,
        restaurant=factory.SelfAttribute('..restaurant')
    )
    status = 'pending_assignment'
    pickup_address = factory.LazyAttribute(lambda obj: obj.restaurant.address or "123 Restaurant St")
    pickup_location = factory.LazyFunction(lambda: Point(-4.01, 5.33, srid=4326))
    delivery_address = "456 Customer Ave, Abidjan"
    delivery_location = factory.LazyFunction(lambda: Point(-4.015, 5.335, srid=4326))
    delivery_fee = 1500
    customer_name = factory.Faker('name')
    customer_phone = factory.Faker('phone_number')
```

Create apps/delivery/tests/test_delivery.py:
```python
"""Tests for Delivery model and API."""

import pytest
from django.utils import timezone
from rest_framework import status

from apps.delivery.models import Delivery, DeliveryStatus
from .factories import DeliveryFactory, DriverFactory


@pytest.mark.django_db
class TestDeliveryModel:
    """Tests for Delivery model."""

    def test_create_delivery(self, restaurant, order):
        """Test creating a delivery."""
        from django.contrib.gis.geos import Point
        from apps.delivery.models import DeliveryZone

        zone = DeliveryZone.objects.create(
            restaurant=restaurant,
            name="Test Zone",
            polygon=Polygon([
                (-4.02, 5.32), (-4.02, 5.34), (-4.00, 5.34),
                (-4.00, 5.32), (-4.02, 5.32)
            ], srid=4326),
            delivery_fee=1500,
        )

        delivery = Delivery.objects.create(
            restaurant=restaurant,
            order=order,
            zone=zone,
            pickup_address="Restaurant",
            delivery_address="Customer",
            delivery_location=Point(-4.01, 5.33, srid=4326),
            delivery_fee=1500,
        )

        assert delivery.status == DeliveryStatus.PENDING_ASSIGNMENT
        assert delivery.driver is None

    def test_fsm_assign(self, restaurant):
        """Test assigning driver via FSM transition."""
        delivery = DeliveryFactory(restaurant=restaurant)
        driver = DriverFactory(restaurant=restaurant, is_available=True)

        delivery.assign(driver)
        delivery.save()

        assert delivery.status == DeliveryStatus.ASSIGNED
        assert delivery.driver == driver
        assert delivery.assigned_at is not None

    def test_fsm_full_flow(self, restaurant):
        """Test full delivery status flow."""
        delivery = DeliveryFactory(restaurant=restaurant)
        driver = DriverFactory(restaurant=restaurant)

        # Assign
        delivery.assign(driver)
        delivery.save()
        assert delivery.status == DeliveryStatus.ASSIGNED

        # Pick up
        delivery.mark_picked_up()
        delivery.save()
        assert delivery.status == DeliveryStatus.PICKED_UP

        # En route
        delivery.mark_en_route()
        delivery.save()
        assert delivery.status == DeliveryStatus.EN_ROUTE

        # Deliver
        delivery.mark_delivered(proof_type='signature', proof_data='base64...', recipient_name='John')
        delivery.save()
        assert delivery.status == DeliveryStatus.DELIVERED
        assert delivery.proof_type == 'signature'

    def test_fsm_cancel(self, restaurant):
        """Test cancelling delivery."""
        delivery = DeliveryFactory(restaurant=restaurant)

        delivery.cancel(reason="Customer not available")
        delivery.save()

        assert delivery.status == DeliveryStatus.CANCELLED
        assert delivery.cancelled_reason == "Customer not available"


@pytest.mark.django_db
class TestDeliveryAPI:
    """Tests for delivery API endpoints."""

    def test_list_deliveries(self, auth_client, restaurant):
        """Test listing deliveries."""
        DeliveryFactory(restaurant=restaurant)
        DeliveryFactory(restaurant=restaurant)

        response = auth_client.get('/api/v1/delivery/deliveries/')

        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) == 2

    def test_update_status_picked_up(self, auth_client, restaurant):
        """Test updating delivery status to picked_up."""
        delivery = DeliveryFactory(restaurant=restaurant)
        driver = DriverFactory(restaurant=restaurant)
        delivery.assign(driver)
        delivery.save()

        response = auth_client.post(
            f'/api/v1/delivery/deliveries/{delivery.id}/update_status/',
            {'status': 'picked_up'},
            format='json'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['status'] == DeliveryStatus.PICKED_UP

    def test_confirm_delivery(self, auth_client, restaurant):
        """Test confirming delivery with signature."""
        delivery = DeliveryFactory(restaurant=restaurant)
        driver = DriverFactory(restaurant=restaurant)
        delivery.assign(driver)
        delivery.save()
        delivery.mark_picked_up()
        delivery.save()
        delivery.mark_en_route()
        delivery.save()

        response = auth_client.post(
            f'/api/v1/delivery/deliveries/{delivery.id}/confirm/',
            {
                'proof_type': 'signature',
                'proof_data': 'base64signaturedata',
                'recipient_name': 'John Doe'
            },
            format='json'
        )

        assert response.status_code == status.HTTP_200_OK
        assert response.data['status'] == DeliveryStatus.DELIVERED
        assert response.data['proof_type'] == 'signature'
```

Create apps/delivery/tests/test_assignment.py:
```python
"""Tests for driver assignment service."""

import pytest
from django.contrib.gis.geos import Point, Polygon
from django.utils import timezone
from datetime import timedelta

from apps.delivery.models import DeliveryZone, Driver, Delivery, DeliveryStatus
from apps.delivery.services import (
    find_nearest_available_driver,
    assign_driver_to_delivery,
    create_delivery_for_order,
)
from .factories import DeliveryZoneFactory, DriverFactory, DeliveryFactory


@pytest.mark.django_db
class TestFindNearestDriver:
    """Tests for find_nearest_available_driver."""

    def test_finds_nearest_driver(self, restaurant):
        """Test finding the nearest available driver."""
        # Create two drivers at different distances
        driver_near = DriverFactory(restaurant=restaurant, is_available=True)
        driver_near.update_location(lat=5.33, lng=-4.01)  # Very close

        driver_far = DriverFactory(restaurant=restaurant, is_available=True)
        driver_far.update_location(lat=5.35, lng=-4.03)  # Further away

        pickup = Point(-4.01, 5.33, srid=4326)

        result = find_nearest_available_driver(
            restaurant=restaurant,
            pickup_location=pickup
        )

        assert result == driver_near

    def test_excludes_unavailable_drivers(self, restaurant):
        """Test that unavailable drivers are excluded."""
        driver = DriverFactory(restaurant=restaurant, is_available=False)
        driver.update_location(lat=5.33, lng=-4.01)

        pickup = Point(-4.01, 5.33, srid=4326)

        result = find_nearest_available_driver(
            restaurant=restaurant,
            pickup_location=pickup
        )

        assert result is None

    def test_excludes_stale_locations(self, restaurant):
        """Test that drivers with stale locations are excluded."""
        driver = DriverFactory(restaurant=restaurant, is_available=True)
        driver.current_location = Point(-4.01, 5.33, srid=4326)
        driver.location_updated_at = timezone.now() - timedelta(minutes=10)  # Stale
        driver.save()

        pickup = Point(-4.01, 5.33, srid=4326)

        result = find_nearest_available_driver(
            restaurant=restaurant,
            pickup_location=pickup,
            max_stale_minutes=5
        )

        assert result is None

    def test_excludes_drivers_outside_range(self, restaurant):
        """Test that drivers outside max distance are excluded."""
        driver = DriverFactory(restaurant=restaurant, is_available=True)
        driver.update_location(lat=6.0, lng=-3.0)  # Far away

        pickup = Point(-4.01, 5.33, srid=4326)

        result = find_nearest_available_driver(
            restaurant=restaurant,
            pickup_location=pickup,
            max_distance_km=5  # 5km max
        )

        assert result is None


@pytest.mark.django_db
class TestAssignDriverToDelivery:
    """Tests for assign_driver_to_delivery."""

    def test_assigns_nearest_driver(self, restaurant):
        """Test assigning nearest driver to delivery."""
        # Setup driver
        driver = DriverFactory(restaurant=restaurant, is_available=True)
        driver.update_location(lat=5.33, lng=-4.01)

        # Setup delivery
        delivery = DeliveryFactory(restaurant=restaurant)

        result = assign_driver_to_delivery(delivery.id)

        assert result is not None
        assert result.driver == driver
        assert result.status == DeliveryStatus.ASSIGNED

        # Driver should now be unavailable
        driver.refresh_from_db()
        assert driver.is_available is False

    def test_no_assignment_if_no_drivers(self, restaurant):
        """Test no assignment when no drivers available."""
        delivery = DeliveryFactory(restaurant=restaurant)

        result = assign_driver_to_delivery(delivery.id)

        assert result is None
        delivery.refresh_from_db()
        assert delivery.status == DeliveryStatus.PENDING_ASSIGNMENT

    def test_no_double_assignment(self, restaurant):
        """Test delivery can't be assigned twice."""
        driver1 = DriverFactory(restaurant=restaurant, is_available=True)
        driver1.update_location(lat=5.33, lng=-4.01)

        driver2 = DriverFactory(restaurant=restaurant, is_available=True)
        driver2.update_location(lat=5.33, lng=-4.01)

        delivery = DeliveryFactory(restaurant=restaurant)

        # First assignment
        result1 = assign_driver_to_delivery(delivery.id)
        assert result1.driver is not None

        # Second assignment attempt
        result2 = assign_driver_to_delivery(delivery.id)
        assert result2.driver == result1.driver  # Same driver


@pytest.mark.django_db
class TestCreateDeliveryForOrder:
    """Tests for create_delivery_for_order."""

    def test_creates_delivery(self, restaurant, order):
        """Test creating delivery for order."""
        restaurant.latitude = 5.33
        restaurant.longitude = -4.01
        restaurant.save()

        DeliveryZoneFactory(restaurant=restaurant)

        delivery = create_delivery_for_order(
            order=order,
            delivery_address="123 Customer St",
            delivery_lat=5.33,
            delivery_lng=-4.01,
            delivery_notes="Ring doorbell"
        )

        assert delivery.id is not None
        assert delivery.order == order
        assert delivery.delivery_address == "123 Customer St"
        assert delivery.delivery_notes == "Ring doorbell"
        assert delivery.delivery_fee > 0

    def test_fails_outside_zones(self, restaurant, order):
        """Test creating delivery fails if outside all zones."""
        DeliveryZoneFactory(restaurant=restaurant)

        with pytest.raises(ValueError, match="outside"):
            create_delivery_for_order(
                order=order,
                delivery_address="Far Away",
                delivery_lat=10.0,  # Outside zone
                delivery_lng=10.0,
            )
```
  </action>
  <verify>
    - Run: `docker compose exec api pytest apps/delivery/tests/test_delivery.py apps/delivery/tests/test_assignment.py -v`
    - All delivery tests pass
    - All assignment tests pass
  </verify>
  <done>Delivery API endpoints and comprehensive tests for delivery and assignment created</done>
</task>

</tasks>

<verification>
1. Run migrations: `docker compose exec api python manage.py migrate`
2. Run all new tests: `docker compose exec api pytest apps/delivery/tests/ -v`
3. Test WebSocket connection:
   - Start server with `daphne config.asgi:application`
   - Connect to `ws://localhost:8000/ws/driver/{driver_id}/location/?token=...`
   - Send location update: `{"type": "location_update", "lat": 5.33, "lng": -4.01}`
4. Test delivery API:
   - POST /api/v1/delivery/deliveries/ creates delivery
   - POST /api/v1/delivery/deliveries/{id}/assign/ assigns driver
   - POST /api/v1/delivery/deliveries/{id}/update_status/ transitions status
</verification>

<success_criteria>
- [ ] Delivery model with FSM status transitions created
- [ ] Assignment service with race-safe nearest driver algorithm
- [ ] WebSocket consumers for driver and customer tracking
- [ ] Delivery API endpoints (CRUD + status + assign + confirm)
- [ ] All tests passing (model, service, API)
</success_criteria>

<output>
After completion, create `.planning/phases/05-delivery/05-02-SUMMARY.md`
</output>
