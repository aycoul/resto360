---
phase: 05.5-resto360-lite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/apps/authentication/models.py
  - apps/api/apps/authentication/migrations/0002_restaurant_plan_type.py
  - apps/api/apps/authentication/serializers.py
  - apps/api/apps/authentication/views.py
  - apps/api/apps/authentication/urls.py
  - apps/api/apps/authentication/tests/test_public_registration.py
autonomous: true

must_haves:
  truths:
    - "Visitor can register without existing account"
    - "Registration creates restaurant with plan_type='free'"
    - "Registration creates owner user linked to restaurant"
    - "Registration returns JWT tokens for immediate login"
  artifacts:
    - path: "apps/api/apps/authentication/models.py"
      provides: "Restaurant.plan_type field"
      contains: "plan_type"
    - path: "apps/api/apps/authentication/views.py"
      provides: "PublicRegistrationView"
      exports: ["PublicRegistrationView"]
    - path: "apps/api/apps/authentication/serializers.py"
      provides: "PublicRegistrationSerializer"
      contains: "PublicRegistrationSerializer"
  key_links:
    - from: "apps/api/apps/authentication/views.py"
      to: "Restaurant.objects.create"
      via: "serializer create method"
      pattern: "Restaurant.*create"
    - from: "apps/api/apps/authentication/views.py"
      to: "User.objects.create_user"
      via: "serializer create method"
      pattern: "User.*create"
---

<objective>
Add plan_type field to Restaurant model and create public registration API for self-service signup.

Purpose: Enable anyone to create a free digital menu account without manual intervention, establishing the foundation for the RESTO360 Lite freemium model.

Output: Restaurant model with plan_type (free/pro/full), public registration endpoint that creates restaurant + owner user in single transaction, returns JWT for immediate dashboard access.
</objective>

<execution_context>
@C:\Users\dell\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dell\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05.5-resto360-lite/05.5-CONTEXT.md

# Existing models to extend
@apps/api/apps/authentication/models.py
@apps/api/apps/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plan_type field to Restaurant model</name>
  <files>
    apps/api/apps/authentication/models.py
    apps/api/apps/authentication/migrations/0002_restaurant_plan_type.py
  </files>
  <action>
Add plan_type CharField to Restaurant model with choices:
- ('free', 'Free') - default
- ('pro', 'Pro')
- ('full', 'Full Platform')

Add optional fields for Pro tier branding:
- logo = models.ImageField(upload_to='restaurant_logos/', blank=True, null=True)
- primary_color = models.CharField(max_length=7, blank=True, help_text="Hex color code")
- show_branding = models.BooleanField(default=True, help_text="Show RESTO360 branding on free tier")

The show_branding field defaults to True (free tier shows branding), Pro tier can set to False.

Run: python manage.py makemigrations authentication
Run: python manage.py migrate

Use project pattern: XOF as integer (no decimals), UUID primary keys (already in BaseModel).
  </action>
  <verify>
    python apps/api/manage.py check
    python apps/api/manage.py showmigrations authentication
  </verify>
  <done>
    Restaurant model has plan_type field with free/pro/full choices, migration applied successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public registration endpoint</name>
  <files>
    apps/api/apps/authentication/serializers.py
    apps/api/apps/authentication/views.py
    apps/api/apps/authentication/urls.py
  </files>
  <action>
Create PublicRegistrationSerializer in serializers.py:
- Fields: email, password, password_confirm, restaurant_name, phone
- Validate: password match, email unique, phone unique
- Create method (in transaction):
  1. Generate slug from restaurant_name (slugify + UUID suffix for uniqueness)
  2. Create Restaurant(name=restaurant_name, slug=slug, phone=phone, email=email, plan_type='free')
  3. Create User(phone=phone, email=email, name=restaurant_name + " Owner", role='owner', restaurant=restaurant)
  4. Return both objects

Create PublicRegistrationView in views.py:
- AllowAny permission (public endpoint)
- POST /api/auth/register/
- On success, generate JWT tokens using RefreshToken.for_user()
- Return: { restaurant: {id, slug, name}, user: {id, name, role}, access, refresh }

Add to urls.py:
- path('register/', PublicRegistrationView.as_view(), name='public-register')

Use project patterns:
- Phone as username (Ivory Coast market standard, decision 01-02)
- UUID primary keys (decision 01-02)
- SimpleJWT with 15min access, 7day refresh (decision 01-01)
  </action>
  <verify>
    curl -X POST http://localhost:8000/api/auth/register/ \
      -H "Content-Type: application/json" \
      -d '{"email":"test@example.com","password":"TestPass123!","password_confirm":"TestPass123!","restaurant_name":"Test Restaurant","phone":"+2250700000001"}'
  </verify>
  <done>
    POST /api/auth/register/ creates restaurant + user, returns JWT tokens. Invalid requests return 400 with validation errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write tests for public registration</name>
  <files>
    apps/api/apps/authentication/tests/test_public_registration.py
  </files>
  <action>
Create test file with pytest tests:

1. test_public_registration_success:
   - POST valid data
   - Assert 201 status
   - Assert restaurant created with plan_type='free'
   - Assert user created with role='owner'
   - Assert JWT tokens in response

2. test_public_registration_password_mismatch:
   - POST with mismatched passwords
   - Assert 400 status
   - Assert error message about password mismatch

3. test_public_registration_duplicate_phone:
   - Create existing user with phone
   - POST with same phone
   - Assert 400 status
   - Assert error about duplicate phone

4. test_public_registration_duplicate_email:
   - Create existing user with email
   - POST with same email
   - Assert 400 status
   - Assert error about duplicate email

5. test_public_registration_creates_unique_slug:
   - Create restaurant "Test Restaurant"
   - Register another "Test Restaurant"
   - Assert both have different slugs

Use project test patterns:
- pytest with Django test client
- Factory Boy for fixtures (if existing)
- @pytest.mark.django_db decorator
  </action>
  <verify>
    cd apps/api && python -m pytest apps/authentication/tests/test_public_registration.py -v
  </verify>
  <done>
    All 5 tests pass, covering success case and error scenarios.
  </done>
</task>

</tasks>

<verification>
1. Migration applied without errors
2. API endpoint accessible at /api/auth/register/
3. Registration creates restaurant with plan_type='free'
4. Registration creates owner user
5. JWT tokens returned for immediate login
6. All tests pass
</verification>

<success_criteria>
- Restaurant model has plan_type field (free/pro/full)
- POST /api/auth/register/ creates restaurant + owner in single request
- Response includes JWT tokens for immediate dashboard access
- Invalid registrations return appropriate error messages
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05.5-resto360-lite/05.5-01-SUMMARY.md`
</output>
